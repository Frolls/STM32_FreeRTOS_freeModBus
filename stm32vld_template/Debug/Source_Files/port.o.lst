   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"port.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.global	ulKernelPriority
  19              		.section	.rodata.ulKernelPriority,"a",%progbits
  20              		.align	2
  23              	ulKernelPriority:
  24 0000 F0000000 		.word	240
  25              		.section	.data.uxCriticalNesting,"aw",%progbits
  26              		.align	2
  29              	uxCriticalNesting:
  30 0000 AAAAAAAA 		.word	-1431655766
  31              		.section	.text.pxPortInitialiseStack,"ax",%progbits
  32              		.align	2
  33              		.global	pxPortInitialiseStack
  34              		.thumb
  35              		.thumb_func
  37              	pxPortInitialiseStack:
  38              	.LFB0:
  39              		.file 1 "../Source_Files/port.c"
   1:../Source_Files/port.c **** /*
   2:../Source_Files/port.c ****     FreeRTOS V7.4.0 - Copyright (C) 2013 Real Time Engineers Ltd.
   3:../Source_Files/port.c **** 
   4:../Source_Files/port.c ****     FEATURES AND PORTS ARE ADDED TO FREERTOS ALL THE TIME.  PLEASE VISIT
   5:../Source_Files/port.c ****     http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
   6:../Source_Files/port.c **** 
   7:../Source_Files/port.c ****     ***************************************************************************
   8:../Source_Files/port.c ****      *                                                                       *
   9:../Source_Files/port.c ****      *    FreeRTOS tutorial books are available in pdf and paperback.        *
  10:../Source_Files/port.c ****      *    Complete, revised, and edited pdf reference manuals are also       *
  11:../Source_Files/port.c ****      *    available.                                                         *
  12:../Source_Files/port.c ****      *                                                                       *
  13:../Source_Files/port.c ****      *    Purchasing FreeRTOS documentation will not only help you, by       *
  14:../Source_Files/port.c ****      *    ensuring you get running as quickly as possible and with an        *
  15:../Source_Files/port.c ****      *    in-depth knowledge of how to use FreeRTOS, it will also help       *
  16:../Source_Files/port.c ****      *    the FreeRTOS project to continue with its mission of providing     *
  17:../Source_Files/port.c ****      *    professional grade, cross platform, de facto standard solutions    *
  18:../Source_Files/port.c ****      *    for microcontrollers - completely free of charge!                  *
  19:../Source_Files/port.c ****      *                                                                       *
  20:../Source_Files/port.c ****      *    >>> See http://www.FreeRTOS.org/Documentation for details. <<<     *
  21:../Source_Files/port.c ****      *                                                                       *
  22:../Source_Files/port.c ****      *    Thank you for using FreeRTOS, and thank you for your support!      *
  23:../Source_Files/port.c ****      *                                                                       *
  24:../Source_Files/port.c ****     ***************************************************************************
  25:../Source_Files/port.c **** 
  26:../Source_Files/port.c **** 
  27:../Source_Files/port.c ****     This file is part of the FreeRTOS distribution.
  28:../Source_Files/port.c **** 
  29:../Source_Files/port.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  30:../Source_Files/port.c ****     the terms of the GNU General Public License (version 2) as published by the
  31:../Source_Files/port.c ****     Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
  32:../Source_Files/port.c **** 
  33:../Source_Files/port.c ****     >>>>>>NOTE<<<<<< The modification to the GPL is included to allow you to
  34:../Source_Files/port.c ****     distribute a combined work that includes FreeRTOS without being obliged to
  35:../Source_Files/port.c ****     provide the source code for proprietary components outside of the FreeRTOS
  36:../Source_Files/port.c ****     kernel.
  37:../Source_Files/port.c **** 
  38:../Source_Files/port.c ****     FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
  39:../Source_Files/port.c ****     WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
  40:../Source_Files/port.c ****     FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
  41:../Source_Files/port.c ****     details. You should have received a copy of the GNU General Public License
  42:../Source_Files/port.c ****     and the FreeRTOS license exception along with FreeRTOS; if not itcan be
  43:../Source_Files/port.c ****     viewed here: http://www.freertos.org/a00114.html and also obtained by
  44:../Source_Files/port.c ****     writing to Real Time Engineers Ltd., contact details for whom are available
  45:../Source_Files/port.c ****     on the FreeRTOS WEB site.
  46:../Source_Files/port.c **** 
  47:../Source_Files/port.c ****     1 tab == 4 spaces!
  48:../Source_Files/port.c **** 
  49:../Source_Files/port.c ****     ***************************************************************************
  50:../Source_Files/port.c ****      *                                                                       *
  51:../Source_Files/port.c ****      *    Having a problem?  Start by reading the FAQ "My application does   *
  52:../Source_Files/port.c ****      *    not run, what could be wrong?"                                     *
  53:../Source_Files/port.c ****      *                                                                       *
  54:../Source_Files/port.c ****      *    http://www.FreeRTOS.org/FAQHelp.html                               *
  55:../Source_Files/port.c ****      *                                                                       *
  56:../Source_Files/port.c ****     ***************************************************************************
  57:../Source_Files/port.c **** 
  58:../Source_Files/port.c **** 
  59:../Source_Files/port.c ****     http://www.FreeRTOS.org - Documentation, books, training, latest versions, 
  60:../Source_Files/port.c ****     license and Real Time Engineers Ltd. contact details.
  61:../Source_Files/port.c **** 
  62:../Source_Files/port.c ****     http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
  63:../Source_Files/port.c ****     including FreeRTOS+Trace - an indispensable productivity tool, and our new
  64:../Source_Files/port.c ****     fully thread aware and reentrant UDP/IP stack.
  65:../Source_Files/port.c **** 
  66:../Source_Files/port.c ****     http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High 
  67:../Source_Files/port.c ****     Integrity Systems, who sell the code with commercial support, 
  68:../Source_Files/port.c ****     indemnification and middleware, under the OpenRTOS brand.
  69:../Source_Files/port.c ****     
  70:../Source_Files/port.c ****     http://www.SafeRTOS.com - High Integrity Systems also provide a safety 
  71:../Source_Files/port.c ****     engineered and independently SIL3 certified version for use in safety and 
  72:../Source_Files/port.c ****     mission critical applications that require provable dependability.
  73:../Source_Files/port.c **** */
  74:../Source_Files/port.c **** 
  75:../Source_Files/port.c **** /*-----------------------------------------------------------
  76:../Source_Files/port.c ****  * Implementation of functions defined in portable.h for the ARM CM3 port.
  77:../Source_Files/port.c ****  *----------------------------------------------------------*/
  78:../Source_Files/port.c **** 
  79:../Source_Files/port.c **** /* Scheduler includes. */
  80:../Source_Files/port.c **** #include "FreeRTOS.h"
  81:../Source_Files/port.c **** #include "task.h"
  82:../Source_Files/port.c **** 
  83:../Source_Files/port.c **** /* For backward compatibility, ensure configKERNEL_INTERRUPT_PRIORITY is
  84:../Source_Files/port.c **** defined.  The value should also ensure backward compatibility.
  85:../Source_Files/port.c **** FreeRTOS.org versions prior to V4.4.0 did not include this definition. */
  86:../Source_Files/port.c **** #ifndef configKERNEL_INTERRUPT_PRIORITY
  87:../Source_Files/port.c **** 	#define configKERNEL_INTERRUPT_PRIORITY 255
  88:../Source_Files/port.c **** #endif
  89:../Source_Files/port.c **** 
  90:../Source_Files/port.c **** #ifndef configSYSTICK_CLOCK_HZ
  91:../Source_Files/port.c **** 	#define configSYSTICK_CLOCK_HZ configCPU_CLOCK_HZ
  92:../Source_Files/port.c **** #endif
  93:../Source_Files/port.c **** 
  94:../Source_Files/port.c **** /* Constants required to manipulate the core.  Registers first... */
  95:../Source_Files/port.c **** #define portNVIC_SYSTICK_CTRL_REG			( * ( ( volatile unsigned long * ) 0xe000e010 ) )
  96:../Source_Files/port.c **** #define portNVIC_SYSTICK_LOAD_REG			( * ( ( volatile unsigned long * ) 0xe000e014 ) )
  97:../Source_Files/port.c **** #define portNVIC_SYSTICK_CURRENT_VALUE_REG	( * ( ( volatile unsigned long * ) 0xe000e018 ) )
  98:../Source_Files/port.c **** #define portNVIC_INT_CTRL_REG				( * ( ( volatile unsigned long * ) 0xe000ed04 ) )
  99:../Source_Files/port.c **** #define portNVIC_SYSPRI2_REG				( * ( ( volatile unsigned long * ) 0xe000ed20 ) )
 100:../Source_Files/port.c **** /* ...then bits in the registers. */
 101:../Source_Files/port.c **** #define portNVIC_SYSTICK_CLK_BIT			( 1UL << 2UL )
 102:../Source_Files/port.c **** #define portNVIC_SYSTICK_INT_BIT			( 1UL << 1UL )
 103:../Source_Files/port.c **** #define portNVIC_SYSTICK_ENABLE_BIT			( 1UL << 0UL )
 104:../Source_Files/port.c **** #define portNVIC_SYSTICK_COUNT_FLAG_BIT		( 1UL << 16UL )
 105:../Source_Files/port.c **** #define portNVIC_PENDSVSET_BIT				( 1UL << 28UL )
 106:../Source_Files/port.c **** #define portNVIC_PENDSVCLEAR_BIT 			( 1UL << 27UL )
 107:../Source_Files/port.c **** #define portNVIC_PEND_SYSTICK_CLEAR_BIT		( 1UL << 25UL )
 108:../Source_Files/port.c **** 
 109:../Source_Files/port.c **** #define portNVIC_PENDSV_PRI				( ( ( unsigned long ) configKERNEL_INTERRUPT_PRIORITY ) << 16UL )
 110:../Source_Files/port.c **** #define portNVIC_SYSTICK_PRI			( ( ( unsigned long ) configKERNEL_INTERRUPT_PRIORITY ) << 24UL )
 111:../Source_Files/port.c **** 
 112:../Source_Files/port.c **** /* Constants required to set up the initial stack. */
 113:../Source_Files/port.c **** #define portINITIAL_XPSR			( 0x01000000 )
 114:../Source_Files/port.c **** 
 115:../Source_Files/port.c **** /* The priority used by the kernel is assigned to a variable to make access
 116:../Source_Files/port.c **** from inline assembler easier. */
 117:../Source_Files/port.c **** const unsigned long ulKernelPriority = configKERNEL_INTERRUPT_PRIORITY;
 118:../Source_Files/port.c **** 
 119:../Source_Files/port.c **** /* Each task maintains its own interrupt status in the critical nesting
 120:../Source_Files/port.c **** variable. */
 121:../Source_Files/port.c **** static unsigned portBASE_TYPE uxCriticalNesting = 0xaaaaaaaa;
 122:../Source_Files/port.c **** 
 123:../Source_Files/port.c **** /*
 124:../Source_Files/port.c ****  * Setup the timer to generate the tick interrupts.  The implementation in this
 125:../Source_Files/port.c ****  * file is weak to allow application writers to change the timer used to
 126:../Source_Files/port.c ****  * generate the tick interrupt.
 127:../Source_Files/port.c ****  */
 128:../Source_Files/port.c **** void vPortSetupTimerInterrupt( void );
 129:../Source_Files/port.c **** 
 130:../Source_Files/port.c **** /*
 131:../Source_Files/port.c ****  * Exception handlers.
 132:../Source_Files/port.c ****  */
 133:../Source_Files/port.c **** void xPortPendSVHandler( void ) __attribute__ (( naked ));
 134:../Source_Files/port.c **** void xPortSysTickHandler( void );
 135:../Source_Files/port.c **** void vPortSVCHandler( void ) __attribute__ (( naked ));
 136:../Source_Files/port.c **** 
 137:../Source_Files/port.c **** /*
 138:../Source_Files/port.c ****  * Start first task is a separate function so it can be tested in isolation.
 139:../Source_Files/port.c ****  */
 140:../Source_Files/port.c **** static void prvPortStartFirstTask( void ) __attribute__ (( naked ));
 141:../Source_Files/port.c **** 
 142:../Source_Files/port.c **** /*-----------------------------------------------------------*/
 143:../Source_Files/port.c **** 
 144:../Source_Files/port.c **** /*
 145:../Source_Files/port.c ****  * The number of SysTick increments that make up one tick period.
 146:../Source_Files/port.c ****  */
 147:../Source_Files/port.c **** #if configUSE_TICKLESS_IDLE == 1
 148:../Source_Files/port.c **** 	static unsigned long ulTimerReloadValueForOneTick = 0;
 149:../Source_Files/port.c **** #endif
 150:../Source_Files/port.c **** 
 151:../Source_Files/port.c **** /*
 152:../Source_Files/port.c ****  * The maximum number of tick periods that can be suppressed is limited by the
 153:../Source_Files/port.c ****  * 24 bit resolution of the SysTick timer.
 154:../Source_Files/port.c ****  */
 155:../Source_Files/port.c **** #if configUSE_TICKLESS_IDLE == 1
 156:../Source_Files/port.c **** 	static unsigned long xMaximumPossibleSuppressedTicks = 0;
 157:../Source_Files/port.c **** #endif /* configUSE_TICKLESS_IDLE */
 158:../Source_Files/port.c **** 
 159:../Source_Files/port.c **** /*
 160:../Source_Files/port.c ****  * Compensate for the CPU cycles that pass while the SysTick is stopped (low
 161:../Source_Files/port.c ****  * power functionality only.
 162:../Source_Files/port.c ****  */
 163:../Source_Files/port.c **** #if configUSE_TICKLESS_IDLE == 1
 164:../Source_Files/port.c **** 	static unsigned long ulStoppedTimerCompensation = 0;
 165:../Source_Files/port.c **** #endif /* configUSE_TICKLESS_IDLE */
 166:../Source_Files/port.c **** 
 167:../Source_Files/port.c **** /*-----------------------------------------------------------*/
 168:../Source_Files/port.c **** 
 169:../Source_Files/port.c **** /*
 170:../Source_Files/port.c ****  * See header file for description.
 171:../Source_Files/port.c ****  */
 172:../Source_Files/port.c **** portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvPa
 173:../Source_Files/port.c **** {
  40              		.loc 1 173 0
  41              		.cfi_startproc
  42              		@ args = 0, pretend = 0, frame = 16
  43              		@ frame_needed = 1, uses_anonymous_args = 0
  44              		@ link register save eliminated.
  45 0000 80B4     		push	{r7}
  46              	.LCFI0:
  47              		.cfi_def_cfa_offset 4
  48              		.cfi_offset 7, -4
  49 0002 85B0     		sub	sp, sp, #20
  50              	.LCFI1:
  51              		.cfi_def_cfa_offset 24
  52 0004 00AF     		add	r7, sp, #0
  53              	.LCFI2:
  54              		.cfi_def_cfa_register 7
  55 0006 F860     		str	r0, [r7, #12]
  56 0008 B960     		str	r1, [r7, #8]
  57 000a 7A60     		str	r2, [r7, #4]
 174:../Source_Files/port.c **** 	/* Simulate the stack frame as it would be created by a context switch
 175:../Source_Files/port.c **** 	interrupt. */
 176:../Source_Files/port.c **** 	pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of int
  58              		.loc 1 176 0
  59 000c FB68     		ldr	r3, [r7, #12]
  60 000e A3F10403 		sub	r3, r3, #4
  61 0012 FB60     		str	r3, [r7, #12]
 177:../Source_Files/port.c **** 	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
  62              		.loc 1 177 0
  63 0014 FB68     		ldr	r3, [r7, #12]
  64 0016 4FF08072 		mov	r2, #16777216
  65 001a 1A60     		str	r2, [r3, #0]
 178:../Source_Files/port.c **** 	pxTopOfStack--;
  66              		.loc 1 178 0
  67 001c FB68     		ldr	r3, [r7, #12]
  68 001e A3F10403 		sub	r3, r3, #4
  69 0022 FB60     		str	r3, [r7, #12]
 179:../Source_Files/port.c **** 	*pxTopOfStack = ( portSTACK_TYPE ) pxCode;	/* PC */
  70              		.loc 1 179 0
  71 0024 BA68     		ldr	r2, [r7, #8]
  72 0026 FB68     		ldr	r3, [r7, #12]
  73 0028 1A60     		str	r2, [r3, #0]
 180:../Source_Files/port.c **** 	pxTopOfStack--;
  74              		.loc 1 180 0
  75 002a FB68     		ldr	r3, [r7, #12]
  76 002c A3F10403 		sub	r3, r3, #4
  77 0030 FB60     		str	r3, [r7, #12]
 181:../Source_Files/port.c **** 	*pxTopOfStack = 0;	/* LR */
  78              		.loc 1 181 0
  79 0032 FB68     		ldr	r3, [r7, #12]
  80 0034 4FF00002 		mov	r2, #0
  81 0038 1A60     		str	r2, [r3, #0]
 182:../Source_Files/port.c **** 	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
  82              		.loc 1 182 0
  83 003a FB68     		ldr	r3, [r7, #12]
  84 003c A3F11403 		sub	r3, r3, #20
  85 0040 FB60     		str	r3, [r7, #12]
 183:../Source_Files/port.c **** 	*pxTopOfStack = ( portSTACK_TYPE ) pvParameters;	/* R0 */
  86              		.loc 1 183 0
  87 0042 7A68     		ldr	r2, [r7, #4]
  88 0044 FB68     		ldr	r3, [r7, #12]
  89 0046 1A60     		str	r2, [r3, #0]
 184:../Source_Files/port.c **** 	pxTopOfStack -= 8;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */
  90              		.loc 1 184 0
  91 0048 FB68     		ldr	r3, [r7, #12]
  92 004a A3F12003 		sub	r3, r3, #32
  93 004e FB60     		str	r3, [r7, #12]
 185:../Source_Files/port.c **** 
 186:../Source_Files/port.c **** 	return pxTopOfStack;
  94              		.loc 1 186 0
  95 0050 FB68     		ldr	r3, [r7, #12]
 187:../Source_Files/port.c **** }
  96              		.loc 1 187 0
  97 0052 1846     		mov	r0, r3
  98 0054 07F11407 		add	r7, r7, #20
  99 0058 BD46     		mov	sp, r7
 100 005a 80BC     		pop	{r7}
 101 005c 7047     		bx	lr
 102              		.cfi_endproc
 103              	.LFE0:
 105 005e 00BF     		.section	.text.SVC_Handler,"ax",%progbits
 106              		.align	2
 107              		.global	SVC_Handler
 108              		.thumb
 109              		.thumb_func
 111              	SVC_Handler:
 112              	.LFB1:
 188:../Source_Files/port.c **** /*-----------------------------------------------------------*/
 189:../Source_Files/port.c **** 
 190:../Source_Files/port.c **** void vPortSVCHandler( void )
 191:../Source_Files/port.c **** {
 113              		.loc 1 191 0
 114              		.cfi_startproc
 115              		@ Naked Function: prologue and epilogue provided by programmer.
 116              		@ args = 0, pretend = 0, frame = 0
 117              		@ frame_needed = 1, uses_anonymous_args = 0
 192:../Source_Files/port.c **** 	__asm volatile (
 118              		.loc 1 192 0
 119              	@ 192 "../Source_Files/port.c" 1
 120 0000 064B     			ldr	r3, pxCurrentTCBConst2		
 121 0002 1968     		ldr r1, [r3]					
 122 0004 0868     		ldr r0, [r1]					
 123 0006 B0E8F00F 		ldmia r0!, {r4-r11}				
 124 000a 80F30988 		msr psp, r0						
 125 000e 4FF00000 		mov r0, #0 						
 126 0012 80F31188 		msr	basepri, r0					
 127 0016 4EF00D0E 		orr r14, #0xd					
 128 001a 7047     		bx r14							
 129              										
 130              		.align 2						
 131 001c 00000000 	pxCurrentTCBConst2: .word pxCurrentTCB				
 132              	
 133              	@ 0 "" 2
 193:../Source_Files/port.c **** 					"	ldr	r3, pxCurrentTCBConst2		\n" /* Restore the context. */
 194:../Source_Files/port.c **** 					"	ldr r1, [r3]					\n" /* Use pxCurrentTCBConst to get the pxCurrentTCB address. */
 195:../Source_Files/port.c **** 					"	ldr r0, [r1]					\n" /* The first item in pxCurrentTCB is the task top of stack. */
 196:../Source_Files/port.c **** 					"	ldmia r0!, {r4-r11}				\n" /* Pop the registers that are not automatically saved on exceptio
 197:../Source_Files/port.c **** 					"	msr psp, r0						\n" /* Restore the task stack pointer. */
 198:../Source_Files/port.c **** 					"	mov r0, #0 						\n"
 199:../Source_Files/port.c **** 					"	msr	basepri, r0					\n"
 200:../Source_Files/port.c **** 					"	orr r14, #0xd					\n"
 201:../Source_Files/port.c **** 					"	bx r14							\n"
 202:../Source_Files/port.c **** 					"									\n"
 203:../Source_Files/port.c **** 					"	.align 2						\n"
 204:../Source_Files/port.c **** 					"pxCurrentTCBConst2: .word pxCurrentTCB				\n"
 205:../Source_Files/port.c **** 				);
 206:../Source_Files/port.c **** }
 134              		.loc 1 206 0
 135              		.thumb
 136              		.cfi_endproc
 137              	.LFE1:
 139              		.section	.text.prvPortStartFirstTask,"ax",%progbits
 140              		.align	2
 141              		.thumb
 142              		.thumb_func
 144              	prvPortStartFirstTask:
 145              	.LFB2:
 207:../Source_Files/port.c **** /*-----------------------------------------------------------*/
 208:../Source_Files/port.c **** 
 209:../Source_Files/port.c **** static void prvPortStartFirstTask( void )
 210:../Source_Files/port.c **** {
 146              		.loc 1 210 0
 147              		.cfi_startproc
 148              		@ Naked Function: prologue and epilogue provided by programmer.
 149              		@ args = 0, pretend = 0, frame = 0
 150              		@ frame_needed = 1, uses_anonymous_args = 0
 211:../Source_Files/port.c **** 	__asm volatile(
 151              		.loc 1 211 0
 152              	@ 211 "../Source_Files/port.c" 1
 153 0000 0348     		 ldr r0, =0xE000ED08 	
 154 0002 0068     	 ldr r0, [r0] 			
 155 0004 0068     	 ldr r0, [r0] 			
 156 0006 80F30888 	 msr msp, r0			
 157 000a 62B6     	 cpsie i				
 158 000c 00DF     	 svc 0					
 159 000e 00BF     	 nop					
 160              	
 161              	@ 0 "" 2
 212:../Source_Files/port.c **** 					" ldr r0, =0xE000ED08 	\n" /* Use the NVIC offset register to locate the stack. */
 213:../Source_Files/port.c **** 					" ldr r0, [r0] 			\n"
 214:../Source_Files/port.c **** 					" ldr r0, [r0] 			\n"
 215:../Source_Files/port.c **** 					" msr msp, r0			\n" /* Set the msp back to the start of the stack. */
 216:../Source_Files/port.c **** 					" cpsie i				\n" /* Globally enable interrupts. */
 217:../Source_Files/port.c **** 					" svc 0					\n" /* System call to start first task. */
 218:../Source_Files/port.c **** 					" nop					\n"
 219:../Source_Files/port.c **** 				);
 220:../Source_Files/port.c **** }
 162              		.loc 1 220 0
 163              		.thumb
 164              		.cfi_endproc
 165              	.LFE2:
 167              		.section	.text.xPortStartScheduler,"ax",%progbits
 168              		.align	2
 169              		.global	xPortStartScheduler
 170              		.thumb
 171              		.thumb_func
 173              	xPortStartScheduler:
 174              	.LFB3:
 221:../Source_Files/port.c **** /*-----------------------------------------------------------*/
 222:../Source_Files/port.c **** 
 223:../Source_Files/port.c **** /*
 224:../Source_Files/port.c ****  * See header file for description.
 225:../Source_Files/port.c ****  */
 226:../Source_Files/port.c **** portBASE_TYPE xPortStartScheduler( void )
 227:../Source_Files/port.c **** {
 175              		.loc 1 227 0
 176              		.cfi_startproc
 177              		@ args = 0, pretend = 0, frame = 0
 178              		@ frame_needed = 1, uses_anonymous_args = 0
 179 0000 80B5     		push	{r7, lr}
 180              	.LCFI3:
 181              		.cfi_def_cfa_offset 8
 182              		.cfi_offset 7, -8
 183              		.cfi_offset 14, -4
 184 0002 00AF     		add	r7, sp, #0
 185              	.LCFI4:
 186              		.cfi_def_cfa_register 7
 228:../Source_Files/port.c **** 	/* configMAX_SYSCALL_INTERRUPT_PRIORITY must not be set to 0.
 229:../Source_Files/port.c **** 	See http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
 230:../Source_Files/port.c **** 	configASSERT( configMAX_SYSCALL_INTERRUPT_PRIORITY );
 231:../Source_Files/port.c **** 
 232:../Source_Files/port.c **** 	/* Make PendSV, CallSV and SysTick the same priroity as the kernel. */
 233:../Source_Files/port.c **** 	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
 187              		.loc 1 233 0
 188 0004 4EF62053 		movw	r3, #60704
 189 0008 CEF20003 		movt	r3, 57344
 190 000c 4EF62052 		movw	r2, #60704
 191 0010 CEF20002 		movt	r2, 57344
 192 0014 1268     		ldr	r2, [r2, #0]
 193 0016 42F47002 		orr	r2, r2, #15728640
 194 001a 1A60     		str	r2, [r3, #0]
 234:../Source_Files/port.c **** 	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
 195              		.loc 1 234 0
 196 001c 4EF62053 		movw	r3, #60704
 197 0020 CEF20003 		movt	r3, 57344
 198 0024 4EF62052 		movw	r2, #60704
 199 0028 CEF20002 		movt	r2, 57344
 200 002c 1268     		ldr	r2, [r2, #0]
 201 002e 42F07042 		orr	r2, r2, #-268435456
 202 0032 1A60     		str	r2, [r3, #0]
 235:../Source_Files/port.c **** 
 236:../Source_Files/port.c **** 	/* Start the timer that generates the tick ISR.  Interrupts are disabled
 237:../Source_Files/port.c **** 	here already. */
 238:../Source_Files/port.c **** 	vPortSetupTimerInterrupt();
 203              		.loc 1 238 0
 204 0034 FFF7FEFF 		bl	vPortSetupTimerInterrupt
 239:../Source_Files/port.c **** 
 240:../Source_Files/port.c **** 	/* Initialise the critical nesting count ready for the first task. */
 241:../Source_Files/port.c **** 	uxCriticalNesting = 0;
 205              		.loc 1 241 0
 206 0038 40F20003 		movw	r3, #:lower16:uxCriticalNesting
 207 003c C0F20003 		movt	r3, #:upper16:uxCriticalNesting
 208 0040 4FF00002 		mov	r2, #0
 209 0044 1A60     		str	r2, [r3, #0]
 242:../Source_Files/port.c **** 
 243:../Source_Files/port.c **** 	/* Start the first task. */
 244:../Source_Files/port.c **** 	prvPortStartFirstTask();
 210              		.loc 1 244 0
 211 0046 FFF7FEFF 		bl	prvPortStartFirstTask
 245:../Source_Files/port.c **** 
 246:../Source_Files/port.c **** 	/* Should not get here! */
 247:../Source_Files/port.c **** 	return 0;
 212              		.loc 1 247 0
 213 004a 4FF00003 		mov	r3, #0
 248:../Source_Files/port.c **** }
 214              		.loc 1 248 0
 215 004e 1846     		mov	r0, r3
 216 0050 80BD     		pop	{r7, pc}
 217              		.cfi_endproc
 218              	.LFE3:
 220 0052 00BF     		.section	.text.vPortEndScheduler,"ax",%progbits
 221              		.align	2
 222              		.global	vPortEndScheduler
 223              		.thumb
 224              		.thumb_func
 226              	vPortEndScheduler:
 227              	.LFB4:
 249:../Source_Files/port.c **** /*-----------------------------------------------------------*/
 250:../Source_Files/port.c **** 
 251:../Source_Files/port.c **** void vPortEndScheduler( void )
 252:../Source_Files/port.c **** {
 228              		.loc 1 252 0
 229              		.cfi_startproc
 230              		@ args = 0, pretend = 0, frame = 0
 231              		@ frame_needed = 1, uses_anonymous_args = 0
 232              		@ link register save eliminated.
 233 0000 80B4     		push	{r7}
 234              	.LCFI5:
 235              		.cfi_def_cfa_offset 4
 236              		.cfi_offset 7, -4
 237 0002 00AF     		add	r7, sp, #0
 238              	.LCFI6:
 239              		.cfi_def_cfa_register 7
 253:../Source_Files/port.c **** 	/* It is unlikely that the CM3 port will require this function as there
 254:../Source_Files/port.c **** 	is nothing to return to.  */
 255:../Source_Files/port.c **** }
 240              		.loc 1 255 0
 241 0004 BD46     		mov	sp, r7
 242 0006 80BC     		pop	{r7}
 243 0008 7047     		bx	lr
 244              		.cfi_endproc
 245              	.LFE4:
 247 000a 00BF     		.section	.text.vPortYieldFromISR,"ax",%progbits
 248              		.align	2
 249              		.global	vPortYieldFromISR
 250              		.thumb
 251              		.thumb_func
 253              	vPortYieldFromISR:
 254              	.LFB5:
 256:../Source_Files/port.c **** /*-----------------------------------------------------------*/
 257:../Source_Files/port.c **** 
 258:../Source_Files/port.c **** void vPortYieldFromISR( void )
 259:../Source_Files/port.c **** {
 255              		.loc 1 259 0
 256              		.cfi_startproc
 257              		@ args = 0, pretend = 0, frame = 0
 258              		@ frame_needed = 1, uses_anonymous_args = 0
 259              		@ link register save eliminated.
 260 0000 80B4     		push	{r7}
 261              	.LCFI7:
 262              		.cfi_def_cfa_offset 4
 263              		.cfi_offset 7, -4
 264 0002 00AF     		add	r7, sp, #0
 265              	.LCFI8:
 266              		.cfi_def_cfa_register 7
 260:../Source_Files/port.c **** 	/* Set a PendSV to request a context switch. */
 261:../Source_Files/port.c **** 	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 267              		.loc 1 261 0
 268 0004 4EF60453 		movw	r3, #60676
 269 0008 CEF20003 		movt	r3, 57344
 270 000c 4FF08052 		mov	r2, #268435456
 271 0010 1A60     		str	r2, [r3, #0]
 262:../Source_Files/port.c **** }
 272              		.loc 1 262 0
 273 0012 BD46     		mov	sp, r7
 274 0014 80BC     		pop	{r7}
 275 0016 7047     		bx	lr
 276              		.cfi_endproc
 277              	.LFE5:
 279              		.section	.text.vPortEnterCritical,"ax",%progbits
 280              		.align	2
 281              		.global	vPortEnterCritical
 282              		.thumb
 283              		.thumb_func
 285              	vPortEnterCritical:
 286              	.LFB6:
 263:../Source_Files/port.c **** /*-----------------------------------------------------------*/
 264:../Source_Files/port.c **** 
 265:../Source_Files/port.c **** void vPortEnterCritical( void )
 266:../Source_Files/port.c **** {
 287              		.loc 1 266 0
 288              		.cfi_startproc
 289              		@ args = 0, pretend = 0, frame = 0
 290              		@ frame_needed = 1, uses_anonymous_args = 0
 291 0000 80B5     		push	{r7, lr}
 292              	.LCFI9:
 293              		.cfi_def_cfa_offset 8
 294              		.cfi_offset 7, -8
 295              		.cfi_offset 14, -4
 296 0002 00AF     		add	r7, sp, #0
 297              	.LCFI10:
 298              		.cfi_def_cfa_register 7
 267:../Source_Files/port.c **** 	portDISABLE_INTERRUPTS();
 299              		.loc 1 267 0
 300 0004 FFF7FEFF 		bl	ulPortSetInterruptMask
 268:../Source_Files/port.c **** 	uxCriticalNesting++;
 301              		.loc 1 268 0
 302 0008 40F20003 		movw	r3, #:lower16:uxCriticalNesting
 303 000c C0F20003 		movt	r3, #:upper16:uxCriticalNesting
 304 0010 1B68     		ldr	r3, [r3, #0]
 305 0012 03F10102 		add	r2, r3, #1
 306 0016 40F20003 		movw	r3, #:lower16:uxCriticalNesting
 307 001a C0F20003 		movt	r3, #:upper16:uxCriticalNesting
 308 001e 1A60     		str	r2, [r3, #0]
 269:../Source_Files/port.c **** }
 309              		.loc 1 269 0
 310 0020 80BD     		pop	{r7, pc}
 311              		.cfi_endproc
 312              	.LFE6:
 314 0022 00BF     		.section	.text.vPortExitCritical,"ax",%progbits
 315              		.align	2
 316              		.global	vPortExitCritical
 317              		.thumb
 318              		.thumb_func
 320              	vPortExitCritical:
 321              	.LFB7:
 270:../Source_Files/port.c **** /*-----------------------------------------------------------*/
 271:../Source_Files/port.c **** 
 272:../Source_Files/port.c **** void vPortExitCritical( void )
 273:../Source_Files/port.c **** {
 322              		.loc 1 273 0
 323              		.cfi_startproc
 324              		@ args = 0, pretend = 0, frame = 0
 325              		@ frame_needed = 1, uses_anonymous_args = 0
 326 0000 80B5     		push	{r7, lr}
 327              	.LCFI11:
 328              		.cfi_def_cfa_offset 8
 329              		.cfi_offset 7, -8
 330              		.cfi_offset 14, -4
 331 0002 00AF     		add	r7, sp, #0
 332              	.LCFI12:
 333              		.cfi_def_cfa_register 7
 274:../Source_Files/port.c **** 	uxCriticalNesting--;
 334              		.loc 1 274 0
 335 0004 40F20003 		movw	r3, #:lower16:uxCriticalNesting
 336 0008 C0F20003 		movt	r3, #:upper16:uxCriticalNesting
 337 000c 1B68     		ldr	r3, [r3, #0]
 338 000e 03F1FF32 		add	r2, r3, #-1
 339 0012 40F20003 		movw	r3, #:lower16:uxCriticalNesting
 340 0016 C0F20003 		movt	r3, #:upper16:uxCriticalNesting
 341 001a 1A60     		str	r2, [r3, #0]
 275:../Source_Files/port.c **** 	if( uxCriticalNesting == 0 )
 342              		.loc 1 275 0
 343 001c 40F20003 		movw	r3, #:lower16:uxCriticalNesting
 344 0020 C0F20003 		movt	r3, #:upper16:uxCriticalNesting
 345 0024 1B68     		ldr	r3, [r3, #0]
 346 0026 002B     		cmp	r3, #0
 347 0028 03D1     		bne	.L10
 276:../Source_Files/port.c **** 	{
 277:../Source_Files/port.c **** 		portENABLE_INTERRUPTS();
 348              		.loc 1 277 0
 349 002a 4FF00000 		mov	r0, #0
 350 002e FFF7FEFF 		bl	vPortClearInterruptMask
 351              	.L10:
 278:../Source_Files/port.c **** 	}
 279:../Source_Files/port.c **** }
 352              		.loc 1 279 0
 353 0032 80BD     		pop	{r7, pc}
 354              		.cfi_endproc
 355              	.LFE7:
 357              		.section	.text.ulPortSetInterruptMask,"ax",%progbits
 358              		.align	2
 359              		.global	ulPortSetInterruptMask
 360              		.thumb
 361              		.thumb_func
 363              	ulPortSetInterruptMask:
 364              	.LFB8:
 280:../Source_Files/port.c **** /*-----------------------------------------------------------*/
 281:../Source_Files/port.c **** 
 282:../Source_Files/port.c **** __attribute__(( naked )) unsigned long ulPortSetInterruptMask( void )
 283:../Source_Files/port.c **** {
 365              		.loc 1 283 0
 366              		.cfi_startproc
 367              		@ Naked Function: prologue and epilogue provided by programmer.
 368              		@ args = 0, pretend = 0, frame = 0
 369              		@ frame_needed = 1, uses_anonymous_args = 0
 284:../Source_Files/port.c **** 	__asm volatile														\
 370              		.loc 1 284 0
 371              	@ 284 "../Source_Files/port.c" 1
 372 0000 EFF31180 			mrs r0, basepri											
 373 0004 4FF05001 		mov r1, #80												
 374 0008 81F31188 		msr basepri, r1											
 375 000c 7047     		bx lr													
 376              	
 377              	@ 0 "" 2
 285:../Source_Files/port.c **** 	(																	\
 286:../Source_Files/port.c **** 		"	mrs r0, basepri											\n" \
 287:../Source_Files/port.c **** 		"	mov r1, %0												\n"	\
 288:../Source_Files/port.c **** 		"	msr basepri, r1											\n" \
 289:../Source_Files/port.c **** 		"	bx lr													\n" \
 290:../Source_Files/port.c **** 		:: "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "r0", "r1"	\
 291:../Source_Files/port.c **** 	);
 292:../Source_Files/port.c **** 
 293:../Source_Files/port.c **** 	/* This return will not be reached but is necessary to prevent compiler
 294:../Source_Files/port.c **** 	warnings. */
 295:../Source_Files/port.c **** 	return 0;
 378              		.loc 1 295 0
 379              		.thumb
 380 000e 4FF00003 		mov	r3, #0
 296:../Source_Files/port.c **** }
 381              		.loc 1 296 0
 382 0012 1846     		mov	r0, r3
 383              		.cfi_endproc
 384              	.LFE8:
 386              		.section	.text.vPortClearInterruptMask,"ax",%progbits
 387              		.align	2
 388              		.global	vPortClearInterruptMask
 389              		.thumb
 390              		.thumb_func
 392              	vPortClearInterruptMask:
 393              	.LFB9:
 297:../Source_Files/port.c **** /*-----------------------------------------------------------*/
 298:../Source_Files/port.c **** 
 299:../Source_Files/port.c **** __attribute__(( naked )) void vPortClearInterruptMask( unsigned long ulNewMaskValue )
 300:../Source_Files/port.c **** {
 394              		.loc 1 300 0
 395              		.cfi_startproc
 396              		@ Naked Function: prologue and epilogue provided by programmer.
 397              		@ args = 0, pretend = 0, frame = 0
 398              		@ frame_needed = 1, uses_anonymous_args = 0
 301:../Source_Files/port.c **** 	__asm volatile													\
 399              		.loc 1 301 0
 400              	@ 301 "../Source_Files/port.c" 1
 401 0000 80F31188 			msr basepri, r0										
 402 0004 7047     		bx lr												
 403              	
 404              	@ 0 "" 2
 302:../Source_Files/port.c **** 	(																\
 303:../Source_Files/port.c **** 		"	msr basepri, r0										\n"	\
 304:../Source_Files/port.c **** 		"	bx lr												\n" \
 305:../Source_Files/port.c **** 		:::"r0"														\
 306:../Source_Files/port.c **** 	);
 307:../Source_Files/port.c **** 
 308:../Source_Files/port.c **** 	/* Just to avoid compiler warnings. */
 309:../Source_Files/port.c **** 	( void ) ulNewMaskValue;
 310:../Source_Files/port.c **** }
 405              		.loc 1 310 0
 406              		.thumb
 407              		.cfi_endproc
 408              	.LFE9:
 410 0006 00BF     		.section	.text.PendSV_Handler,"ax",%progbits
 411              		.align	2
 412              		.global	PendSV_Handler
 413              		.thumb
 414              		.thumb_func
 416              	PendSV_Handler:
 417              	.LFB10:
 311:../Source_Files/port.c **** /*-----------------------------------------------------------*/
 312:../Source_Files/port.c **** 
 313:../Source_Files/port.c **** void xPortPendSVHandler( void )
 314:../Source_Files/port.c **** {
 418              		.loc 1 314 0
 419              		.cfi_startproc
 420              		@ Naked Function: prologue and epilogue provided by programmer.
 421              		@ args = 0, pretend = 0, frame = 0
 422              		@ frame_needed = 1, uses_anonymous_args = 0
 315:../Source_Files/port.c **** 	/* This is a naked function. */
 316:../Source_Files/port.c **** 
 317:../Source_Files/port.c **** 	__asm volatile
 423              		.loc 1 317 0
 424              	@ 317 "../Source_Files/port.c" 1
 425 0000 EFF30980 			mrs r0, psp							
 426              											
 427 0004 0C4B     		ldr	r3, pxCurrentTCBConst			
 428 0006 1A68     		ldr	r2, [r3]						
 429              											
 430 0008 20E9F00F 		stmdb r0!, {r4-r11}					
 431 000c 1060     		str r0, [r2]						
 432              											
 433 000e 2DE90840 		stmdb sp!, {r3, r14}				
 434 0012 4FF05000 		mov r0, #80							
 435 0016 80F31188 		msr basepri, r0						
 436 001a FFF7FEFF 		bl vTaskSwitchContext				
 437 001e 4FF00000 		mov r0, #0							
 438 0022 80F31188 		msr basepri, r0						
 439 0026 BDE80840 		ldmia sp!, {r3, r14}				
 440              											
 441 002a 1968     		ldr r1, [r3]						
 442 002c 0868     		ldr r0, [r1]						
 443 002e B0E8F00F 		ldmia r0!, {r4-r11}					
 444 0032 80F30988 		msr psp, r0							
 445 0036 7047     		bx r14								
 446              											
 447              		.align 2							
 448 0038 00000000 	pxCurrentTCBConst: .word pxCurrentTCB	
 449              	
 450              	@ 0 "" 2
 318:../Source_Files/port.c **** 	(
 319:../Source_Files/port.c **** 	"	mrs r0, psp							\n"
 320:../Source_Files/port.c **** 	"										\n"
 321:../Source_Files/port.c **** 	"	ldr	r3, pxCurrentTCBConst			\n" /* Get the location of the current TCB. */
 322:../Source_Files/port.c **** 	"	ldr	r2, [r3]						\n"
 323:../Source_Files/port.c **** 	"										\n"
 324:../Source_Files/port.c **** 	"	stmdb r0!, {r4-r11}					\n" /* Save the remaining registers. */
 325:../Source_Files/port.c **** 	"	str r0, [r2]						\n" /* Save the new top of stack into the first member of the TCB. */
 326:../Source_Files/port.c **** 	"										\n"
 327:../Source_Files/port.c **** 	"	stmdb sp!, {r3, r14}				\n"
 328:../Source_Files/port.c **** 	"	mov r0, %0							\n"
 329:../Source_Files/port.c **** 	"	msr basepri, r0						\n"
 330:../Source_Files/port.c **** 	"	bl vTaskSwitchContext				\n"
 331:../Source_Files/port.c **** 	"	mov r0, #0							\n"
 332:../Source_Files/port.c **** 	"	msr basepri, r0						\n"
 333:../Source_Files/port.c **** 	"	ldmia sp!, {r3, r14}				\n"
 334:../Source_Files/port.c **** 	"										\n"	/* Restore the context, including the critical nesting count. */
 335:../Source_Files/port.c **** 	"	ldr r1, [r3]						\n"
 336:../Source_Files/port.c **** 	"	ldr r0, [r1]						\n" /* The first item in pxCurrentTCB is the task top of stack. */
 337:../Source_Files/port.c **** 	"	ldmia r0!, {r4-r11}					\n" /* Pop the registers. */
 338:../Source_Files/port.c **** 	"	msr psp, r0							\n"
 339:../Source_Files/port.c **** 	"	bx r14								\n"
 340:../Source_Files/port.c **** 	"										\n"
 341:../Source_Files/port.c **** 	"	.align 2							\n"
 342:../Source_Files/port.c **** 	"pxCurrentTCBConst: .word pxCurrentTCB	\n"
 343:../Source_Files/port.c **** 	::"i"(configMAX_SYSCALL_INTERRUPT_PRIORITY)
 344:../Source_Files/port.c **** 	);
 345:../Source_Files/port.c **** }
 451              		.loc 1 345 0
 452              		.thumb
 453              		.cfi_endproc
 454              	.LFE10:
 456              		.section	.text.SysTick_Handler,"ax",%progbits
 457              		.align	2
 458              		.global	SysTick_Handler
 459              		.thumb
 460              		.thumb_func
 462              	SysTick_Handler:
 463              	.LFB11:
 346:../Source_Files/port.c **** /*-----------------------------------------------------------*/
 347:../Source_Files/port.c **** 
 348:../Source_Files/port.c **** void xPortSysTickHandler( void )
 349:../Source_Files/port.c **** {
 464              		.loc 1 349 0
 465              		.cfi_startproc
 466              		@ args = 0, pretend = 0, frame = 0
 467              		@ frame_needed = 1, uses_anonymous_args = 0
 468 0000 80B5     		push	{r7, lr}
 469              	.LCFI13:
 470              		.cfi_def_cfa_offset 8
 471              		.cfi_offset 7, -8
 472              		.cfi_offset 14, -4
 473 0002 00AF     		add	r7, sp, #0
 474              	.LCFI14:
 475              		.cfi_def_cfa_register 7
 350:../Source_Files/port.c **** 	/* If using preemption, also force a context switch. */
 351:../Source_Files/port.c **** 	#if configUSE_PREEMPTION == 1
 352:../Source_Files/port.c **** 		portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 476              		.loc 1 352 0
 477 0004 4EF60453 		movw	r3, #60676
 478 0008 CEF20003 		movt	r3, 57344
 479 000c 4FF08052 		mov	r2, #268435456
 480 0010 1A60     		str	r2, [r3, #0]
 353:../Source_Files/port.c **** 	#endif
 354:../Source_Files/port.c **** 
 355:../Source_Files/port.c **** 	/* Only reset the systick load register if configUSE_TICKLESS_IDLE is set to
 356:../Source_Files/port.c **** 	1.  If it is set to 0 tickless idle is not being used.  If it is set to a
 357:../Source_Files/port.c **** 	value other than 0 or 1 then a timer other than the SysTick is being used
 358:../Source_Files/port.c **** 	to generate the tick interrupt. */
 359:../Source_Files/port.c **** 	#if configUSE_TICKLESS_IDLE == 1
 360:../Source_Files/port.c **** 		portNVIC_SYSTICK_LOAD_REG = ulTimerReloadValueForOneTick;
 361:../Source_Files/port.c **** 	#endif
 362:../Source_Files/port.c **** 
 363:../Source_Files/port.c **** 	( void ) portSET_INTERRUPT_MASK_FROM_ISR();
 481              		.loc 1 363 0
 482 0012 FFF7FEFF 		bl	ulPortSetInterruptMask
 364:../Source_Files/port.c **** 	{
 365:../Source_Files/port.c **** 		vTaskIncrementTick();
 483              		.loc 1 365 0
 484 0016 FFF7FEFF 		bl	vTaskIncrementTick
 366:../Source_Files/port.c **** 	}
 367:../Source_Files/port.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( 0 );
 485              		.loc 1 367 0
 486 001a 4FF00000 		mov	r0, #0
 487 001e FFF7FEFF 		bl	vPortClearInterruptMask
 368:../Source_Files/port.c **** }
 488              		.loc 1 368 0
 489 0022 80BD     		pop	{r7, pc}
 490              		.cfi_endproc
 491              	.LFE11:
 493              		.section	.text.vPortSetupTimerInterrupt,"ax",%progbits
 494              		.align	2
 495              		.weak	vPortSetupTimerInterrupt
 496              		.thumb
 497              		.thumb_func
 499              	vPortSetupTimerInterrupt:
 500              	.LFB12:
 369:../Source_Files/port.c **** /*-----------------------------------------------------------*/
 370:../Source_Files/port.c **** 
 371:../Source_Files/port.c **** #if configUSE_TICKLESS_IDLE == 1
 372:../Source_Files/port.c **** 
 373:../Source_Files/port.c **** 	__attribute__((weak)) void vPortSuppressTicksAndSleep( portTickType xExpectedIdleTime )
 374:../Source_Files/port.c **** 	{
 375:../Source_Files/port.c **** 	unsigned long ulReloadValue, ulCompleteTickPeriods, ulCompletedSysTickIncrements;
 376:../Source_Files/port.c **** 	portTickType xModifiableIdleTime;
 377:../Source_Files/port.c **** 
 378:../Source_Files/port.c **** 		/* Make sure the SysTick reload value does not overflow the counter. */
 379:../Source_Files/port.c **** 		if( xExpectedIdleTime > xMaximumPossibleSuppressedTicks )
 380:../Source_Files/port.c **** 		{
 381:../Source_Files/port.c **** 			xExpectedIdleTime = xMaximumPossibleSuppressedTicks;
 382:../Source_Files/port.c **** 		}
 383:../Source_Files/port.c **** 
 384:../Source_Files/port.c **** 		/* Calculate the reload value required to wait xExpectedIdleTime
 385:../Source_Files/port.c **** 		tick periods.  -1 is used because this code will execute part way
 386:../Source_Files/port.c **** 		through one of the tick periods, and the fraction of a tick period is
 387:../Source_Files/port.c **** 		accounted for later. */
 388:../Source_Files/port.c **** 		ulReloadValue = ( ulTimerReloadValueForOneTick * ( xExpectedIdleTime - 1UL ) );
 389:../Source_Files/port.c **** 		if( ulReloadValue > ulStoppedTimerCompensation )
 390:../Source_Files/port.c **** 		{
 391:../Source_Files/port.c **** 			ulReloadValue -= ulStoppedTimerCompensation;
 392:../Source_Files/port.c **** 		}
 393:../Source_Files/port.c **** 
 394:../Source_Files/port.c **** 		/* Stop the SysTick momentarily.  The time the SysTick is stopped for
 395:../Source_Files/port.c **** 		is accounted for as best it can be, but using the tickless mode will
 396:../Source_Files/port.c **** 		inevitably result in some tiny drift of the time maintained by the
 397:../Source_Files/port.c **** 		kernel with respect to calendar time. */
 398:../Source_Files/port.c **** 		portNVIC_SYSTICK_CTRL_REG = portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT;
 399:../Source_Files/port.c **** 
 400:../Source_Files/port.c **** 		/* Adjust the reload value to take into account that the current time
 401:../Source_Files/port.c **** 		slice is already partially complete. */
 402:../Source_Files/port.c **** 		ulReloadValue += ( portNVIC_SYSTICK_LOAD_REG - ( portNVIC_SYSTICK_LOAD_REG - portNVIC_SYSTICK_CUR
 403:../Source_Files/port.c **** 
 404:../Source_Files/port.c **** 		/* Enter a critical section but don't use the taskENTER_CRITICAL()
 405:../Source_Files/port.c **** 		method as that will mask interrupts that should exit sleep mode. */
 406:../Source_Files/port.c **** 		__asm volatile( "cpsid i" );
 407:../Source_Files/port.c **** 
 408:../Source_Files/port.c **** 		/* If a context switch is pending or a task is waiting for the scheduler
 409:../Source_Files/port.c **** 		to be unsuspended then abandon the low power entry. */
 410:../Source_Files/port.c **** 		if( eTaskConfirmSleepModeStatus() == eAbortSleep )
 411:../Source_Files/port.c **** 		{
 412:../Source_Files/port.c **** 			/* Restart SysTick. */
 413:../Source_Files/port.c **** 			portNVIC_SYSTICK_CTRL_REG = portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTI
 414:../Source_Files/port.c **** 
 415:../Source_Files/port.c **** 			/* Re-enable interrupts - see comments above the cpsid instruction()
 416:../Source_Files/port.c **** 			above. */
 417:../Source_Files/port.c **** 			__asm volatile( "cpsie i" );
 418:../Source_Files/port.c **** 		}
 419:../Source_Files/port.c **** 		else
 420:../Source_Files/port.c **** 		{
 421:../Source_Files/port.c **** 			/* Set the new reload value. */
 422:../Source_Files/port.c **** 			portNVIC_SYSTICK_LOAD_REG = ulReloadValue;
 423:../Source_Files/port.c **** 
 424:../Source_Files/port.c **** 			/* Clear the SysTick count flag and set the count value back to
 425:../Source_Files/port.c **** 			zero. */
 426:../Source_Files/port.c **** 			portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
 427:../Source_Files/port.c **** 
 428:../Source_Files/port.c **** 			/* Restart SysTick. */
 429:../Source_Files/port.c **** 			portNVIC_SYSTICK_CTRL_REG = portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTI
 430:../Source_Files/port.c **** 
 431:../Source_Files/port.c **** 			/* Sleep until something happens.  configPRE_SLEEP_PROCESSING() can
 432:../Source_Files/port.c **** 			set its parameter to 0 to indicate that its implementation contains
 433:../Source_Files/port.c **** 			its own wait for interrupt or wait for event instruction, and so wfi
 434:../Source_Files/port.c **** 			should not be executed again.  However, the original expected idle
 435:../Source_Files/port.c **** 			time variable must remain unmodified, so a copy is taken. */
 436:../Source_Files/port.c **** 			xModifiableIdleTime = xExpectedIdleTime;
 437:../Source_Files/port.c **** 			configPRE_SLEEP_PROCESSING( xModifiableIdleTime );
 438:../Source_Files/port.c **** 			if( xModifiableIdleTime > 0 )
 439:../Source_Files/port.c **** 			{
 440:../Source_Files/port.c **** 				__asm volatile( "wfi" );
 441:../Source_Files/port.c **** 			}
 442:../Source_Files/port.c **** 			configPOST_SLEEP_PROCESSING( xExpectedIdleTime );
 443:../Source_Files/port.c **** 
 444:../Source_Files/port.c **** 			/* Stop SysTick.  Again, the time the SysTick is stopped for is
 445:../Source_Files/port.c **** 			accounted for as best it can be, but using the tickless mode will
 446:../Source_Files/port.c **** 			inevitably result in some tiny drift of the time maintained by the
 447:../Source_Files/port.c **** 			kernel with respect to calendar time. */
 448:../Source_Files/port.c **** 			portNVIC_SYSTICK_CTRL_REG = portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT;
 449:../Source_Files/port.c **** 
 450:../Source_Files/port.c **** 			/* Re-enable interrupts - see comments above the cpsid instruction()
 451:../Source_Files/port.c **** 			above. */
 452:../Source_Files/port.c **** 			__asm volatile( "cpsie i" );
 453:../Source_Files/port.c **** 
 454:../Source_Files/port.c **** 			if( ( portNVIC_SYSTICK_CTRL_REG & portNVIC_SYSTICK_COUNT_FLAG_BIT ) != 0 )
 455:../Source_Files/port.c **** 			{
 456:../Source_Files/port.c **** 				/* The tick interrupt has already executed, and the SysTick
 457:../Source_Files/port.c **** 				count reloaded with the portNVIC_SYSTICK_LOAD_REG value.
 458:../Source_Files/port.c **** 				Reset the portNVIC_SYSTICK_LOAD_REG with whatever remains of
 459:../Source_Files/port.c **** 				this tick period. */
 460:../Source_Files/port.c **** 				portNVIC_SYSTICK_LOAD_REG = ulTimerReloadValueForOneTick - ( ulReloadValue - portNVIC_SYSTICK_C
 461:../Source_Files/port.c **** 
 462:../Source_Files/port.c **** 				/* The tick interrupt handler will already have pended the tick
 463:../Source_Files/port.c **** 				processing in the kernel.  As the pending tick will be
 464:../Source_Files/port.c **** 				processed as soon as this function exits, the tick value
 465:../Source_Files/port.c **** 				maintained by the tick is stepped forward by one less than the
 466:../Source_Files/port.c **** 				time spent waiting. */
 467:../Source_Files/port.c **** 				ulCompleteTickPeriods = xExpectedIdleTime - 1UL;
 468:../Source_Files/port.c **** 			}
 469:../Source_Files/port.c **** 			else
 470:../Source_Files/port.c **** 			{
 471:../Source_Files/port.c **** 				/* Something other than the tick interrupt ended the sleep.
 472:../Source_Files/port.c **** 				Work out how long the sleep lasted. */
 473:../Source_Files/port.c **** 				ulCompletedSysTickIncrements = ( xExpectedIdleTime * ulTimerReloadValueForOneTick ) - portNVIC_
 474:../Source_Files/port.c **** 
 475:../Source_Files/port.c **** 				/* How many complete tick periods passed while the processor
 476:../Source_Files/port.c **** 				was waiting? */
 477:../Source_Files/port.c **** 				ulCompleteTickPeriods = ulCompletedSysTickIncrements / ulTimerReloadValueForOneTick;
 478:../Source_Files/port.c **** 
 479:../Source_Files/port.c **** 				/* The reload value is set to whatever fraction of a single tick
 480:../Source_Files/port.c **** 				period remains. */
 481:../Source_Files/port.c **** 				portNVIC_SYSTICK_LOAD_REG = ( ( ulCompleteTickPeriods + 1 ) * ulTimerReloadValueForOneTick ) - 
 482:../Source_Files/port.c **** 			}
 483:../Source_Files/port.c **** 
 484:../Source_Files/port.c **** 			/* Restart SysTick so it runs from portNVIC_SYSTICK_LOAD_REG
 485:../Source_Files/port.c **** 			again, then set portNVIC_SYSTICK_LOAD_REG back to its standard
 486:../Source_Files/port.c **** 			value. */
 487:../Source_Files/port.c **** 			portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
 488:../Source_Files/port.c **** 			portNVIC_SYSTICK_CTRL_REG = portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTI
 489:../Source_Files/port.c **** 
 490:../Source_Files/port.c **** 			vTaskStepTick( ulCompleteTickPeriods );
 491:../Source_Files/port.c **** 		}
 492:../Source_Files/port.c **** 	}
 493:../Source_Files/port.c **** 
 494:../Source_Files/port.c **** #endif /* #if configUSE_TICKLESS_IDLE */
 495:../Source_Files/port.c **** /*-----------------------------------------------------------*/
 496:../Source_Files/port.c **** 
 497:../Source_Files/port.c **** /*
 498:../Source_Files/port.c ****  * Setup the systick timer to generate the tick interrupts at the required
 499:../Source_Files/port.c ****  * frequency.
 500:../Source_Files/port.c ****  */
 501:../Source_Files/port.c **** __attribute__(( weak )) void vPortSetupTimerInterrupt( void )
 502:../Source_Files/port.c **** {
 501              		.loc 1 502 0
 502              		.cfi_startproc
 503              		@ args = 0, pretend = 0, frame = 0
 504              		@ frame_needed = 1, uses_anonymous_args = 0
 505              		@ link register save eliminated.
 506 0000 80B4     		push	{r7}
 507              	.LCFI15:
 508              		.cfi_def_cfa_offset 4
 509              		.cfi_offset 7, -4
 510 0002 00AF     		add	r7, sp, #0
 511              	.LCFI16:
 512              		.cfi_def_cfa_register 7
 503:../Source_Files/port.c **** 	/* Calculate the constants required to configure the tick interrupt. */
 504:../Source_Files/port.c **** 	#if configUSE_TICKLESS_IDLE == 1
 505:../Source_Files/port.c **** 	{
 506:../Source_Files/port.c **** 		ulTimerReloadValueForOneTick = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 507:../Source_Files/port.c **** 		xMaximumPossibleSuppressedTicks = 0xffffffUL / ( ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) 
 508:../Source_Files/port.c **** 		ulStoppedTimerCompensation = 45UL / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
 509:../Source_Files/port.c **** 	}
 510:../Source_Files/port.c **** 	#endif /* configUSE_TICKLESS_IDLE */
 511:../Source_Files/port.c **** 
 512:../Source_Files/port.c **** 	/* Configure SysTick to interrupt at the requested rate. */
 513:../Source_Files/port.c **** 	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;;
 513              		.loc 1 513 0
 514 0004 4EF21403 		movw	r3, #57364
 515 0008 CEF20003 		movt	r3, 57344
 516 000c 45F6BF52 		movw	r2, #23999
 517 0010 1A60     		str	r2, [r3, #0]
 514:../Source_Files/port.c **** 	portNVIC_SYSTICK_CTRL_REG = portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK
 518              		.loc 1 514 0
 519 0012 4EF21003 		movw	r3, #57360
 520 0016 CEF20003 		movt	r3, 57344
 521 001a 4FF00702 		mov	r2, #7
 522 001e 1A60     		str	r2, [r3, #0]
 515:../Source_Files/port.c **** }
 523              		.loc 1 515 0
 524 0020 BD46     		mov	sp, r7
 525 0022 80BC     		pop	{r7}
 526 0024 7047     		bx	lr
 527              		.cfi_endproc
 528              	.LFE12:
 530 0026 00BF     		.text
 531              	.Letext0:
 532              		.file 2 "/home/frolls/ARM/stm32vld_template/Header_Files/projdefs.h"
 533              		.file 3 "/home/frolls/ARM/stm32vld_template/Header_Files/portmacro.h"
DEFINED SYMBOLS
                            *ABS*:00000000 port.c
     /tmp/ccU3vCE8.s:23     .rodata.ulKernelPriority:00000000 ulKernelPriority
     /tmp/ccU3vCE8.s:20     .rodata.ulKernelPriority:00000000 $d
     /tmp/ccU3vCE8.s:26     .data.uxCriticalNesting:00000000 $d
     /tmp/ccU3vCE8.s:29     .data.uxCriticalNesting:00000000 uxCriticalNesting
     /tmp/ccU3vCE8.s:32     .text.pxPortInitialiseStack:00000000 $t
     /tmp/ccU3vCE8.s:37     .text.pxPortInitialiseStack:00000000 pxPortInitialiseStack
     /tmp/ccU3vCE8.s:106    .text.SVC_Handler:00000000 $t
     /tmp/ccU3vCE8.s:111    .text.SVC_Handler:00000000 SVC_Handler
     /tmp/ccU3vCE8.s:131    .text.SVC_Handler:0000001c pxCurrentTCBConst2
     /tmp/ccU3vCE8.s:131    .text.SVC_Handler:0000001c $d
     /tmp/ccU3vCE8.s:140    .text.prvPortStartFirstTask:00000000 $t
     /tmp/ccU3vCE8.s:144    .text.prvPortStartFirstTask:00000000 prvPortStartFirstTask
     /tmp/ccU3vCE8.s:168    .text.xPortStartScheduler:00000000 $t
     /tmp/ccU3vCE8.s:173    .text.xPortStartScheduler:00000000 xPortStartScheduler
     /tmp/ccU3vCE8.s:499    .text.vPortSetupTimerInterrupt:00000000 vPortSetupTimerInterrupt
     /tmp/ccU3vCE8.s:221    .text.vPortEndScheduler:00000000 $t
     /tmp/ccU3vCE8.s:226    .text.vPortEndScheduler:00000000 vPortEndScheduler
     /tmp/ccU3vCE8.s:248    .text.vPortYieldFromISR:00000000 $t
     /tmp/ccU3vCE8.s:253    .text.vPortYieldFromISR:00000000 vPortYieldFromISR
     /tmp/ccU3vCE8.s:280    .text.vPortEnterCritical:00000000 $t
     /tmp/ccU3vCE8.s:285    .text.vPortEnterCritical:00000000 vPortEnterCritical
     /tmp/ccU3vCE8.s:363    .text.ulPortSetInterruptMask:00000000 ulPortSetInterruptMask
     /tmp/ccU3vCE8.s:315    .text.vPortExitCritical:00000000 $t
     /tmp/ccU3vCE8.s:320    .text.vPortExitCritical:00000000 vPortExitCritical
     /tmp/ccU3vCE8.s:392    .text.vPortClearInterruptMask:00000000 vPortClearInterruptMask
     /tmp/ccU3vCE8.s:358    .text.ulPortSetInterruptMask:00000000 $t
     /tmp/ccU3vCE8.s:387    .text.vPortClearInterruptMask:00000000 $t
     /tmp/ccU3vCE8.s:411    .text.PendSV_Handler:00000000 $t
     /tmp/ccU3vCE8.s:416    .text.PendSV_Handler:00000000 PendSV_Handler
     /tmp/ccU3vCE8.s:448    .text.PendSV_Handler:00000038 pxCurrentTCBConst
     /tmp/ccU3vCE8.s:448    .text.PendSV_Handler:00000038 $d
     /tmp/ccU3vCE8.s:457    .text.SysTick_Handler:00000000 $t
     /tmp/ccU3vCE8.s:462    .text.SysTick_Handler:00000000 SysTick_Handler
     /tmp/ccU3vCE8.s:494    .text.vPortSetupTimerInterrupt:00000000 $t
     /tmp/ccU3vCE8.s:167    .text.prvPortStartFirstTask:00000010 $d
                     .debug_frame:00000010 $d
                           .group:00000000 wm4.1.3f2d2167d278fc96c4a7439609634148
                           .group:00000000 wm4.stddef.h.40.50cf36416e06376af8a9dca28536f2e4
                           .group:00000000 wm4.projdefs.h.76.214f319a5937dae232f0ee2912b07e1d
                           .group:00000000 wm4.FreeRTOSConfig.h.86.3af1027ee08901f4d7dabcb80a837715
                           .group:00000000 wm4.portmacro.h.77.8d562aa278cb516c96f7646e8f3849cb
                           .group:00000000 wm4.portable.h.332.e25bf3f97ebf50a0f90736144cb8c3f8
                           .group:00000000 wm4.mpu_wrappers.h.76.3abcfc7ebb6d78909ee0b4ad2f20f282
                           .group:00000000 wm4.FreeRTOS.h.159.741cbf33489b2c951994722716e9692e
                           .group:00000000 wm4.list.h.105.6a6307ce3396638a078c02ff83387dc6
                           .group:00000000 wm4.task.h.94.33ec4de8c3f825901c54e6cf58507761

UNDEFINED SYMBOLS
pxCurrentTCB
vTaskSwitchContext
vTaskIncrementTick
