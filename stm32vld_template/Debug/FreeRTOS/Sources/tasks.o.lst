   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"tasks.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.global	pxCurrentTCB
  19              		.section	.bss.pxCurrentTCB,"aw",%nobits
  20              		.align	2
  23              	pxCurrentTCB:
  24 0000 00000000 		.space	4
  25              		.section	.bss.pxReadyTasksLists,"aw",%nobits
  26              		.align	2
  29              	pxReadyTasksLists:
  30 0000 00000000 		.space	100
  30      00000000 
  30      00000000 
  30      00000000 
  30      00000000 
  31              		.section	.bss.xDelayedTaskList1,"aw",%nobits
  32              		.align	2
  35              	xDelayedTaskList1:
  36 0000 00000000 		.space	20
  36      00000000 
  36      00000000 
  36      00000000 
  36      00000000 
  37              		.section	.bss.xDelayedTaskList2,"aw",%nobits
  38              		.align	2
  41              	xDelayedTaskList2:
  42 0000 00000000 		.space	20
  42      00000000 
  42      00000000 
  42      00000000 
  42      00000000 
  43              		.section	.bss.pxDelayedTaskList,"aw",%nobits
  44              		.align	2
  47              	pxDelayedTaskList:
  48 0000 00000000 		.space	4
  49              		.section	.bss.pxOverflowDelayedTaskList,"aw",%nobits
  50              		.align	2
  53              	pxOverflowDelayedTaskList:
  54 0000 00000000 		.space	4
  55              		.section	.bss.xPendingReadyList,"aw",%nobits
  56              		.align	2
  59              	xPendingReadyList:
  60 0000 00000000 		.space	20
  60      00000000 
  60      00000000 
  60      00000000 
  60      00000000 
  61              		.section	.bss.xTasksWaitingTermination,"aw",%nobits
  62              		.align	2
  65              	xTasksWaitingTermination:
  66 0000 00000000 		.space	20
  66      00000000 
  66      00000000 
  66      00000000 
  66      00000000 
  67              		.section	.bss.uxTasksDeleted,"aw",%nobits
  68              		.align	2
  71              	uxTasksDeleted:
  72 0000 00000000 		.space	4
  73              		.section	.bss.xSuspendedTaskList,"aw",%nobits
  74              		.align	2
  77              	xSuspendedTaskList:
  78 0000 00000000 		.space	20
  78      00000000 
  78      00000000 
  78      00000000 
  78      00000000 
  79              		.section	.bss.uxCurrentNumberOfTasks,"aw",%nobits
  80              		.align	2
  83              	uxCurrentNumberOfTasks:
  84 0000 00000000 		.space	4
  85              		.section	.bss.xTickCount,"aw",%nobits
  86              		.align	2
  89              	xTickCount:
  90 0000 00000000 		.space	4
  91              		.section	.bss.uxTopUsedPriority,"aw",%nobits
  92              		.align	2
  95              	uxTopUsedPriority:
  96 0000 00000000 		.space	4
  97              		.section	.bss.uxTopReadyPriority,"aw",%nobits
  98              		.align	2
 101              	uxTopReadyPriority:
 102 0000 00000000 		.space	4
 103              		.section	.bss.xSchedulerRunning,"aw",%nobits
 104              		.align	2
 107              	xSchedulerRunning:
 108 0000 00000000 		.space	4
 109              		.section	.bss.uxSchedulerSuspended,"aw",%nobits
 110              		.align	2
 113              	uxSchedulerSuspended:
 114 0000 00000000 		.space	4
 115              		.section	.bss.uxMissedTicks,"aw",%nobits
 116              		.align	2
 119              	uxMissedTicks:
 120 0000 00000000 		.space	4
 121              		.section	.bss.xMissedYield,"aw",%nobits
 122              		.align	2
 125              	xMissedYield:
 126 0000 00000000 		.space	4
 127              		.section	.bss.xNumOfOverflows,"aw",%nobits
 128              		.align	2
 131              	xNumOfOverflows:
 132 0000 00000000 		.space	4
 133              		.section	.bss.uxTaskNumber,"aw",%nobits
 134              		.align	2
 137              	uxTaskNumber:
 138 0000 00000000 		.space	4
 139              		.section	.data.xNextTaskUnblockTime,"aw",%progbits
 140              		.align	2
 143              	xNextTaskUnblockTime:
 144 0000 FFFFFFFF 		.word	-1
 145              		.section	.text.xTaskGenericCreate,"ax",%progbits
 146              		.align	2
 147              		.global	xTaskGenericCreate
 148              		.thumb
 149              		.thumb_func
 151              	xTaskGenericCreate:
 152              	.LFB0:
 153              		.file 1 "../FreeRTOS/Sources/tasks.c"
   1:../FreeRTOS/Sources/tasks.c **** /*
   2:../FreeRTOS/Sources/tasks.c ****     FreeRTOS V7.4.0 - Copyright (C) 2013 Real Time Engineers Ltd.
   3:../FreeRTOS/Sources/tasks.c **** 
   4:../FreeRTOS/Sources/tasks.c ****     FEATURES AND PORTS ARE ADDED TO FREERTOS ALL THE TIME.  PLEASE VISIT
   5:../FreeRTOS/Sources/tasks.c ****     http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
   6:../FreeRTOS/Sources/tasks.c **** 
   7:../FreeRTOS/Sources/tasks.c ****     ***************************************************************************
   8:../FreeRTOS/Sources/tasks.c ****      *                                                                       *
   9:../FreeRTOS/Sources/tasks.c ****      *    FreeRTOS tutorial books are available in pdf and paperback.        *
  10:../FreeRTOS/Sources/tasks.c ****      *    Complete, revised, and edited pdf reference manuals are also       *
  11:../FreeRTOS/Sources/tasks.c ****      *    available.                                                         *
  12:../FreeRTOS/Sources/tasks.c ****      *                                                                       *
  13:../FreeRTOS/Sources/tasks.c ****      *    Purchasing FreeRTOS documentation will not only help you, by       *
  14:../FreeRTOS/Sources/tasks.c ****      *    ensuring you get running as quickly as possible and with an        *
  15:../FreeRTOS/Sources/tasks.c ****      *    in-depth knowledge of how to use FreeRTOS, it will also help       *
  16:../FreeRTOS/Sources/tasks.c ****      *    the FreeRTOS project to continue with its mission of providing     *
  17:../FreeRTOS/Sources/tasks.c ****      *    professional grade, cross platform, de facto standard solutions    *
  18:../FreeRTOS/Sources/tasks.c ****      *    for microcontrollers - completely free of charge!                  *
  19:../FreeRTOS/Sources/tasks.c ****      *                                                                       *
  20:../FreeRTOS/Sources/tasks.c ****      *    >>> See http://www.FreeRTOS.org/Documentation for details. <<<     *
  21:../FreeRTOS/Sources/tasks.c ****      *                                                                       *
  22:../FreeRTOS/Sources/tasks.c ****      *    Thank you for using FreeRTOS, and thank you for your support!      *
  23:../FreeRTOS/Sources/tasks.c ****      *                                                                       *
  24:../FreeRTOS/Sources/tasks.c ****     ***************************************************************************
  25:../FreeRTOS/Sources/tasks.c **** 
  26:../FreeRTOS/Sources/tasks.c **** 
  27:../FreeRTOS/Sources/tasks.c ****     This file is part of the FreeRTOS distribution.
  28:../FreeRTOS/Sources/tasks.c **** 
  29:../FreeRTOS/Sources/tasks.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  30:../FreeRTOS/Sources/tasks.c ****     the terms of the GNU General Public License (version 2) as published by the
  31:../FreeRTOS/Sources/tasks.c ****     Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
  32:../FreeRTOS/Sources/tasks.c **** 
  33:../FreeRTOS/Sources/tasks.c ****     >>>>>>NOTE<<<<<< The modification to the GPL is included to allow you to
  34:../FreeRTOS/Sources/tasks.c ****     distribute a combined work that includes FreeRTOS without being obliged to
  35:../FreeRTOS/Sources/tasks.c ****     provide the source code for proprietary components outside of the FreeRTOS
  36:../FreeRTOS/Sources/tasks.c ****     kernel.
  37:../FreeRTOS/Sources/tasks.c **** 
  38:../FreeRTOS/Sources/tasks.c ****     FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
  39:../FreeRTOS/Sources/tasks.c ****     WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
  40:../FreeRTOS/Sources/tasks.c ****     FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
  41:../FreeRTOS/Sources/tasks.c ****     details. You should have received a copy of the GNU General Public License
  42:../FreeRTOS/Sources/tasks.c ****     and the FreeRTOS license exception along with FreeRTOS; if not itcan be
  43:../FreeRTOS/Sources/tasks.c ****     viewed here: http://www.freertos.org/a00114.html and also obtained by
  44:../FreeRTOS/Sources/tasks.c ****     writing to Real Time Engineers Ltd., contact details for whom are available
  45:../FreeRTOS/Sources/tasks.c ****     on the FreeRTOS WEB site.
  46:../FreeRTOS/Sources/tasks.c **** 
  47:../FreeRTOS/Sources/tasks.c ****     1 tab == 4 spaces!
  48:../FreeRTOS/Sources/tasks.c **** 
  49:../FreeRTOS/Sources/tasks.c ****     ***************************************************************************
  50:../FreeRTOS/Sources/tasks.c ****      *                                                                       *
  51:../FreeRTOS/Sources/tasks.c ****      *    Having a problem?  Start by reading the FAQ "My application does   *
  52:../FreeRTOS/Sources/tasks.c ****      *    not run, what could be wrong?"                                     *
  53:../FreeRTOS/Sources/tasks.c ****      *                                                                       *
  54:../FreeRTOS/Sources/tasks.c ****      *    http://www.FreeRTOS.org/FAQHelp.html                               *
  55:../FreeRTOS/Sources/tasks.c ****      *                                                                       *
  56:../FreeRTOS/Sources/tasks.c ****     ***************************************************************************
  57:../FreeRTOS/Sources/tasks.c **** 
  58:../FreeRTOS/Sources/tasks.c **** 
  59:../FreeRTOS/Sources/tasks.c ****     http://www.FreeRTOS.org - Documentation, books, training, latest versions, 
  60:../FreeRTOS/Sources/tasks.c ****     license and Real Time Engineers Ltd. contact details.
  61:../FreeRTOS/Sources/tasks.c **** 
  62:../FreeRTOS/Sources/tasks.c ****     http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
  63:../FreeRTOS/Sources/tasks.c ****     including FreeRTOS+Trace - an indispensable productivity tool, and our new
  64:../FreeRTOS/Sources/tasks.c ****     fully thread aware and reentrant UDP/IP stack.
  65:../FreeRTOS/Sources/tasks.c **** 
  66:../FreeRTOS/Sources/tasks.c ****     http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High 
  67:../FreeRTOS/Sources/tasks.c ****     Integrity Systems, who sell the code with commercial support, 
  68:../FreeRTOS/Sources/tasks.c ****     indemnification and middleware, under the OpenRTOS brand.
  69:../FreeRTOS/Sources/tasks.c ****     
  70:../FreeRTOS/Sources/tasks.c ****     http://www.SafeRTOS.com - High Integrity Systems also provide a safety 
  71:../FreeRTOS/Sources/tasks.c ****     engineered and independently SIL3 certified version for use in safety and 
  72:../FreeRTOS/Sources/tasks.c ****     mission critical applications that require provable dependability.
  73:../FreeRTOS/Sources/tasks.c **** */
  74:../FreeRTOS/Sources/tasks.c **** 
  75:../FreeRTOS/Sources/tasks.c **** /* Standard includes. */
  76:../FreeRTOS/Sources/tasks.c **** #include <stdio.h>
  77:../FreeRTOS/Sources/tasks.c **** #include <stdlib.h>
  78:../FreeRTOS/Sources/tasks.c **** #include <string.h>
  79:../FreeRTOS/Sources/tasks.c **** 
  80:../FreeRTOS/Sources/tasks.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  81:../FreeRTOS/Sources/tasks.c **** all the API functions to use the MPU wrappers.  That should only be done when
  82:../FreeRTOS/Sources/tasks.c **** task.h is included from an application file. */
  83:../FreeRTOS/Sources/tasks.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  84:../FreeRTOS/Sources/tasks.c **** 
  85:../FreeRTOS/Sources/tasks.c **** /* FreeRTOS includes. */
  86:../FreeRTOS/Sources/tasks.c **** #include "FreeRTOS.h"
  87:../FreeRTOS/Sources/tasks.c **** #include "task.h"
  88:../FreeRTOS/Sources/tasks.c **** #include "timers.h"
  89:../FreeRTOS/Sources/tasks.c **** #include "StackMacros.h"
  90:../FreeRTOS/Sources/tasks.c **** 
  91:../FreeRTOS/Sources/tasks.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  92:../FreeRTOS/Sources/tasks.c **** 
  93:../FreeRTOS/Sources/tasks.c **** /* Sanity check the configuration. */
  94:../FreeRTOS/Sources/tasks.c **** #if configUSE_TICKLESS_IDLE != 0
  95:../FreeRTOS/Sources/tasks.c **** 	#if INCLUDE_vTaskSuspend != 1
  96:../FreeRTOS/Sources/tasks.c **** 		#error INCLUDE_vTaskSuspend must be set to 1 if configUSE_TICKLESS_IDLE is not set to 0
  97:../FreeRTOS/Sources/tasks.c **** 	#endif /* INCLUDE_vTaskSuspend */
  98:../FreeRTOS/Sources/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
  99:../FreeRTOS/Sources/tasks.c **** 
 100:../FreeRTOS/Sources/tasks.c **** /*
 101:../FreeRTOS/Sources/tasks.c ****  * Defines the size, in words, of the stack allocated to the idle task.
 102:../FreeRTOS/Sources/tasks.c ****  */
 103:../FreeRTOS/Sources/tasks.c **** #define tskIDLE_STACK_SIZE	configMINIMAL_STACK_SIZE
 104:../FreeRTOS/Sources/tasks.c **** 
 105:../FreeRTOS/Sources/tasks.c **** /*
 106:../FreeRTOS/Sources/tasks.c ****  * Task control block.  A task control block (TCB) is allocated for each task,
 107:../FreeRTOS/Sources/tasks.c ****  * and stores task state information, including a pointer to the task's context
 108:../FreeRTOS/Sources/tasks.c ****  * (the task's run time environment, including register values)
 109:../FreeRTOS/Sources/tasks.c ****  */
 110:../FreeRTOS/Sources/tasks.c **** typedef struct tskTaskControlBlock
 111:../FreeRTOS/Sources/tasks.c **** {
 112:../FreeRTOS/Sources/tasks.c **** 	volatile portSTACK_TYPE	*pxTopOfStack;		/*< Points to the location of the last item placed on the 
 113:../FreeRTOS/Sources/tasks.c **** 
 114:../FreeRTOS/Sources/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
 115:../FreeRTOS/Sources/tasks.c **** 		xMPU_SETTINGS xMPUSettings;				/*< The MPU settings are defined as part of the port layer.  THIS 
 116:../FreeRTOS/Sources/tasks.c **** 	#endif
 117:../FreeRTOS/Sources/tasks.c **** 
 118:../FreeRTOS/Sources/tasks.c **** 	xListItem				xGenericListItem;		/*< The list that the state list item of a task is reference from 
 119:../FreeRTOS/Sources/tasks.c **** 	xListItem				xEventListItem;		/*< Used to reference a task from an event list. */
 120:../FreeRTOS/Sources/tasks.c **** 	unsigned portBASE_TYPE	uxPriority;			/*< The priority of the task.  0 is the lowest priority. */
 121:../FreeRTOS/Sources/tasks.c **** 	portSTACK_TYPE			*pxStack;			/*< Points to the start of the stack. */
 122:../FreeRTOS/Sources/tasks.c **** 	signed char				pcTaskName[ configMAX_TASK_NAME_LEN ];/*< Descriptive name given to the task when c
 123:../FreeRTOS/Sources/tasks.c **** 
 124:../FreeRTOS/Sources/tasks.c **** 	#if ( portSTACK_GROWTH > 0 )
 125:../FreeRTOS/Sources/tasks.c **** 		portSTACK_TYPE *pxEndOfStack;			/*< Points to the end of the stack on architectures where the sta
 126:../FreeRTOS/Sources/tasks.c **** 	#endif
 127:../FreeRTOS/Sources/tasks.c **** 
 128:../FreeRTOS/Sources/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
 129:../FreeRTOS/Sources/tasks.c **** 		unsigned portBASE_TYPE uxCriticalNesting; /*< Holds the critical section nesting depth for ports 
 130:../FreeRTOS/Sources/tasks.c **** 	#endif
 131:../FreeRTOS/Sources/tasks.c **** 
 132:../FreeRTOS/Sources/tasks.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 133:../FreeRTOS/Sources/tasks.c **** 		unsigned portBASE_TYPE	uxTCBNumber;	/*< Stores a number that increments each time a TCB is create
 134:../FreeRTOS/Sources/tasks.c **** 		unsigned portBASE_TYPE  uxTaskNumber;	/*< Stores a number specifically for use by third party tra
 135:../FreeRTOS/Sources/tasks.c **** 	#endif
 136:../FreeRTOS/Sources/tasks.c **** 
 137:../FreeRTOS/Sources/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
 138:../FreeRTOS/Sources/tasks.c **** 		unsigned portBASE_TYPE uxBasePriority;	/*< The priority last assigned to the task - used by the p
 139:../FreeRTOS/Sources/tasks.c **** 	#endif
 140:../FreeRTOS/Sources/tasks.c **** 
 141:../FreeRTOS/Sources/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
 142:../FreeRTOS/Sources/tasks.c **** 		pdTASK_HOOK_CODE pxTaskTag;
 143:../FreeRTOS/Sources/tasks.c **** 	#endif
 144:../FreeRTOS/Sources/tasks.c **** 
 145:../FreeRTOS/Sources/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
 146:../FreeRTOS/Sources/tasks.c **** 		unsigned long ulRunTimeCounter;			/*< Stores the amount of time the task has spent in the Running
 147:../FreeRTOS/Sources/tasks.c **** 	#endif
 148:../FreeRTOS/Sources/tasks.c **** 
 149:../FreeRTOS/Sources/tasks.c **** } tskTCB;
 150:../FreeRTOS/Sources/tasks.c **** 
 151:../FreeRTOS/Sources/tasks.c **** 
 152:../FreeRTOS/Sources/tasks.c **** /*
 153:../FreeRTOS/Sources/tasks.c ****  * Some kernel aware debuggers require the data the debugger needs access to to
 154:../FreeRTOS/Sources/tasks.c ****  * be global, rather than file scope.
 155:../FreeRTOS/Sources/tasks.c ****  */
 156:../FreeRTOS/Sources/tasks.c **** #ifdef portREMOVE_STATIC_QUALIFIER
 157:../FreeRTOS/Sources/tasks.c **** 	#define static
 158:../FreeRTOS/Sources/tasks.c **** #endif
 159:../FreeRTOS/Sources/tasks.c **** 
 160:../FreeRTOS/Sources/tasks.c **** /*lint -e956 */
 161:../FreeRTOS/Sources/tasks.c **** PRIVILEGED_DATA tskTCB * volatile pxCurrentTCB = NULL;
 162:../FreeRTOS/Sources/tasks.c **** 
 163:../FreeRTOS/Sources/tasks.c **** /* Lists for ready and blocked tasks. --------------------*/
 164:../FreeRTOS/Sources/tasks.c **** PRIVILEGED_DATA static xList pxReadyTasksLists[ configMAX_PRIORITIES ];	/*< Prioritised ready tasks
 165:../FreeRTOS/Sources/tasks.c **** PRIVILEGED_DATA static xList xDelayedTaskList1;							/*< Delayed tasks. */
 166:../FreeRTOS/Sources/tasks.c **** PRIVILEGED_DATA static xList xDelayedTaskList2;							/*< Delayed tasks (two lists are used - one f
 167:../FreeRTOS/Sources/tasks.c **** PRIVILEGED_DATA static xList * volatile pxDelayedTaskList ;				/*< Points to the delayed task list 
 168:../FreeRTOS/Sources/tasks.c **** PRIVILEGED_DATA static xList * volatile pxOverflowDelayedTaskList;		/*< Points to the delayed task 
 169:../FreeRTOS/Sources/tasks.c **** PRIVILEGED_DATA static xList xPendingReadyList;							/*< Tasks that have been readied while the sc
 170:../FreeRTOS/Sources/tasks.c **** 
 171:../FreeRTOS/Sources/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 172:../FreeRTOS/Sources/tasks.c **** 
 173:../FreeRTOS/Sources/tasks.c **** 	PRIVILEGED_DATA static xList xTasksWaitingTermination;				/*< Tasks that have been deleted - but t
 174:../FreeRTOS/Sources/tasks.c **** 	PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxTasksDeleted = ( unsigned portBASE_TYPE )
 175:../FreeRTOS/Sources/tasks.c **** 
 176:../FreeRTOS/Sources/tasks.c **** #endif
 177:../FreeRTOS/Sources/tasks.c **** 
 178:../FreeRTOS/Sources/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 179:../FreeRTOS/Sources/tasks.c **** 
 180:../FreeRTOS/Sources/tasks.c **** 	PRIVILEGED_DATA static xList xSuspendedTaskList;					/*< Tasks that are currently suspended. */
 181:../FreeRTOS/Sources/tasks.c **** 
 182:../FreeRTOS/Sources/tasks.c **** #endif
 183:../FreeRTOS/Sources/tasks.c **** 
 184:../FreeRTOS/Sources/tasks.c **** #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
 185:../FreeRTOS/Sources/tasks.c **** 
 186:../FreeRTOS/Sources/tasks.c **** 	PRIVILEGED_DATA static xTaskHandle xIdleTaskHandle = NULL;			/*< Holds the handle of the idle task
 187:../FreeRTOS/Sources/tasks.c **** 
 188:../FreeRTOS/Sources/tasks.c **** #endif
 189:../FreeRTOS/Sources/tasks.c **** 
 190:../FreeRTOS/Sources/tasks.c **** /* File private variables. --------------------------------*/
 191:../FreeRTOS/Sources/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxCurrentNumberOfTasks 	= ( unsigned portBAS
 192:../FreeRTOS/Sources/tasks.c **** PRIVILEGED_DATA static volatile portTickType xTickCount 						= ( portTickType ) 0U;
 193:../FreeRTOS/Sources/tasks.c **** PRIVILEGED_DATA static unsigned portBASE_TYPE uxTopUsedPriority	 				= tskIDLE_PRIORITY;
 194:../FreeRTOS/Sources/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxTopReadyPriority 		= tskIDLE_PRIORITY;
 195:../FreeRTOS/Sources/tasks.c **** PRIVILEGED_DATA static volatile signed portBASE_TYPE xSchedulerRunning 			= pdFALSE;
 196:../FreeRTOS/Sources/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxSchedulerSuspended	 	= ( unsigned portBASE
 197:../FreeRTOS/Sources/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxMissedTicks 			= ( unsigned portBASE_TYPE 
 198:../FreeRTOS/Sources/tasks.c **** PRIVILEGED_DATA static volatile portBASE_TYPE xMissedYield 						= ( portBASE_TYPE ) pdFALSE;
 199:../FreeRTOS/Sources/tasks.c **** PRIVILEGED_DATA static volatile portBASE_TYPE xNumOfOverflows 					= ( portBASE_TYPE ) 0;
 200:../FreeRTOS/Sources/tasks.c **** PRIVILEGED_DATA static unsigned portBASE_TYPE uxTaskNumber 						= ( unsigned portBASE_TYPE ) 0U;
 201:../FreeRTOS/Sources/tasks.c **** PRIVILEGED_DATA static volatile portTickType xNextTaskUnblockTime				= ( portTickType ) portMAX_DEL
 202:../FreeRTOS/Sources/tasks.c **** 
 203:../FreeRTOS/Sources/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
 204:../FreeRTOS/Sources/tasks.c **** 
 205:../FreeRTOS/Sources/tasks.c **** 	PRIVILEGED_DATA static char pcStatsString[ 50 ] ;
 206:../FreeRTOS/Sources/tasks.c **** 	PRIVILEGED_DATA static unsigned long ulTaskSwitchedInTime = 0UL;	/*< Holds the value of a timer/co
 207:../FreeRTOS/Sources/tasks.c **** 	PRIVILEGED_DATA static unsigned long ulTotalRunTime;				/*< Holds the total amount of execution ti
 208:../FreeRTOS/Sources/tasks.c **** 	static void prvGenerateRunTimeStatsForTasksInList( const signed char *pcWriteBuffer, xList *pxList
 209:../FreeRTOS/Sources/tasks.c **** 
 210:../FreeRTOS/Sources/tasks.c **** #endif
 211:../FreeRTOS/Sources/tasks.c **** 
 212:../FreeRTOS/Sources/tasks.c **** /* Debugging and trace facilities private variables and macros. ------------*/
 213:../FreeRTOS/Sources/tasks.c **** 
 214:../FreeRTOS/Sources/tasks.c **** /*
 215:../FreeRTOS/Sources/tasks.c ****  * The value used to fill the stack of a task when the task is created.  This
 216:../FreeRTOS/Sources/tasks.c ****  * is used purely for checking the high water mark for tasks.
 217:../FreeRTOS/Sources/tasks.c ****  */
 218:../FreeRTOS/Sources/tasks.c **** #define tskSTACK_FILL_BYTE	( 0xa5U )
 219:../FreeRTOS/Sources/tasks.c **** 
 220:../FreeRTOS/Sources/tasks.c **** /*
 221:../FreeRTOS/Sources/tasks.c ****  * Macros used by vListTask to indicate which state a task is in.
 222:../FreeRTOS/Sources/tasks.c ****  */
 223:../FreeRTOS/Sources/tasks.c **** #define tskBLOCKED_CHAR		( ( signed char ) 'B' )
 224:../FreeRTOS/Sources/tasks.c **** #define tskREADY_CHAR		( ( signed char ) 'R' )
 225:../FreeRTOS/Sources/tasks.c **** #define tskDELETED_CHAR		( ( signed char ) 'D' )
 226:../FreeRTOS/Sources/tasks.c **** #define tskSUSPENDED_CHAR	( ( signed char ) 'S' )
 227:../FreeRTOS/Sources/tasks.c **** 
 228:../FreeRTOS/Sources/tasks.c **** /*-----------------------------------------------------------*/
 229:../FreeRTOS/Sources/tasks.c **** 
 230:../FreeRTOS/Sources/tasks.c **** #if ( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
 231:../FreeRTOS/Sources/tasks.c **** 
 232:../FreeRTOS/Sources/tasks.c **** 	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 0 then task selection is
 233:../FreeRTOS/Sources/tasks.c **** 	performed in a generic way that is not optimised to any particular
 234:../FreeRTOS/Sources/tasks.c **** 	microcontroller architecture. */
 235:../FreeRTOS/Sources/tasks.c **** 
 236:../FreeRTOS/Sources/tasks.c **** 	/* uxTopReadyPriority holds the priority of the highest priority ready
 237:../FreeRTOS/Sources/tasks.c **** 	state task. */
 238:../FreeRTOS/Sources/tasks.c **** 	#define taskRECORD_READY_PRIORITY( uxPriority )																		\
 239:../FreeRTOS/Sources/tasks.c **** 	{																													\
 240:../FreeRTOS/Sources/tasks.c **** 		if( ( uxPriority ) > uxTopReadyPriority )																		\
 241:../FreeRTOS/Sources/tasks.c **** 		{																												\
 242:../FreeRTOS/Sources/tasks.c **** 			uxTopReadyPriority = ( uxPriority );																		\
 243:../FreeRTOS/Sources/tasks.c **** 		}																												\
 244:../FreeRTOS/Sources/tasks.c **** 	} /* taskRECORD_READY_PRIORITY */
 245:../FreeRTOS/Sources/tasks.c **** 
 246:../FreeRTOS/Sources/tasks.c **** 	/*-----------------------------------------------------------*/
 247:../FreeRTOS/Sources/tasks.c **** 
 248:../FreeRTOS/Sources/tasks.c **** 	#define taskSELECT_HIGHEST_PRIORITY_TASK()																			\
 249:../FreeRTOS/Sources/tasks.c **** 	{																													\
 250:../FreeRTOS/Sources/tasks.c **** 		/* Find the highest priority queue that contains ready tasks. */												\
 251:../FreeRTOS/Sources/tasks.c **** 		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )										\
 252:../FreeRTOS/Sources/tasks.c **** 		{																												\
 253:../FreeRTOS/Sources/tasks.c **** 			configASSERT( uxTopReadyPriority );																			\
 254:../FreeRTOS/Sources/tasks.c **** 			--uxTopReadyPriority;																						\
 255:../FreeRTOS/Sources/tasks.c **** 		}																												\
 256:../FreeRTOS/Sources/tasks.c **** 																														\
 257:../FreeRTOS/Sources/tasks.c **** 		/* listGET_OWNER_OF_NEXT_ENTRY indexes through the list, so the tasks of										\
 258:../FreeRTOS/Sources/tasks.c **** 		the	same priority get an equal share of the processor time. */													\
 259:../FreeRTOS/Sources/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );						\
 260:../FreeRTOS/Sources/tasks.c **** 	} /* taskSELECT_HIGHEST_PRIORITY_TASK */
 261:../FreeRTOS/Sources/tasks.c **** 
 262:../FreeRTOS/Sources/tasks.c **** 	/*-----------------------------------------------------------*/
 263:../FreeRTOS/Sources/tasks.c **** 
 264:../FreeRTOS/Sources/tasks.c **** 	/* Define away taskRESET_READY_PRIORITY() and portRESET_READY_PRIORITY() as
 265:../FreeRTOS/Sources/tasks.c **** 	they are only required when a port optimised method of task selection is
 266:../FreeRTOS/Sources/tasks.c **** 	being used. */
 267:../FreeRTOS/Sources/tasks.c **** 	#define taskRESET_READY_PRIORITY( uxPriority )
 268:../FreeRTOS/Sources/tasks.c **** 	#define portRESET_READY_PRIORITY( uxPriority, uxTopReadyPriority )
 269:../FreeRTOS/Sources/tasks.c **** 
 270:../FreeRTOS/Sources/tasks.c **** #else /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 271:../FreeRTOS/Sources/tasks.c **** 
 272:../FreeRTOS/Sources/tasks.c **** 	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 1 then task selection is
 273:../FreeRTOS/Sources/tasks.c **** 	performed in a way that is tailored to the particular microcontroller
 274:../FreeRTOS/Sources/tasks.c **** 	architecture being used. */
 275:../FreeRTOS/Sources/tasks.c **** 
 276:../FreeRTOS/Sources/tasks.c **** 	/* A port optimised version is provided.  Call the port defined macros. */
 277:../FreeRTOS/Sources/tasks.c **** 	#define taskRECORD_READY_PRIORITY( uxPriority )	portRECORD_READY_PRIORITY( uxPriority, uxTopReadyP
 278:../FreeRTOS/Sources/tasks.c **** 
 279:../FreeRTOS/Sources/tasks.c **** 	/*-----------------------------------------------------------*/
 280:../FreeRTOS/Sources/tasks.c **** 
 281:../FreeRTOS/Sources/tasks.c **** 	#define taskSELECT_HIGHEST_PRIORITY_TASK()														\
 282:../FreeRTOS/Sources/tasks.c **** 	{																								\
 283:../FreeRTOS/Sources/tasks.c **** 	unsigned portBASE_TYPE uxTopPriority;															\
 284:../FreeRTOS/Sources/tasks.c **** 																									\
 285:../FreeRTOS/Sources/tasks.c **** 		/* Find the highest priority queue that contains ready tasks. */							\
 286:../FreeRTOS/Sources/tasks.c **** 		portGET_HIGHEST_PRIORITY( uxTopPriority, uxTopReadyPriority );								\
 287:../FreeRTOS/Sources/tasks.c **** 		configASSERT( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ uxTopPriority ] ) ) > 0 );		\
 288:../FreeRTOS/Sources/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );		\
 289:../FreeRTOS/Sources/tasks.c **** 	} /* taskSELECT_HIGHEST_PRIORITY_TASK() */
 290:../FreeRTOS/Sources/tasks.c **** 
 291:../FreeRTOS/Sources/tasks.c **** 	/*-----------------------------------------------------------*/
 292:../FreeRTOS/Sources/tasks.c **** 
 293:../FreeRTOS/Sources/tasks.c **** 	/* A port optimised version is provided, call it only if the TCB being reset
 294:../FreeRTOS/Sources/tasks.c **** 	is being referenced from a ready list.  If it is referenced from a delayed
 295:../FreeRTOS/Sources/tasks.c **** 	or suspended list then it won't be in a ready list. */
 296:../FreeRTOS/Sources/tasks.c **** 	#define taskRESET_READY_PRIORITY( uxPriority )													\
 297:../FreeRTOS/Sources/tasks.c **** 	{																								\
 298:../FreeRTOS/Sources/tasks.c **** 		if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ ( uxPriority ) ] ) ) == 0 )				\
 299:../FreeRTOS/Sources/tasks.c **** 		{																							\
 300:../FreeRTOS/Sources/tasks.c **** 			portRESET_READY_PRIORITY( ( uxPriority ), ( uxTopReadyPriority ) );						\
 301:../FreeRTOS/Sources/tasks.c **** 		}																							\
 302:../FreeRTOS/Sources/tasks.c **** 	}
 303:../FreeRTOS/Sources/tasks.c **** 
 304:../FreeRTOS/Sources/tasks.c **** #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 305:../FreeRTOS/Sources/tasks.c **** 
 306:../FreeRTOS/Sources/tasks.c **** /*
 307:../FreeRTOS/Sources/tasks.c ****  * Place the task represented by pxTCB into the appropriate ready queue for
 308:../FreeRTOS/Sources/tasks.c ****  * the task.  It is inserted at the end of the list.  One quirk of this is
 309:../FreeRTOS/Sources/tasks.c ****  * that if the task being inserted is at the same priority as the currently
 310:../FreeRTOS/Sources/tasks.c ****  * executing task, then it will only be rescheduled after the currently
 311:../FreeRTOS/Sources/tasks.c ****  * executing task has been rescheduled.
 312:../FreeRTOS/Sources/tasks.c ****  */
 313:../FreeRTOS/Sources/tasks.c **** #define prvAddTaskToReadyQueue( pxTCB )																				\
 314:../FreeRTOS/Sources/tasks.c **** 	traceMOVED_TASK_TO_READY_STATE( pxTCB )																			\
 315:../FreeRTOS/Sources/tasks.c **** 	taskRECORD_READY_PRIORITY( ( pxTCB )->uxPriority );																\
 316:../FreeRTOS/Sources/tasks.c **** 	vListInsertEnd( ( xList * ) &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xGeneri
 317:../FreeRTOS/Sources/tasks.c **** /*-----------------------------------------------------------*/
 318:../FreeRTOS/Sources/tasks.c **** 
 319:../FreeRTOS/Sources/tasks.c **** /*
 320:../FreeRTOS/Sources/tasks.c ****  * Macro that looks at the list of tasks that are currently delayed to see if
 321:../FreeRTOS/Sources/tasks.c ****  * any require waking.
 322:../FreeRTOS/Sources/tasks.c ****  *
 323:../FreeRTOS/Sources/tasks.c ****  * Tasks are stored in the queue in the order of their wake time - meaning
 324:../FreeRTOS/Sources/tasks.c ****  * once one tasks has been found whose timer has not expired we need not look
 325:../FreeRTOS/Sources/tasks.c ****  * any further down the list.
 326:../FreeRTOS/Sources/tasks.c ****  */
 327:../FreeRTOS/Sources/tasks.c **** #define prvCheckDelayedTasks()															\
 328:../FreeRTOS/Sources/tasks.c **** {																						\
 329:../FreeRTOS/Sources/tasks.c **** portTickType xItemValue;																\
 330:../FreeRTOS/Sources/tasks.c **** 																						\
 331:../FreeRTOS/Sources/tasks.c **** 	/* Is the tick count greater than or equal to the wake time of the first			\
 332:../FreeRTOS/Sources/tasks.c **** 	task referenced from the delayed tasks list? */										\
 333:../FreeRTOS/Sources/tasks.c **** 	if( xTickCount >= xNextTaskUnblockTime )											\
 334:../FreeRTOS/Sources/tasks.c **** 	{																					\
 335:../FreeRTOS/Sources/tasks.c **** 		for( ;; )																		\
 336:../FreeRTOS/Sources/tasks.c **** 		{																				\
 337:../FreeRTOS/Sources/tasks.c **** 			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )						\
 338:../FreeRTOS/Sources/tasks.c **** 			{																			\
 339:../FreeRTOS/Sources/tasks.c **** 				/* The delayed list is empty.  Set xNextTaskUnblockTime to the			\
 340:../FreeRTOS/Sources/tasks.c **** 				maximum possible value so it is extremely unlikely that the				\
 341:../FreeRTOS/Sources/tasks.c **** 				if( xTickCount >= xNextTaskUnblockTime ) test will pass next			\
 342:../FreeRTOS/Sources/tasks.c **** 				time through. */														\
 343:../FreeRTOS/Sources/tasks.c **** 				xNextTaskUnblockTime = portMAX_DELAY;									\
 344:../FreeRTOS/Sources/tasks.c **** 				break;																	\
 345:../FreeRTOS/Sources/tasks.c **** 			}																			\
 346:../FreeRTOS/Sources/tasks.c **** 			else																		\
 347:../FreeRTOS/Sources/tasks.c **** 			{																			\
 348:../FreeRTOS/Sources/tasks.c **** 				/* The delayed list is not empty, get the value of the item at			\
 349:../FreeRTOS/Sources/tasks.c **** 				the head of the delayed list.  This is the time at which the			\
 350:../FreeRTOS/Sources/tasks.c **** 				task at the head of the delayed list should be removed from				\
 351:../FreeRTOS/Sources/tasks.c **** 				the Blocked state. */													\
 352:../FreeRTOS/Sources/tasks.c **** 				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );	\
 353:../FreeRTOS/Sources/tasks.c **** 				xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );	\
 354:../FreeRTOS/Sources/tasks.c **** 																						\
 355:../FreeRTOS/Sources/tasks.c **** 				if( xTickCount < xItemValue )											\
 356:../FreeRTOS/Sources/tasks.c **** 				{																		\
 357:../FreeRTOS/Sources/tasks.c **** 					/* It is not time to unblock this item yet, but the item			\
 358:../FreeRTOS/Sources/tasks.c **** 					value is the time at which the task at the head of the				\
 359:../FreeRTOS/Sources/tasks.c **** 					blocked list should be removed from the Blocked state -				\
 360:../FreeRTOS/Sources/tasks.c **** 					so record the item value in xNextTaskUnblockTime. */				\
 361:../FreeRTOS/Sources/tasks.c **** 					xNextTaskUnblockTime = xItemValue;									\
 362:../FreeRTOS/Sources/tasks.c **** 					break;																\
 363:../FreeRTOS/Sources/tasks.c **** 				}																		\
 364:../FreeRTOS/Sources/tasks.c **** 																						\
 365:../FreeRTOS/Sources/tasks.c **** 				/* It is time to remove the item from the Blocked state. */				\
 366:../FreeRTOS/Sources/tasks.c **** 				uxListRemove( &( pxTCB->xGenericListItem ) );							\
 367:../FreeRTOS/Sources/tasks.c **** 																						\
 368:../FreeRTOS/Sources/tasks.c **** 				/* Is the task waiting on an event also? */								\
 369:../FreeRTOS/Sources/tasks.c **** 				if( pxTCB->xEventListItem.pvContainer != NULL )							\
 370:../FreeRTOS/Sources/tasks.c **** 				{																		\
 371:../FreeRTOS/Sources/tasks.c **** 					uxListRemove( &( pxTCB->xEventListItem ) );							\
 372:../FreeRTOS/Sources/tasks.c **** 				}																		\
 373:../FreeRTOS/Sources/tasks.c **** 				prvAddTaskToReadyQueue( pxTCB );										\
 374:../FreeRTOS/Sources/tasks.c **** 			}																			\
 375:../FreeRTOS/Sources/tasks.c **** 		}																				\
 376:../FreeRTOS/Sources/tasks.c **** 	}																					\
 377:../FreeRTOS/Sources/tasks.c **** }
 378:../FreeRTOS/Sources/tasks.c **** /*-----------------------------------------------------------*/
 379:../FreeRTOS/Sources/tasks.c **** 
 380:../FreeRTOS/Sources/tasks.c **** /*
 381:../FreeRTOS/Sources/tasks.c ****  * Several functions take an xTaskHandle parameter that can optionally be NULL,
 382:../FreeRTOS/Sources/tasks.c ****  * where NULL is used to indicate that the handle of the currently executing
 383:../FreeRTOS/Sources/tasks.c ****  * task should be used in place of the parameter.  This macro simply checks to
 384:../FreeRTOS/Sources/tasks.c ****  * see if the parameter is NULL and returns a pointer to the appropriate TCB.
 385:../FreeRTOS/Sources/tasks.c ****  */
 386:../FreeRTOS/Sources/tasks.c **** #define prvGetTCBFromHandle( pxHandle ) ( ( ( pxHandle ) == NULL ) ? ( tskTCB * ) pxCurrentTCB : ( 
 387:../FreeRTOS/Sources/tasks.c **** 
 388:../FreeRTOS/Sources/tasks.c **** /* Callback function prototypes. --------------------------*/
 389:../FreeRTOS/Sources/tasks.c **** extern void vApplicationStackOverflowHook( xTaskHandle xTask, signed char *pcTaskName );
 390:../FreeRTOS/Sources/tasks.c **** extern void vApplicationTickHook( void );
 391:../FreeRTOS/Sources/tasks.c **** 
 392:../FreeRTOS/Sources/tasks.c **** /* File private functions. --------------------------------*/
 393:../FreeRTOS/Sources/tasks.c **** 
 394:../FreeRTOS/Sources/tasks.c **** /*
 395:../FreeRTOS/Sources/tasks.c ****  * Utility to ready a TCB for a given task.  Mainly just copies the parameters
 396:../FreeRTOS/Sources/tasks.c ****  * into the TCB structure.
 397:../FreeRTOS/Sources/tasks.c ****  */
 398:../FreeRTOS/Sources/tasks.c **** static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned po
 399:../FreeRTOS/Sources/tasks.c **** 
 400:../FreeRTOS/Sources/tasks.c **** /*
 401:../FreeRTOS/Sources/tasks.c ****  * Utility to ready all the lists used by the scheduler.  This is called
 402:../FreeRTOS/Sources/tasks.c ****  * automatically upon the creation of the first task.
 403:../FreeRTOS/Sources/tasks.c ****  */
 404:../FreeRTOS/Sources/tasks.c **** static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
 405:../FreeRTOS/Sources/tasks.c **** 
 406:../FreeRTOS/Sources/tasks.c **** /*
 407:../FreeRTOS/Sources/tasks.c ****  * The idle task, which as all tasks is implemented as a never ending loop.
 408:../FreeRTOS/Sources/tasks.c ****  * The idle task is automatically created and added to the ready lists upon
 409:../FreeRTOS/Sources/tasks.c ****  * creation of the first user task.
 410:../FreeRTOS/Sources/tasks.c ****  *
 411:../FreeRTOS/Sources/tasks.c ****  * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
 412:../FreeRTOS/Sources/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
 413:../FreeRTOS/Sources/tasks.c ****  *
 414:../FreeRTOS/Sources/tasks.c ****  * void prvIdleTask( void *pvParameters );
 415:../FreeRTOS/Sources/tasks.c ****  *
 416:../FreeRTOS/Sources/tasks.c ****  */
 417:../FreeRTOS/Sources/tasks.c **** static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters );
 418:../FreeRTOS/Sources/tasks.c **** 
 419:../FreeRTOS/Sources/tasks.c **** /*
 420:../FreeRTOS/Sources/tasks.c ****  * Utility to free all memory allocated by the scheduler to hold a TCB,
 421:../FreeRTOS/Sources/tasks.c ****  * including the stack pointed to by the TCB.
 422:../FreeRTOS/Sources/tasks.c ****  *
 423:../FreeRTOS/Sources/tasks.c ****  * This does not free memory allocated by the task itself (i.e. memory
 424:../FreeRTOS/Sources/tasks.c ****  * allocated by calls to pvPortMalloc from within the tasks application code).
 425:../FreeRTOS/Sources/tasks.c ****  */
 426:../FreeRTOS/Sources/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 427:../FreeRTOS/Sources/tasks.c **** 
 428:../FreeRTOS/Sources/tasks.c **** 	static void prvDeleteTCB( tskTCB *pxTCB ) PRIVILEGED_FUNCTION;
 429:../FreeRTOS/Sources/tasks.c **** 
 430:../FreeRTOS/Sources/tasks.c **** #endif
 431:../FreeRTOS/Sources/tasks.c **** 
 432:../FreeRTOS/Sources/tasks.c **** /*
 433:../FreeRTOS/Sources/tasks.c ****  * Used only by the idle task.  This checks to see if anything has been placed
 434:../FreeRTOS/Sources/tasks.c ****  * in the list of tasks waiting to be deleted.  If so the task is cleaned up
 435:../FreeRTOS/Sources/tasks.c ****  * and its TCB deleted.
 436:../FreeRTOS/Sources/tasks.c ****  */
 437:../FreeRTOS/Sources/tasks.c **** static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
 438:../FreeRTOS/Sources/tasks.c **** 
 439:../FreeRTOS/Sources/tasks.c **** /*
 440:../FreeRTOS/Sources/tasks.c ****  * The currently executing task is entering the Blocked state.  Add the task to
 441:../FreeRTOS/Sources/tasks.c ****  * either the current or the overflow delayed task list.
 442:../FreeRTOS/Sources/tasks.c ****  */
 443:../FreeRTOS/Sources/tasks.c **** static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake ) PRIVILEGED_FUNCTION;
 444:../FreeRTOS/Sources/tasks.c **** 
 445:../FreeRTOS/Sources/tasks.c **** /*
 446:../FreeRTOS/Sources/tasks.c ****  * Allocates memory from the heap for a TCB and associated stack.  Checks the
 447:../FreeRTOS/Sources/tasks.c ****  * allocation was successful.
 448:../FreeRTOS/Sources/tasks.c ****  */
 449:../FreeRTOS/Sources/tasks.c **** static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer 
 450:../FreeRTOS/Sources/tasks.c **** 
 451:../FreeRTOS/Sources/tasks.c **** /*
 452:../FreeRTOS/Sources/tasks.c ****  * Called from vTaskList.  vListTasks details all the tasks currently under
 453:../FreeRTOS/Sources/tasks.c ****  * control of the scheduler.  The tasks may be in one of a number of lists.
 454:../FreeRTOS/Sources/tasks.c ****  * prvListTaskWithinSingleList accepts a list and details the tasks from
 455:../FreeRTOS/Sources/tasks.c ****  * within just that list.
 456:../FreeRTOS/Sources/tasks.c ****  *
 457:../FreeRTOS/Sources/tasks.c ****  * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
 458:../FreeRTOS/Sources/tasks.c ****  * NORMAL APPLICATION CODE.
 459:../FreeRTOS/Sources/tasks.c ****  */
 460:../FreeRTOS/Sources/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
 461:../FreeRTOS/Sources/tasks.c **** 
 462:../FreeRTOS/Sources/tasks.c **** 	static void prvListTaskWithinSingleList( const signed char *pcWriteBuffer, xList *pxList, signed c
 463:../FreeRTOS/Sources/tasks.c **** 
 464:../FreeRTOS/Sources/tasks.c **** #endif
 465:../FreeRTOS/Sources/tasks.c **** 
 466:../FreeRTOS/Sources/tasks.c **** /*
 467:../FreeRTOS/Sources/tasks.c ****  * When a task is created, the stack of the task is filled with a known value.
 468:../FreeRTOS/Sources/tasks.c ****  * This function determines the 'high water mark' of the task stack by
 469:../FreeRTOS/Sources/tasks.c ****  * determining how much of the stack remains at the original preset value.
 470:../FreeRTOS/Sources/tasks.c ****  */
 471:../FreeRTOS/Sources/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
 472:../FreeRTOS/Sources/tasks.c **** 
 473:../FreeRTOS/Sources/tasks.c **** 	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte ) PRIVILEGED_F
 474:../FreeRTOS/Sources/tasks.c **** 
 475:../FreeRTOS/Sources/tasks.c **** #endif
 476:../FreeRTOS/Sources/tasks.c **** 
 477:../FreeRTOS/Sources/tasks.c **** /*
 478:../FreeRTOS/Sources/tasks.c ****  * Return the amount of time, in ticks, that will pass before the kernel will
 479:../FreeRTOS/Sources/tasks.c ****  * next move a task from the Blocked state to the Running state.
 480:../FreeRTOS/Sources/tasks.c ****  *
 481:../FreeRTOS/Sources/tasks.c ****  * This conditional compilation should use inequality to 0, not equality to 1.
 482:../FreeRTOS/Sources/tasks.c ****  * This is to ensure portSUPPRESS_TICKS_AND_SLEEP() can be called when user
 483:../FreeRTOS/Sources/tasks.c ****  * defined low power mode implementations require configUSE_TICKLESS_IDLE to be
 484:../FreeRTOS/Sources/tasks.c ****  * set to a value other than 1.
 485:../FreeRTOS/Sources/tasks.c ****  */
 486:../FreeRTOS/Sources/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
 487:../FreeRTOS/Sources/tasks.c **** 
 488:../FreeRTOS/Sources/tasks.c **** 	static portTickType prvGetExpectedIdleTime( void ) PRIVILEGED_FUNCTION;
 489:../FreeRTOS/Sources/tasks.c **** 
 490:../FreeRTOS/Sources/tasks.c **** #endif
 491:../FreeRTOS/Sources/tasks.c **** 
 492:../FreeRTOS/Sources/tasks.c **** /*lint +e956 */
 493:../FreeRTOS/Sources/tasks.c **** 
 494:../FreeRTOS/Sources/tasks.c **** signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, 
 495:../FreeRTOS/Sources/tasks.c **** {
 154              		.loc 1 495 0
 155              		.cfi_startproc
 156              		@ args = 16, pretend = 0, frame = 32
 157              		@ frame_needed = 1, uses_anonymous_args = 0
 158 0000 80B5     		push	{r7, lr}
 159              	.LCFI0:
 160              		.cfi_def_cfa_offset 8
 161              		.cfi_offset 7, -8
 162              		.cfi_offset 14, -4
 163 0002 8AB0     		sub	sp, sp, #40
 164              	.LCFI1:
 165              		.cfi_def_cfa_offset 48
 166 0004 02AF     		add	r7, sp, #8
 167              	.LCFI2:
 168              		.cfi_def_cfa 7, 40
 169 0006 F860     		str	r0, [r7, #12]
 170 0008 B960     		str	r1, [r7, #8]
 171 000a 3B60     		str	r3, [r7, #0]
 172 000c 1346     		mov	r3, r2	@ movhi
 173 000e FB80     		strh	r3, [r7, #6]	@ movhi
 496:../FreeRTOS/Sources/tasks.c **** signed portBASE_TYPE xReturn;
 497:../FreeRTOS/Sources/tasks.c **** tskTCB * pxNewTCB;
 498:../FreeRTOS/Sources/tasks.c **** 
 499:../FreeRTOS/Sources/tasks.c **** 	configASSERT( pxTaskCode );
 174              		.loc 1 499 0
 175 0010 FB68     		ldr	r3, [r7, #12]
 176 0012 002B     		cmp	r3, #0
 177 0014 02D1     		bne	.L2
 178              		.loc 1 499 0 is_stmt 0 discriminator 1
 179 0016 FFF7FEFF 		bl	ulPortSetInterruptMask
 180              	.L3:
 181              		.loc 1 499 0 discriminator 2
 182 001a FEE7     		b	.L3
 183              	.L2:
 500:../FreeRTOS/Sources/tasks.c **** 	configASSERT( ( ( uxPriority & ( ~portPRIVILEGE_BIT ) ) < configMAX_PRIORITIES ) );
 184              		.loc 1 500 0 is_stmt 1
 185 001c BB6A     		ldr	r3, [r7, #40]
 186 001e 042B     		cmp	r3, #4
 187 0020 02D9     		bls	.L4
 188              		.loc 1 500 0 is_stmt 0 discriminator 1
 189 0022 FFF7FEFF 		bl	ulPortSetInterruptMask
 190              	.L5:
 191              		.loc 1 500 0 discriminator 2
 192 0026 FEE7     		b	.L5
 193              	.L4:
 501:../FreeRTOS/Sources/tasks.c **** 
 502:../FreeRTOS/Sources/tasks.c **** 	/* Allocate the memory required by the TCB and stack for the new task,
 503:../FreeRTOS/Sources/tasks.c **** 	checking that the allocation was successful. */
 504:../FreeRTOS/Sources/tasks.c **** 	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
 194              		.loc 1 504 0 is_stmt 1
 195 0028 FB88     		ldrh	r3, [r7, #6]
 196 002a 1846     		mov	r0, r3
 197 002c 396B     		ldr	r1, [r7, #48]
 198 002e FFF7FEFF 		bl	prvAllocateTCBAndStack
 199 0032 B861     		str	r0, [r7, #24]
 505:../FreeRTOS/Sources/tasks.c **** 
 506:../FreeRTOS/Sources/tasks.c **** 	if( pxNewTCB != NULL )
 200              		.loc 1 506 0
 201 0034 BB69     		ldr	r3, [r7, #24]
 202 0036 002B     		cmp	r3, #0
 203 0038 00F0B580 		beq	.L6
 204              	.LBB2:
 507:../FreeRTOS/Sources/tasks.c **** 	{
 508:../FreeRTOS/Sources/tasks.c **** 		portSTACK_TYPE *pxTopOfStack;
 509:../FreeRTOS/Sources/tasks.c **** 
 510:../FreeRTOS/Sources/tasks.c **** 		#if( portUSING_MPU_WRAPPERS == 1 )
 511:../FreeRTOS/Sources/tasks.c **** 			/* Should the task be created in privileged mode? */
 512:../FreeRTOS/Sources/tasks.c **** 			portBASE_TYPE xRunPrivileged;
 513:../FreeRTOS/Sources/tasks.c **** 			if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
 514:../FreeRTOS/Sources/tasks.c **** 			{
 515:../FreeRTOS/Sources/tasks.c **** 				xRunPrivileged = pdTRUE;
 516:../FreeRTOS/Sources/tasks.c **** 			}
 517:../FreeRTOS/Sources/tasks.c **** 			else
 518:../FreeRTOS/Sources/tasks.c **** 			{
 519:../FreeRTOS/Sources/tasks.c **** 				xRunPrivileged = pdFALSE;
 520:../FreeRTOS/Sources/tasks.c **** 			}
 521:../FreeRTOS/Sources/tasks.c **** 			uxPriority &= ~portPRIVILEGE_BIT;
 522:../FreeRTOS/Sources/tasks.c **** 		#endif /* portUSING_MPU_WRAPPERS == 1 */
 523:../FreeRTOS/Sources/tasks.c **** 
 524:../FreeRTOS/Sources/tasks.c **** 		/* Calculate the top of stack address.  This depends on whether the
 525:../FreeRTOS/Sources/tasks.c **** 		stack grows from high memory to low (as per the 80x86) or visa versa.
 526:../FreeRTOS/Sources/tasks.c **** 		portSTACK_GROWTH is used to make the result positive or negative as
 527:../FreeRTOS/Sources/tasks.c **** 		required by the port. */
 528:../FreeRTOS/Sources/tasks.c **** 		#if( portSTACK_GROWTH < 0 )
 529:../FreeRTOS/Sources/tasks.c **** 		{
 530:../FreeRTOS/Sources/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
 205              		.loc 1 530 0
 206 003c BB69     		ldr	r3, [r7, #24]
 207 003e 1A6B     		ldr	r2, [r3, #48]
 208 0040 FB88     		ldrh	r3, [r7, #6]
 209 0042 03F1FF33 		add	r3, r3, #-1
 210 0046 4FEA8303 		lsl	r3, r3, #2
 211 004a D318     		adds	r3, r2, r3
 212 004c 7B61     		str	r3, [r7, #20]
 531:../FreeRTOS/Sources/tasks.c **** 			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ( portPOINT
 213              		.loc 1 531 0
 214 004e 7B69     		ldr	r3, [r7, #20]
 215 0050 23F00703 		bic	r3, r3, #7
 216 0054 7B61     		str	r3, [r7, #20]
 532:../FreeRTOS/Sources/tasks.c **** 
 533:../FreeRTOS/Sources/tasks.c **** 			/* Check the alignment of the calculated top of stack is correct. */
 534:../FreeRTOS/Sources/tasks.c **** 			configASSERT( ( ( ( unsigned long ) pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) =
 217              		.loc 1 534 0
 218 0056 7B69     		ldr	r3, [r7, #20]
 219 0058 03F00703 		and	r3, r3, #7
 220 005c 002B     		cmp	r3, #0
 221 005e 02D0     		beq	.L7
 222              		.loc 1 534 0 is_stmt 0 discriminator 1
 223 0060 FFF7FEFF 		bl	ulPortSetInterruptMask
 224              	.L8:
 225              		.loc 1 534 0 discriminator 2
 226 0064 FEE7     		b	.L8
 227              	.L7:
 535:../FreeRTOS/Sources/tasks.c **** 		}
 536:../FreeRTOS/Sources/tasks.c **** 		#else /* portSTACK_GROWTH */
 537:../FreeRTOS/Sources/tasks.c **** 		{
 538:../FreeRTOS/Sources/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack;
 539:../FreeRTOS/Sources/tasks.c **** 
 540:../FreeRTOS/Sources/tasks.c **** 			/* Check the alignment of the stack buffer is correct. */
 541:../FreeRTOS/Sources/tasks.c **** 			configASSERT( ( ( ( unsigned long ) pxNewTCB->pxStack & ( unsigned long ) portBYTE_ALIGNMENT_MAS
 542:../FreeRTOS/Sources/tasks.c **** 
 543:../FreeRTOS/Sources/tasks.c **** 			/* If we want to use stack checking on architectures that use
 544:../FreeRTOS/Sources/tasks.c **** 			a positive stack growth direction then we also need to store the
 545:../FreeRTOS/Sources/tasks.c **** 			other extreme of the stack space. */
 546:../FreeRTOS/Sources/tasks.c **** 			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
 547:../FreeRTOS/Sources/tasks.c **** 		}
 548:../FreeRTOS/Sources/tasks.c **** 		#endif /* portSTACK_GROWTH */
 549:../FreeRTOS/Sources/tasks.c **** 
 550:../FreeRTOS/Sources/tasks.c **** 		/* Setup the newly allocated TCB with the initial state of the task. */
 551:../FreeRTOS/Sources/tasks.c **** 		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
 228              		.loc 1 551 0 is_stmt 1
 229 0066 FB88     		ldrh	r3, [r7, #6]
 230 0068 0093     		str	r3, [sp, #0]
 231 006a B869     		ldr	r0, [r7, #24]
 232 006c B968     		ldr	r1, [r7, #8]
 233 006e BA6A     		ldr	r2, [r7, #40]
 234 0070 7B6B     		ldr	r3, [r7, #52]
 235 0072 FFF7FEFF 		bl	prvInitialiseTCBVariables
 552:../FreeRTOS/Sources/tasks.c **** 
 553:../FreeRTOS/Sources/tasks.c **** 		/* Initialize the TCB stack to look as if the task was already running,
 554:../FreeRTOS/Sources/tasks.c **** 		but had been interrupted by the scheduler.  The return address is set
 555:../FreeRTOS/Sources/tasks.c **** 		to the start of the task function. Once the stack has been initialised
 556:../FreeRTOS/Sources/tasks.c **** 		the	top of stack variable is updated. */
 557:../FreeRTOS/Sources/tasks.c **** 		#if( portUSING_MPU_WRAPPERS == 1 )
 558:../FreeRTOS/Sources/tasks.c **** 		{
 559:../FreeRTOS/Sources/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPriv
 560:../FreeRTOS/Sources/tasks.c **** 		}
 561:../FreeRTOS/Sources/tasks.c **** 		#else /* portUSING_MPU_WRAPPERS */
 562:../FreeRTOS/Sources/tasks.c **** 		{
 563:../FreeRTOS/Sources/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 236              		.loc 1 563 0
 237 0076 7869     		ldr	r0, [r7, #20]
 238 0078 F968     		ldr	r1, [r7, #12]
 239 007a 3A68     		ldr	r2, [r7, #0]
 240 007c FFF7FEFF 		bl	pxPortInitialiseStack
 241 0080 0246     		mov	r2, r0
 242 0082 BB69     		ldr	r3, [r7, #24]
 243 0084 1A60     		str	r2, [r3, #0]
 564:../FreeRTOS/Sources/tasks.c **** 		}
 565:../FreeRTOS/Sources/tasks.c **** 		#endif /* portUSING_MPU_WRAPPERS */
 566:../FreeRTOS/Sources/tasks.c **** 
 567:../FreeRTOS/Sources/tasks.c **** 		/* Check the alignment of the initialised stack. */
 568:../FreeRTOS/Sources/tasks.c **** 		portALIGNMENT_ASSERT_pxCurrentTCB( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long
 244              		.loc 1 568 0
 245 0086 BB69     		ldr	r3, [r7, #24]
 246 0088 1B68     		ldr	r3, [r3, #0]
 247 008a 03F00703 		and	r3, r3, #7
 248 008e 002B     		cmp	r3, #0
 249 0090 02D0     		beq	.L9
 250              		.loc 1 568 0 is_stmt 0 discriminator 1
 251 0092 FFF7FEFF 		bl	ulPortSetInterruptMask
 252              	.L10:
 253              		.loc 1 568 0 discriminator 2
 254 0096 FEE7     		b	.L10
 255              	.L9:
 569:../FreeRTOS/Sources/tasks.c **** 
 570:../FreeRTOS/Sources/tasks.c **** 		if( ( void * ) pxCreatedTask != NULL )
 256              		.loc 1 570 0 is_stmt 1
 257 0098 FB6A     		ldr	r3, [r7, #44]
 258 009a 002B     		cmp	r3, #0
 259 009c 02D0     		beq	.L11
 571:../FreeRTOS/Sources/tasks.c **** 		{
 572:../FreeRTOS/Sources/tasks.c **** 			/* Pass the TCB out - in an anonymous way.  The calling function/
 573:../FreeRTOS/Sources/tasks.c **** 			task can use this as a handle to delete the task later if
 574:../FreeRTOS/Sources/tasks.c **** 			required.*/
 575:../FreeRTOS/Sources/tasks.c **** 			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
 260              		.loc 1 575 0
 261 009e FB6A     		ldr	r3, [r7, #44]
 262 00a0 BA69     		ldr	r2, [r7, #24]
 263 00a2 1A60     		str	r2, [r3, #0]
 264              	.L11:
 576:../FreeRTOS/Sources/tasks.c **** 		}
 577:../FreeRTOS/Sources/tasks.c **** 
 578:../FreeRTOS/Sources/tasks.c **** 		/* We are going to manipulate the task queues to add this task to a
 579:../FreeRTOS/Sources/tasks.c **** 		ready list, so must make sure no interrupts occur. */
 580:../FreeRTOS/Sources/tasks.c **** 		taskENTER_CRITICAL();
 265              		.loc 1 580 0
 266 00a4 FFF7FEFF 		bl	vPortEnterCritical
 581:../FreeRTOS/Sources/tasks.c **** 		{
 582:../FreeRTOS/Sources/tasks.c **** 			uxCurrentNumberOfTasks++;
 267              		.loc 1 582 0
 268 00a8 40F20003 		movw	r3, #:lower16:uxCurrentNumberOfTasks
 269 00ac C0F20003 		movt	r3, #:upper16:uxCurrentNumberOfTasks
 270 00b0 1B68     		ldr	r3, [r3, #0]
 271 00b2 03F10102 		add	r2, r3, #1
 272 00b6 40F20003 		movw	r3, #:lower16:uxCurrentNumberOfTasks
 273 00ba C0F20003 		movt	r3, #:upper16:uxCurrentNumberOfTasks
 274 00be 1A60     		str	r2, [r3, #0]
 583:../FreeRTOS/Sources/tasks.c **** 			if( pxCurrentTCB == NULL )
 275              		.loc 1 583 0
 276 00c0 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 277 00c4 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 278 00c8 1B68     		ldr	r3, [r3, #0]
 279 00ca 002B     		cmp	r3, #0
 280 00cc 0FD1     		bne	.L12
 584:../FreeRTOS/Sources/tasks.c **** 			{
 585:../FreeRTOS/Sources/tasks.c **** 				/* There are no other tasks, or all the other tasks are in
 586:../FreeRTOS/Sources/tasks.c **** 				the suspended state - make this the current task. */
 587:../FreeRTOS/Sources/tasks.c **** 				pxCurrentTCB =  pxNewTCB;
 281              		.loc 1 587 0
 282 00ce 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 283 00d2 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 284 00d6 BA69     		ldr	r2, [r7, #24]
 285 00d8 1A60     		str	r2, [r3, #0]
 588:../FreeRTOS/Sources/tasks.c **** 
 589:../FreeRTOS/Sources/tasks.c **** 				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
 286              		.loc 1 589 0
 287 00da 40F20003 		movw	r3, #:lower16:uxCurrentNumberOfTasks
 288 00de C0F20003 		movt	r3, #:upper16:uxCurrentNumberOfTasks
 289 00e2 1B68     		ldr	r3, [r3, #0]
 290 00e4 012B     		cmp	r3, #1
 291 00e6 18D1     		bne	.L13
 590:../FreeRTOS/Sources/tasks.c **** 				{
 591:../FreeRTOS/Sources/tasks.c **** 					/* This is the first task to be created so do the preliminary
 592:../FreeRTOS/Sources/tasks.c **** 					initialisation required.  We will not recover if this call
 593:../FreeRTOS/Sources/tasks.c **** 					fails, but we will report the failure. */
 594:../FreeRTOS/Sources/tasks.c **** 					prvInitialiseTaskLists();
 292              		.loc 1 594 0
 293 00e8 FFF7FEFF 		bl	prvInitialiseTaskLists
 294 00ec 15E0     		b	.L13
 295              	.L12:
 595:../FreeRTOS/Sources/tasks.c **** 				}
 596:../FreeRTOS/Sources/tasks.c **** 			}
 597:../FreeRTOS/Sources/tasks.c **** 			else
 598:../FreeRTOS/Sources/tasks.c **** 			{
 599:../FreeRTOS/Sources/tasks.c **** 				/* If the scheduler is not already running, make this task the
 600:../FreeRTOS/Sources/tasks.c **** 				current task if it is the highest priority task to be created
 601:../FreeRTOS/Sources/tasks.c **** 				so far. */
 602:../FreeRTOS/Sources/tasks.c **** 				if( xSchedulerRunning == pdFALSE )
 296              		.loc 1 602 0
 297 00ee 40F20003 		movw	r3, #:lower16:xSchedulerRunning
 298 00f2 C0F20003 		movt	r3, #:upper16:xSchedulerRunning
 299 00f6 1B68     		ldr	r3, [r3, #0]
 300 00f8 002B     		cmp	r3, #0
 301 00fa 0ED1     		bne	.L13
 603:../FreeRTOS/Sources/tasks.c **** 				{
 604:../FreeRTOS/Sources/tasks.c **** 					if( pxCurrentTCB->uxPriority <= uxPriority )
 302              		.loc 1 604 0
 303 00fc 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 304 0100 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 305 0104 1B68     		ldr	r3, [r3, #0]
 306 0106 DA6A     		ldr	r2, [r3, #44]
 307 0108 BB6A     		ldr	r3, [r7, #40]
 308 010a 9A42     		cmp	r2, r3
 309 010c 05D8     		bhi	.L13
 605:../FreeRTOS/Sources/tasks.c **** 					{
 606:../FreeRTOS/Sources/tasks.c **** 						pxCurrentTCB = pxNewTCB;
 310              		.loc 1 606 0
 311 010e 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 312 0112 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 313 0116 BA69     		ldr	r2, [r7, #24]
 314 0118 1A60     		str	r2, [r3, #0]
 315              	.L13:
 607:../FreeRTOS/Sources/tasks.c **** 					}
 608:../FreeRTOS/Sources/tasks.c **** 				}
 609:../FreeRTOS/Sources/tasks.c **** 			}
 610:../FreeRTOS/Sources/tasks.c **** 
 611:../FreeRTOS/Sources/tasks.c **** 			/* Remember the top priority to make context switching faster.  Use
 612:../FreeRTOS/Sources/tasks.c **** 			the priority in pxNewTCB as this has been capped to a valid value. */
 613:../FreeRTOS/Sources/tasks.c **** 			if( pxNewTCB->uxPriority > uxTopUsedPriority )
 316              		.loc 1 613 0
 317 011a BB69     		ldr	r3, [r7, #24]
 318 011c DA6A     		ldr	r2, [r3, #44]
 319 011e 40F20003 		movw	r3, #:lower16:uxTopUsedPriority
 320 0122 C0F20003 		movt	r3, #:upper16:uxTopUsedPriority
 321 0126 1B68     		ldr	r3, [r3, #0]
 322 0128 9A42     		cmp	r2, r3
 323 012a 06D9     		bls	.L14
 614:../FreeRTOS/Sources/tasks.c **** 			{
 615:../FreeRTOS/Sources/tasks.c **** 				uxTopUsedPriority = pxNewTCB->uxPriority;
 324              		.loc 1 615 0
 325 012c BB69     		ldr	r3, [r7, #24]
 326 012e DA6A     		ldr	r2, [r3, #44]
 327 0130 40F20003 		movw	r3, #:lower16:uxTopUsedPriority
 328 0134 C0F20003 		movt	r3, #:upper16:uxTopUsedPriority
 329 0138 1A60     		str	r2, [r3, #0]
 330              	.L14:
 616:../FreeRTOS/Sources/tasks.c **** 			}
 617:../FreeRTOS/Sources/tasks.c **** 
 618:../FreeRTOS/Sources/tasks.c **** 			uxTaskNumber++;
 331              		.loc 1 618 0
 332 013a 40F20003 		movw	r3, #:lower16:uxTaskNumber
 333 013e C0F20003 		movt	r3, #:upper16:uxTaskNumber
 334 0142 1B68     		ldr	r3, [r3, #0]
 335 0144 03F10102 		add	r2, r3, #1
 336 0148 40F20003 		movw	r3, #:lower16:uxTaskNumber
 337 014c C0F20003 		movt	r3, #:upper16:uxTaskNumber
 338 0150 1A60     		str	r2, [r3, #0]
 619:../FreeRTOS/Sources/tasks.c **** 
 620:../FreeRTOS/Sources/tasks.c **** 			#if ( configUSE_TRACE_FACILITY == 1 )
 621:../FreeRTOS/Sources/tasks.c **** 			{
 622:../FreeRTOS/Sources/tasks.c **** 				/* Add a counter into the TCB for tracing only. */
 623:../FreeRTOS/Sources/tasks.c **** 				pxNewTCB->uxTCBNumber = uxTaskNumber;
 624:../FreeRTOS/Sources/tasks.c **** 			}
 625:../FreeRTOS/Sources/tasks.c **** 			#endif /* configUSE_TRACE_FACILITY */
 626:../FreeRTOS/Sources/tasks.c **** 			traceTASK_CREATE( pxNewTCB );
 627:../FreeRTOS/Sources/tasks.c **** 
 628:../FreeRTOS/Sources/tasks.c **** 			prvAddTaskToReadyQueue( pxNewTCB );
 339              		.loc 1 628 0
 340 0152 BB69     		ldr	r3, [r7, #24]
 341 0154 DA6A     		ldr	r2, [r3, #44]
 342 0156 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 343 015a C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 344 015e 1B68     		ldr	r3, [r3, #0]
 345 0160 9A42     		cmp	r2, r3
 346 0162 06D9     		bls	.L15
 347              		.loc 1 628 0 is_stmt 0 discriminator 1
 348 0164 BB69     		ldr	r3, [r7, #24]
 349 0166 DA6A     		ldr	r2, [r3, #44]
 350 0168 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 351 016c C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 352 0170 1A60     		str	r2, [r3, #0]
 353              	.L15:
 354              		.loc 1 628 0 discriminator 2
 355 0172 BB69     		ldr	r3, [r7, #24]
 356 0174 DA6A     		ldr	r2, [r3, #44]
 357 0176 1346     		mov	r3, r2
 358 0178 4FEA8303 		lsl	r3, r3, #2
 359 017c 9B18     		adds	r3, r3, r2
 360 017e 4FEA8303 		lsl	r3, r3, #2
 361 0182 40F20002 		movw	r2, #:lower16:pxReadyTasksLists
 362 0186 C0F20002 		movt	r2, #:upper16:pxReadyTasksLists
 363 018a 9A18     		adds	r2, r3, r2
 364 018c BB69     		ldr	r3, [r7, #24]
 365 018e 03F10403 		add	r3, r3, #4
 366 0192 1046     		mov	r0, r2
 367 0194 1946     		mov	r1, r3
 368 0196 FFF7FEFF 		bl	vListInsertEnd
 629:../FreeRTOS/Sources/tasks.c **** 
 630:../FreeRTOS/Sources/tasks.c **** 			xReturn = pdPASS;
 369              		.loc 1 630 0 is_stmt 1 discriminator 2
 370 019a 4FF00103 		mov	r3, #1
 371 019e FB61     		str	r3, [r7, #28]
 631:../FreeRTOS/Sources/tasks.c **** 			portSETUP_TCB( pxNewTCB );
 632:../FreeRTOS/Sources/tasks.c **** 		}
 633:../FreeRTOS/Sources/tasks.c **** 		taskEXIT_CRITICAL();
 372              		.loc 1 633 0 discriminator 2
 373 01a0 FFF7FEFF 		bl	vPortExitCritical
 374 01a4 02E0     		b	.L16
 375              	.L6:
 376              	.LBE2:
 634:../FreeRTOS/Sources/tasks.c **** 	}
 635:../FreeRTOS/Sources/tasks.c **** 	else
 636:../FreeRTOS/Sources/tasks.c **** 	{
 637:../FreeRTOS/Sources/tasks.c **** 		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 377              		.loc 1 637 0
 378 01a6 4FF0FF33 		mov	r3, #-1
 379 01aa FB61     		str	r3, [r7, #28]
 380              	.L16:
 638:../FreeRTOS/Sources/tasks.c **** 		traceTASK_CREATE_FAILED();
 639:../FreeRTOS/Sources/tasks.c **** 	}
 640:../FreeRTOS/Sources/tasks.c **** 
 641:../FreeRTOS/Sources/tasks.c **** 	if( xReturn == pdPASS )
 381              		.loc 1 641 0
 382 01ac FB69     		ldr	r3, [r7, #28]
 383 01ae 012B     		cmp	r3, #1
 384 01b0 11D1     		bne	.L17
 642:../FreeRTOS/Sources/tasks.c **** 	{
 643:../FreeRTOS/Sources/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 385              		.loc 1 643 0
 386 01b2 40F20003 		movw	r3, #:lower16:xSchedulerRunning
 387 01b6 C0F20003 		movt	r3, #:upper16:xSchedulerRunning
 388 01ba 1B68     		ldr	r3, [r3, #0]
 389 01bc 002B     		cmp	r3, #0
 390 01be 0AD0     		beq	.L17
 644:../FreeRTOS/Sources/tasks.c **** 		{
 645:../FreeRTOS/Sources/tasks.c **** 			/* If the created task is of a higher priority than the current task
 646:../FreeRTOS/Sources/tasks.c **** 			then it should run now. */
 647:../FreeRTOS/Sources/tasks.c **** 			if( pxCurrentTCB->uxPriority < uxPriority )
 391              		.loc 1 647 0
 392 01c0 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 393 01c4 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 394 01c8 1B68     		ldr	r3, [r3, #0]
 395 01ca DA6A     		ldr	r2, [r3, #44]
 396 01cc BB6A     		ldr	r3, [r7, #40]
 397 01ce 9A42     		cmp	r2, r3
 398 01d0 01D2     		bcs	.L17
 648:../FreeRTOS/Sources/tasks.c **** 			{
 649:../FreeRTOS/Sources/tasks.c **** 				portYIELD_WITHIN_API();
 399              		.loc 1 649 0
 400 01d2 FFF7FEFF 		bl	vPortYieldFromISR
 401              	.L17:
 650:../FreeRTOS/Sources/tasks.c **** 			}
 651:../FreeRTOS/Sources/tasks.c **** 		}
 652:../FreeRTOS/Sources/tasks.c **** 	}
 653:../FreeRTOS/Sources/tasks.c **** 
 654:../FreeRTOS/Sources/tasks.c **** 	return xReturn;
 402              		.loc 1 654 0
 403 01d6 FB69     		ldr	r3, [r7, #28]
 655:../FreeRTOS/Sources/tasks.c **** }
 404              		.loc 1 655 0
 405 01d8 1846     		mov	r0, r3
 406 01da 07F12007 		add	r7, r7, #32
 407 01de BD46     		mov	sp, r7
 408 01e0 80BD     		pop	{r7, pc}
 409              		.cfi_endproc
 410              	.LFE0:
 412 01e2 00BF     		.section	.text.vTaskDelete,"ax",%progbits
 413              		.align	2
 414              		.global	vTaskDelete
 415              		.thumb
 416              		.thumb_func
 418              	vTaskDelete:
 419              	.LFB1:
 656:../FreeRTOS/Sources/tasks.c **** /*-----------------------------------------------------------*/
 657:../FreeRTOS/Sources/tasks.c **** 
 658:../FreeRTOS/Sources/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 659:../FreeRTOS/Sources/tasks.c **** 
 660:../FreeRTOS/Sources/tasks.c **** 	void vTaskDelete( xTaskHandle xTaskToDelete )
 661:../FreeRTOS/Sources/tasks.c **** 	{
 420              		.loc 1 661 0
 421              		.cfi_startproc
 422              		@ args = 0, pretend = 0, frame = 16
 423              		@ frame_needed = 1, uses_anonymous_args = 0
 424 0000 80B5     		push	{r7, lr}
 425              	.LCFI3:
 426              		.cfi_def_cfa_offset 8
 427              		.cfi_offset 7, -8
 428              		.cfi_offset 14, -4
 429 0002 84B0     		sub	sp, sp, #16
 430              	.LCFI4:
 431              		.cfi_def_cfa_offset 24
 432 0004 00AF     		add	r7, sp, #0
 433              	.LCFI5:
 434              		.cfi_def_cfa_register 7
 435 0006 7860     		str	r0, [r7, #4]
 662:../FreeRTOS/Sources/tasks.c **** 	tskTCB *pxTCB;
 663:../FreeRTOS/Sources/tasks.c **** 
 664:../FreeRTOS/Sources/tasks.c **** 		taskENTER_CRITICAL();
 436              		.loc 1 664 0
 437 0008 FFF7FEFF 		bl	vPortEnterCritical
 665:../FreeRTOS/Sources/tasks.c **** 		{
 666:../FreeRTOS/Sources/tasks.c **** 			/* Ensure a yield is performed if the current task is being
 667:../FreeRTOS/Sources/tasks.c **** 			deleted. */
 668:../FreeRTOS/Sources/tasks.c **** 			if( xTaskToDelete == pxCurrentTCB )
 438              		.loc 1 668 0
 439 000c 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 440 0010 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 441 0014 1B68     		ldr	r3, [r3, #0]
 442 0016 7A68     		ldr	r2, [r7, #4]
 443 0018 9A42     		cmp	r2, r3
 444 001a 02D1     		bne	.L20
 669:../FreeRTOS/Sources/tasks.c **** 			{
 670:../FreeRTOS/Sources/tasks.c **** 				xTaskToDelete = NULL;
 445              		.loc 1 670 0
 446 001c 4FF00003 		mov	r3, #0
 447 0020 7B60     		str	r3, [r7, #4]
 448              	.L20:
 671:../FreeRTOS/Sources/tasks.c **** 			}
 672:../FreeRTOS/Sources/tasks.c **** 
 673:../FreeRTOS/Sources/tasks.c **** 			/* If null is passed in here then we are deleting ourselves. */
 674:../FreeRTOS/Sources/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 449              		.loc 1 674 0
 450 0022 7B68     		ldr	r3, [r7, #4]
 451 0024 002B     		cmp	r3, #0
 452 0026 05D1     		bne	.L21
 453              		.loc 1 674 0 is_stmt 0 discriminator 1
 454 0028 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 455 002c C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 456 0030 1B68     		ldr	r3, [r3, #0]
 457 0032 00E0     		b	.L22
 458              	.L21:
 459              		.loc 1 674 0 discriminator 2
 460 0034 7B68     		ldr	r3, [r7, #4]
 461              	.L22:
 462              		.loc 1 674 0 discriminator 3
 463 0036 FB60     		str	r3, [r7, #12]
 675:../FreeRTOS/Sources/tasks.c **** 
 676:../FreeRTOS/Sources/tasks.c **** 			/* Remove task from the ready list and place in the	termination list.
 677:../FreeRTOS/Sources/tasks.c **** 			This will stop the task from be scheduled.  The idle task will check
 678:../FreeRTOS/Sources/tasks.c **** 			the termination list and free up any memory allocated by the
 679:../FreeRTOS/Sources/tasks.c **** 			scheduler for the TCB and stack. */
 680:../FreeRTOS/Sources/tasks.c **** 			if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
 464              		.loc 1 680 0 is_stmt 1 discriminator 3
 465 0038 FB68     		ldr	r3, [r7, #12]
 466 003a 03F10403 		add	r3, r3, #4
 467 003e 1846     		mov	r0, r3
 468 0040 FFF7FEFF 		bl	uxListRemove
 681:../FreeRTOS/Sources/tasks.c **** 			{
 682:../FreeRTOS/Sources/tasks.c **** 				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 683:../FreeRTOS/Sources/tasks.c **** 			}
 684:../FreeRTOS/Sources/tasks.c **** 
 685:../FreeRTOS/Sources/tasks.c **** 			/* Is the task waiting on an event also? */
 686:../FreeRTOS/Sources/tasks.c **** 			if( pxTCB->xEventListItem.pvContainer != NULL )
 469              		.loc 1 686 0 discriminator 3
 470 0044 FB68     		ldr	r3, [r7, #12]
 471 0046 9B6A     		ldr	r3, [r3, #40]
 472 0048 002B     		cmp	r3, #0
 473 004a 05D0     		beq	.L23
 687:../FreeRTOS/Sources/tasks.c **** 			{
 688:../FreeRTOS/Sources/tasks.c **** 				uxListRemove( &( pxTCB->xEventListItem ) );
 474              		.loc 1 688 0
 475 004c FB68     		ldr	r3, [r7, #12]
 476 004e 03F11803 		add	r3, r3, #24
 477 0052 1846     		mov	r0, r3
 478 0054 FFF7FEFF 		bl	uxListRemove
 479              	.L23:
 689:../FreeRTOS/Sources/tasks.c **** 			}
 690:../FreeRTOS/Sources/tasks.c **** 
 691:../FreeRTOS/Sources/tasks.c **** 			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
 480              		.loc 1 691 0
 481 0058 FB68     		ldr	r3, [r7, #12]
 482 005a 03F10403 		add	r3, r3, #4
 483 005e 40F20000 		movw	r0, #:lower16:xTasksWaitingTermination
 484 0062 C0F20000 		movt	r0, #:upper16:xTasksWaitingTermination
 485 0066 1946     		mov	r1, r3
 486 0068 FFF7FEFF 		bl	vListInsertEnd
 692:../FreeRTOS/Sources/tasks.c **** 
 693:../FreeRTOS/Sources/tasks.c **** 			/* Increment the ucTasksDeleted variable so the idle task knows
 694:../FreeRTOS/Sources/tasks.c **** 			there is a task that has been deleted and that it should therefore
 695:../FreeRTOS/Sources/tasks.c **** 			check the xTasksWaitingTermination list. */
 696:../FreeRTOS/Sources/tasks.c **** 			++uxTasksDeleted;
 487              		.loc 1 696 0
 488 006c 40F20003 		movw	r3, #:lower16:uxTasksDeleted
 489 0070 C0F20003 		movt	r3, #:upper16:uxTasksDeleted
 490 0074 1B68     		ldr	r3, [r3, #0]
 491 0076 03F10102 		add	r2, r3, #1
 492 007a 40F20003 		movw	r3, #:lower16:uxTasksDeleted
 493 007e C0F20003 		movt	r3, #:upper16:uxTasksDeleted
 494 0082 1A60     		str	r2, [r3, #0]
 697:../FreeRTOS/Sources/tasks.c **** 
 698:../FreeRTOS/Sources/tasks.c **** 			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
 699:../FreeRTOS/Sources/tasks.c **** 			can detect that the task lists need re-generating. */
 700:../FreeRTOS/Sources/tasks.c **** 			uxTaskNumber++;
 495              		.loc 1 700 0
 496 0084 40F20003 		movw	r3, #:lower16:uxTaskNumber
 497 0088 C0F20003 		movt	r3, #:upper16:uxTaskNumber
 498 008c 1B68     		ldr	r3, [r3, #0]
 499 008e 03F10102 		add	r2, r3, #1
 500 0092 40F20003 		movw	r3, #:lower16:uxTaskNumber
 501 0096 C0F20003 		movt	r3, #:upper16:uxTaskNumber
 502 009a 1A60     		str	r2, [r3, #0]
 701:../FreeRTOS/Sources/tasks.c **** 
 702:../FreeRTOS/Sources/tasks.c **** 			traceTASK_DELETE( pxTCB );
 703:../FreeRTOS/Sources/tasks.c **** 		}
 704:../FreeRTOS/Sources/tasks.c **** 		taskEXIT_CRITICAL();
 503              		.loc 1 704 0
 504 009c FFF7FEFF 		bl	vPortExitCritical
 705:../FreeRTOS/Sources/tasks.c **** 
 706:../FreeRTOS/Sources/tasks.c **** 		/* Force a reschedule if we have just deleted the current task. */
 707:../FreeRTOS/Sources/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 505              		.loc 1 707 0
 506 00a0 40F20003 		movw	r3, #:lower16:xSchedulerRunning
 507 00a4 C0F20003 		movt	r3, #:upper16:xSchedulerRunning
 508 00a8 1B68     		ldr	r3, [r3, #0]
 509 00aa 002B     		cmp	r3, #0
 510 00ac 04D0     		beq	.L19
 708:../FreeRTOS/Sources/tasks.c **** 		{
 709:../FreeRTOS/Sources/tasks.c **** 			if( ( void * ) xTaskToDelete == NULL )
 511              		.loc 1 709 0
 512 00ae 7B68     		ldr	r3, [r7, #4]
 513 00b0 002B     		cmp	r3, #0
 514 00b2 01D1     		bne	.L19
 710:../FreeRTOS/Sources/tasks.c **** 			{
 711:../FreeRTOS/Sources/tasks.c **** 				portYIELD_WITHIN_API();
 515              		.loc 1 711 0
 516 00b4 FFF7FEFF 		bl	vPortYieldFromISR
 517              	.L19:
 712:../FreeRTOS/Sources/tasks.c **** 			}
 713:../FreeRTOS/Sources/tasks.c **** 		}
 714:../FreeRTOS/Sources/tasks.c **** 	}
 518              		.loc 1 714 0
 519 00b8 07F11007 		add	r7, r7, #16
 520 00bc BD46     		mov	sp, r7
 521 00be 80BD     		pop	{r7, pc}
 522              		.cfi_endproc
 523              	.LFE1:
 525              		.section	.text.vTaskDelayUntil,"ax",%progbits
 526              		.align	2
 527              		.global	vTaskDelayUntil
 528              		.thumb
 529              		.thumb_func
 531              	vTaskDelayUntil:
 532              	.LFB2:
 715:../FreeRTOS/Sources/tasks.c **** 
 716:../FreeRTOS/Sources/tasks.c **** #endif /* INCLUDE_vTaskDelete */
 717:../FreeRTOS/Sources/tasks.c **** /*-----------------------------------------------------------*/
 718:../FreeRTOS/Sources/tasks.c **** 
 719:../FreeRTOS/Sources/tasks.c **** #if ( INCLUDE_vTaskDelayUntil == 1 )
 720:../FreeRTOS/Sources/tasks.c **** 
 721:../FreeRTOS/Sources/tasks.c **** 	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
 722:../FreeRTOS/Sources/tasks.c **** 	{
 533              		.loc 1 722 0
 534              		.cfi_startproc
 535              		@ args = 0, pretend = 0, frame = 24
 536              		@ frame_needed = 1, uses_anonymous_args = 0
 537 0000 80B5     		push	{r7, lr}
 538              	.LCFI6:
 539              		.cfi_def_cfa_offset 8
 540              		.cfi_offset 7, -8
 541              		.cfi_offset 14, -4
 542 0002 86B0     		sub	sp, sp, #24
 543              	.LCFI7:
 544              		.cfi_def_cfa_offset 32
 545 0004 00AF     		add	r7, sp, #0
 546              	.LCFI8:
 547              		.cfi_def_cfa_register 7
 548 0006 7860     		str	r0, [r7, #4]
 549 0008 3960     		str	r1, [r7, #0]
 723:../FreeRTOS/Sources/tasks.c **** 	portTickType xTimeToWake;
 724:../FreeRTOS/Sources/tasks.c **** 	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
 550              		.loc 1 724 0
 551 000a 4FF00003 		mov	r3, #0
 552 000e 7B61     		str	r3, [r7, #20]
 725:../FreeRTOS/Sources/tasks.c **** 
 726:../FreeRTOS/Sources/tasks.c **** 		configASSERT( pxPreviousWakeTime );
 553              		.loc 1 726 0
 554 0010 7B68     		ldr	r3, [r7, #4]
 555 0012 002B     		cmp	r3, #0
 556 0014 02D1     		bne	.L26
 557              		.loc 1 726 0 is_stmt 0 discriminator 1
 558 0016 FFF7FEFF 		bl	ulPortSetInterruptMask
 559              	.L27:
 560              		.loc 1 726 0 discriminator 2
 561 001a FEE7     		b	.L27
 562              	.L26:
 727:../FreeRTOS/Sources/tasks.c **** 		configASSERT( ( xTimeIncrement > 0U ) );
 563              		.loc 1 727 0 is_stmt 1
 564 001c 3B68     		ldr	r3, [r7, #0]
 565 001e 002B     		cmp	r3, #0
 566 0020 02D1     		bne	.L28
 567              		.loc 1 727 0 is_stmt 0 discriminator 1
 568 0022 FFF7FEFF 		bl	ulPortSetInterruptMask
 569              	.L29:
 570              		.loc 1 727 0 discriminator 2
 571 0026 FEE7     		b	.L29
 572              	.L28:
 728:../FreeRTOS/Sources/tasks.c **** 
 729:../FreeRTOS/Sources/tasks.c **** 		vTaskSuspendAll();
 573              		.loc 1 729 0 is_stmt 1
 574 0028 FFF7FEFF 		bl	vTaskSuspendAll
 730:../FreeRTOS/Sources/tasks.c **** 		{
 731:../FreeRTOS/Sources/tasks.c **** 			/* Generate the tick time at which the task wants to wake. */
 732:../FreeRTOS/Sources/tasks.c **** 			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 575              		.loc 1 732 0
 576 002c 7B68     		ldr	r3, [r7, #4]
 577 002e 1A68     		ldr	r2, [r3, #0]
 578 0030 3B68     		ldr	r3, [r7, #0]
 579 0032 D318     		adds	r3, r2, r3
 580 0034 3B61     		str	r3, [r7, #16]
 733:../FreeRTOS/Sources/tasks.c **** 
 734:../FreeRTOS/Sources/tasks.c **** 			if( xTickCount < *pxPreviousWakeTime )
 581              		.loc 1 734 0
 582 0036 7B68     		ldr	r3, [r7, #4]
 583 0038 1A68     		ldr	r2, [r3, #0]
 584 003a 40F20003 		movw	r3, #:lower16:xTickCount
 585 003e C0F20003 		movt	r3, #:upper16:xTickCount
 586 0042 1B68     		ldr	r3, [r3, #0]
 587 0044 9A42     		cmp	r2, r3
 588 0046 10D9     		bls	.L30
 735:../FreeRTOS/Sources/tasks.c **** 			{
 736:../FreeRTOS/Sources/tasks.c **** 				/* The tick count has overflowed since this function was
 737:../FreeRTOS/Sources/tasks.c **** 				lasted called.  In this case the only time we should ever
 738:../FreeRTOS/Sources/tasks.c **** 				actually delay is if the wake time has also	overflowed,
 739:../FreeRTOS/Sources/tasks.c **** 				and the wake time is greater than the tick time.  When this
 740:../FreeRTOS/Sources/tasks.c **** 				is the case it is as if neither time had overflowed. */
 741:../FreeRTOS/Sources/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
 589              		.loc 1 741 0
 590 0048 7B68     		ldr	r3, [r7, #4]
 591 004a 1A68     		ldr	r2, [r3, #0]
 592 004c 3B69     		ldr	r3, [r7, #16]
 593 004e 9A42     		cmp	r2, r3
 594 0050 1BD9     		bls	.L31
 595              		.loc 1 741 0 is_stmt 0 discriminator 1
 596 0052 40F20003 		movw	r3, #:lower16:xTickCount
 597 0056 C0F20003 		movt	r3, #:upper16:xTickCount
 598 005a 1B68     		ldr	r3, [r3, #0]
 599 005c 3A69     		ldr	r2, [r7, #16]
 600 005e 9A42     		cmp	r2, r3
 601 0060 13D9     		bls	.L31
 742:../FreeRTOS/Sources/tasks.c **** 				{
 743:../FreeRTOS/Sources/tasks.c **** 					xShouldDelay = pdTRUE;
 602              		.loc 1 743 0 is_stmt 1
 603 0062 4FF00103 		mov	r3, #1
 604 0066 7B61     		str	r3, [r7, #20]
 605 0068 0FE0     		b	.L31
 606              	.L30:
 744:../FreeRTOS/Sources/tasks.c **** 				}
 745:../FreeRTOS/Sources/tasks.c **** 			}
 746:../FreeRTOS/Sources/tasks.c **** 			else
 747:../FreeRTOS/Sources/tasks.c **** 			{
 748:../FreeRTOS/Sources/tasks.c **** 				/* The tick time has not overflowed.  In this case we will
 749:../FreeRTOS/Sources/tasks.c **** 				delay if either the wake time has overflowed, and/or the
 750:../FreeRTOS/Sources/tasks.c **** 				tick time is less than the wake time. */
 751:../FreeRTOS/Sources/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
 607              		.loc 1 751 0
 608 006a 7B68     		ldr	r3, [r7, #4]
 609 006c 1A68     		ldr	r2, [r3, #0]
 610 006e 3B69     		ldr	r3, [r7, #16]
 611 0070 9A42     		cmp	r2, r3
 612 0072 07D8     		bhi	.L32
 613              		.loc 1 751 0 is_stmt 0 discriminator 1
 614 0074 40F20003 		movw	r3, #:lower16:xTickCount
 615 0078 C0F20003 		movt	r3, #:upper16:xTickCount
 616 007c 1B68     		ldr	r3, [r3, #0]
 617 007e 3A69     		ldr	r2, [r7, #16]
 618 0080 9A42     		cmp	r2, r3
 619 0082 02D9     		bls	.L31
 620              	.L32:
 752:../FreeRTOS/Sources/tasks.c **** 				{
 753:../FreeRTOS/Sources/tasks.c **** 					xShouldDelay = pdTRUE;
 621              		.loc 1 753 0 is_stmt 1
 622 0084 4FF00103 		mov	r3, #1
 623 0088 7B61     		str	r3, [r7, #20]
 624              	.L31:
 754:../FreeRTOS/Sources/tasks.c **** 				}
 755:../FreeRTOS/Sources/tasks.c **** 			}
 756:../FreeRTOS/Sources/tasks.c **** 
 757:../FreeRTOS/Sources/tasks.c **** 			/* Update the wake time ready for the next call. */
 758:../FreeRTOS/Sources/tasks.c **** 			*pxPreviousWakeTime = xTimeToWake;
 625              		.loc 1 758 0
 626 008a 7B68     		ldr	r3, [r7, #4]
 627 008c 3A69     		ldr	r2, [r7, #16]
 628 008e 1A60     		str	r2, [r3, #0]
 759:../FreeRTOS/Sources/tasks.c **** 
 760:../FreeRTOS/Sources/tasks.c **** 			if( xShouldDelay != pdFALSE )
 629              		.loc 1 760 0
 630 0090 7B69     		ldr	r3, [r7, #20]
 631 0092 002B     		cmp	r3, #0
 632 0094 0CD0     		beq	.L33
 761:../FreeRTOS/Sources/tasks.c **** 			{
 762:../FreeRTOS/Sources/tasks.c **** 				traceTASK_DELAY_UNTIL();
 763:../FreeRTOS/Sources/tasks.c **** 
 764:../FreeRTOS/Sources/tasks.c **** 				/* We must remove ourselves from the ready list before adding
 765:../FreeRTOS/Sources/tasks.c **** 				ourselves to the blocked list as the same list item is used for
 766:../FreeRTOS/Sources/tasks.c **** 				both lists. */
 767:../FreeRTOS/Sources/tasks.c **** 				if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
 633              		.loc 1 767 0
 634 0096 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 635 009a C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 636 009e 1B68     		ldr	r3, [r3, #0]
 637 00a0 03F10403 		add	r3, r3, #4
 638 00a4 1846     		mov	r0, r3
 639 00a6 FFF7FEFF 		bl	uxListRemove
 768:../FreeRTOS/Sources/tasks.c **** 				{
 769:../FreeRTOS/Sources/tasks.c **** 					/* The current task must be in a ready list, so there is
 770:../FreeRTOS/Sources/tasks.c **** 					no need to check, and the port reset macro can be called
 771:../FreeRTOS/Sources/tasks.c **** 					directly. */
 772:../FreeRTOS/Sources/tasks.c **** 					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
 773:../FreeRTOS/Sources/tasks.c **** 				}
 774:../FreeRTOS/Sources/tasks.c **** 
 775:../FreeRTOS/Sources/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake );
 640              		.loc 1 775 0
 641 00aa 3869     		ldr	r0, [r7, #16]
 642 00ac FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
 643              	.L33:
 776:../FreeRTOS/Sources/tasks.c **** 			}
 777:../FreeRTOS/Sources/tasks.c **** 		}
 778:../FreeRTOS/Sources/tasks.c **** 		xAlreadyYielded = xTaskResumeAll();
 644              		.loc 1 778 0
 645 00b0 FFF7FEFF 		bl	xTaskResumeAll
 646 00b4 F860     		str	r0, [r7, #12]
 779:../FreeRTOS/Sources/tasks.c **** 
 780:../FreeRTOS/Sources/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
 781:../FreeRTOS/Sources/tasks.c **** 		have put ourselves to sleep. */
 782:../FreeRTOS/Sources/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
 647              		.loc 1 782 0
 648 00b6 FB68     		ldr	r3, [r7, #12]
 649 00b8 002B     		cmp	r3, #0
 650 00ba 01D1     		bne	.L25
 783:../FreeRTOS/Sources/tasks.c **** 		{
 784:../FreeRTOS/Sources/tasks.c **** 			portYIELD_WITHIN_API();
 651              		.loc 1 784 0
 652 00bc FFF7FEFF 		bl	vPortYieldFromISR
 653              	.L25:
 785:../FreeRTOS/Sources/tasks.c **** 		}
 786:../FreeRTOS/Sources/tasks.c **** 	}
 654              		.loc 1 786 0
 655 00c0 07F11807 		add	r7, r7, #24
 656 00c4 BD46     		mov	sp, r7
 657 00c6 80BD     		pop	{r7, pc}
 658              		.cfi_endproc
 659              	.LFE2:
 661              		.section	.text.vTaskDelay,"ax",%progbits
 662              		.align	2
 663              		.global	vTaskDelay
 664              		.thumb
 665              		.thumb_func
 667              	vTaskDelay:
 668              	.LFB3:
 787:../FreeRTOS/Sources/tasks.c **** 
 788:../FreeRTOS/Sources/tasks.c **** #endif /* INCLUDE_vTaskDelayUntil */
 789:../FreeRTOS/Sources/tasks.c **** /*-----------------------------------------------------------*/
 790:../FreeRTOS/Sources/tasks.c **** 
 791:../FreeRTOS/Sources/tasks.c **** #if ( INCLUDE_vTaskDelay == 1 )
 792:../FreeRTOS/Sources/tasks.c **** 
 793:../FreeRTOS/Sources/tasks.c **** 	void vTaskDelay( portTickType xTicksToDelay )
 794:../FreeRTOS/Sources/tasks.c **** 	{
 669              		.loc 1 794 0
 670              		.cfi_startproc
 671              		@ args = 0, pretend = 0, frame = 16
 672              		@ frame_needed = 1, uses_anonymous_args = 0
 673 0000 80B5     		push	{r7, lr}
 674              	.LCFI9:
 675              		.cfi_def_cfa_offset 8
 676              		.cfi_offset 7, -8
 677              		.cfi_offset 14, -4
 678 0002 84B0     		sub	sp, sp, #16
 679              	.LCFI10:
 680              		.cfi_def_cfa_offset 24
 681 0004 00AF     		add	r7, sp, #0
 682              	.LCFI11:
 683              		.cfi_def_cfa_register 7
 684 0006 7860     		str	r0, [r7, #4]
 795:../FreeRTOS/Sources/tasks.c **** 	portTickType xTimeToWake;
 796:../FreeRTOS/Sources/tasks.c **** 	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
 685              		.loc 1 796 0
 686 0008 4FF00003 		mov	r3, #0
 687 000c FB60     		str	r3, [r7, #12]
 797:../FreeRTOS/Sources/tasks.c **** 
 798:../FreeRTOS/Sources/tasks.c **** 		/* A delay time of zero just forces a reschedule. */
 799:../FreeRTOS/Sources/tasks.c **** 		if( xTicksToDelay > ( portTickType ) 0U )
 688              		.loc 1 799 0
 689 000e 7B68     		ldr	r3, [r7, #4]
 690 0010 002B     		cmp	r3, #0
 691 0012 19D0     		beq	.L36
 800:../FreeRTOS/Sources/tasks.c **** 		{
 801:../FreeRTOS/Sources/tasks.c **** 			vTaskSuspendAll();
 692              		.loc 1 801 0
 693 0014 FFF7FEFF 		bl	vTaskSuspendAll
 802:../FreeRTOS/Sources/tasks.c **** 			{
 803:../FreeRTOS/Sources/tasks.c **** 				traceTASK_DELAY();
 804:../FreeRTOS/Sources/tasks.c **** 
 805:../FreeRTOS/Sources/tasks.c **** 				/* A task that is removed from the event list while the
 806:../FreeRTOS/Sources/tasks.c **** 				scheduler is suspended will not get placed in the ready
 807:../FreeRTOS/Sources/tasks.c **** 				list or removed from the blocked list until the scheduler
 808:../FreeRTOS/Sources/tasks.c **** 				is resumed.
 809:../FreeRTOS/Sources/tasks.c **** 
 810:../FreeRTOS/Sources/tasks.c **** 				This task cannot be in an event list as it is the currently
 811:../FreeRTOS/Sources/tasks.c **** 				executing task. */
 812:../FreeRTOS/Sources/tasks.c **** 
 813:../FreeRTOS/Sources/tasks.c **** 				/* Calculate the time to wake - this may overflow but this is
 814:../FreeRTOS/Sources/tasks.c **** 				not a problem. */
 815:../FreeRTOS/Sources/tasks.c **** 				xTimeToWake = xTickCount + xTicksToDelay;
 694              		.loc 1 815 0
 695 0018 40F20003 		movw	r3, #:lower16:xTickCount
 696 001c C0F20003 		movt	r3, #:upper16:xTickCount
 697 0020 1A68     		ldr	r2, [r3, #0]
 698 0022 7B68     		ldr	r3, [r7, #4]
 699 0024 D318     		adds	r3, r2, r3
 700 0026 BB60     		str	r3, [r7, #8]
 816:../FreeRTOS/Sources/tasks.c **** 
 817:../FreeRTOS/Sources/tasks.c **** 				/* We must remove ourselves from the ready list before adding
 818:../FreeRTOS/Sources/tasks.c **** 				ourselves to the blocked list as the same list item is used for
 819:../FreeRTOS/Sources/tasks.c **** 				both lists. */
 820:../FreeRTOS/Sources/tasks.c **** 				if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
 701              		.loc 1 820 0
 702 0028 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 703 002c C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 704 0030 1B68     		ldr	r3, [r3, #0]
 705 0032 03F10403 		add	r3, r3, #4
 706 0036 1846     		mov	r0, r3
 707 0038 FFF7FEFF 		bl	uxListRemove
 821:../FreeRTOS/Sources/tasks.c **** 				{
 822:../FreeRTOS/Sources/tasks.c **** 					/* The current task must be in a ready list, so there is
 823:../FreeRTOS/Sources/tasks.c **** 					no need to check, and the port reset macro can be called
 824:../FreeRTOS/Sources/tasks.c **** 					directly. */
 825:../FreeRTOS/Sources/tasks.c **** 					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
 826:../FreeRTOS/Sources/tasks.c **** 				}
 827:../FreeRTOS/Sources/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake );
 708              		.loc 1 827 0
 709 003c B868     		ldr	r0, [r7, #8]
 710 003e FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
 828:../FreeRTOS/Sources/tasks.c **** 			}
 829:../FreeRTOS/Sources/tasks.c **** 			xAlreadyYielded = xTaskResumeAll();
 711              		.loc 1 829 0
 712 0042 FFF7FEFF 		bl	xTaskResumeAll
 713 0046 F860     		str	r0, [r7, #12]
 714              	.L36:
 830:../FreeRTOS/Sources/tasks.c **** 		}
 831:../FreeRTOS/Sources/tasks.c **** 
 832:../FreeRTOS/Sources/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
 833:../FreeRTOS/Sources/tasks.c **** 		have put ourselves to sleep. */
 834:../FreeRTOS/Sources/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
 715              		.loc 1 834 0
 716 0048 FB68     		ldr	r3, [r7, #12]
 717 004a 002B     		cmp	r3, #0
 718 004c 01D1     		bne	.L35
 835:../FreeRTOS/Sources/tasks.c **** 		{
 836:../FreeRTOS/Sources/tasks.c **** 			portYIELD_WITHIN_API();
 719              		.loc 1 836 0
 720 004e FFF7FEFF 		bl	vPortYieldFromISR
 721              	.L35:
 837:../FreeRTOS/Sources/tasks.c **** 		}
 838:../FreeRTOS/Sources/tasks.c **** 	}
 722              		.loc 1 838 0
 723 0052 07F11007 		add	r7, r7, #16
 724 0056 BD46     		mov	sp, r7
 725 0058 80BD     		pop	{r7, pc}
 726              		.cfi_endproc
 727              	.LFE3:
 729 005a 00BF     		.section	.text.uxTaskPriorityGet,"ax",%progbits
 730              		.align	2
 731              		.global	uxTaskPriorityGet
 732              		.thumb
 733              		.thumb_func
 735              	uxTaskPriorityGet:
 736              	.LFB4:
 839:../FreeRTOS/Sources/tasks.c **** 
 840:../FreeRTOS/Sources/tasks.c **** #endif /* INCLUDE_vTaskDelay */
 841:../FreeRTOS/Sources/tasks.c **** /*-----------------------------------------------------------*/
 842:../FreeRTOS/Sources/tasks.c **** 
 843:../FreeRTOS/Sources/tasks.c **** #if ( INCLUDE_eTaskGetState == 1 )
 844:../FreeRTOS/Sources/tasks.c **** 
 845:../FreeRTOS/Sources/tasks.c **** 	eTaskState eTaskGetState( xTaskHandle xTask )
 846:../FreeRTOS/Sources/tasks.c **** 	{
 847:../FreeRTOS/Sources/tasks.c **** 	eTaskState eReturn;
 848:../FreeRTOS/Sources/tasks.c **** 	xList *pxStateList;
 849:../FreeRTOS/Sources/tasks.c **** 	tskTCB *pxTCB;
 850:../FreeRTOS/Sources/tasks.c **** 
 851:../FreeRTOS/Sources/tasks.c **** 		pxTCB = ( tskTCB * ) xTask;
 852:../FreeRTOS/Sources/tasks.c **** 
 853:../FreeRTOS/Sources/tasks.c **** 		if( pxTCB == pxCurrentTCB )
 854:../FreeRTOS/Sources/tasks.c **** 		{
 855:../FreeRTOS/Sources/tasks.c **** 			/* The task calling this function is querying its own state. */
 856:../FreeRTOS/Sources/tasks.c **** 			eReturn = eRunning;
 857:../FreeRTOS/Sources/tasks.c **** 		}
 858:../FreeRTOS/Sources/tasks.c **** 		else
 859:../FreeRTOS/Sources/tasks.c **** 		{
 860:../FreeRTOS/Sources/tasks.c **** 			taskENTER_CRITICAL();
 861:../FreeRTOS/Sources/tasks.c **** 			{
 862:../FreeRTOS/Sources/tasks.c **** 				pxStateList = ( xList * ) listLIST_ITEM_CONTAINER( &( pxTCB->xGenericListItem ) );
 863:../FreeRTOS/Sources/tasks.c **** 			}
 864:../FreeRTOS/Sources/tasks.c **** 			taskEXIT_CRITICAL();
 865:../FreeRTOS/Sources/tasks.c **** 
 866:../FreeRTOS/Sources/tasks.c **** 			if( ( pxStateList == pxDelayedTaskList ) || ( pxStateList == pxOverflowDelayedTaskList ) )
 867:../FreeRTOS/Sources/tasks.c **** 			{
 868:../FreeRTOS/Sources/tasks.c **** 				/* The task being queried is referenced from one of the Blocked
 869:../FreeRTOS/Sources/tasks.c **** 				lists. */
 870:../FreeRTOS/Sources/tasks.c **** 				eReturn = eBlocked;
 871:../FreeRTOS/Sources/tasks.c **** 			}
 872:../FreeRTOS/Sources/tasks.c **** 
 873:../FreeRTOS/Sources/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
 874:../FreeRTOS/Sources/tasks.c **** 				else if( pxStateList == &xSuspendedTaskList )
 875:../FreeRTOS/Sources/tasks.c **** 				{
 876:../FreeRTOS/Sources/tasks.c **** 					/* The task being queried is referenced from the suspended
 877:../FreeRTOS/Sources/tasks.c **** 					list. */
 878:../FreeRTOS/Sources/tasks.c **** 					eReturn = eSuspended;
 879:../FreeRTOS/Sources/tasks.c **** 				}
 880:../FreeRTOS/Sources/tasks.c **** 			#endif
 881:../FreeRTOS/Sources/tasks.c **** 
 882:../FreeRTOS/Sources/tasks.c **** 			#if ( INCLUDE_vTaskDelete == 1 )
 883:../FreeRTOS/Sources/tasks.c **** 				else if( pxStateList == &xTasksWaitingTermination )
 884:../FreeRTOS/Sources/tasks.c **** 				{
 885:../FreeRTOS/Sources/tasks.c **** 					/* The task being queried is referenced from the deleted
 886:../FreeRTOS/Sources/tasks.c **** 					tasks list. */
 887:../FreeRTOS/Sources/tasks.c **** 					eReturn = eDeleted;
 888:../FreeRTOS/Sources/tasks.c **** 				}
 889:../FreeRTOS/Sources/tasks.c **** 			#endif
 890:../FreeRTOS/Sources/tasks.c **** 
 891:../FreeRTOS/Sources/tasks.c **** 			else
 892:../FreeRTOS/Sources/tasks.c **** 			{
 893:../FreeRTOS/Sources/tasks.c **** 				/* If the task is not in any other state, it must be in the
 894:../FreeRTOS/Sources/tasks.c **** 				Ready (including pending ready) state. */
 895:../FreeRTOS/Sources/tasks.c **** 				eReturn = eReady;
 896:../FreeRTOS/Sources/tasks.c **** 			}
 897:../FreeRTOS/Sources/tasks.c **** 		}
 898:../FreeRTOS/Sources/tasks.c **** 
 899:../FreeRTOS/Sources/tasks.c **** 		return eReturn;
 900:../FreeRTOS/Sources/tasks.c **** 	}
 901:../FreeRTOS/Sources/tasks.c **** 
 902:../FreeRTOS/Sources/tasks.c **** #endif /* INCLUDE_eTaskGetState */
 903:../FreeRTOS/Sources/tasks.c **** /*-----------------------------------------------------------*/
 904:../FreeRTOS/Sources/tasks.c **** 
 905:../FreeRTOS/Sources/tasks.c **** #if ( INCLUDE_uxTaskPriorityGet == 1 )
 906:../FreeRTOS/Sources/tasks.c **** 
 907:../FreeRTOS/Sources/tasks.c **** 	unsigned portBASE_TYPE uxTaskPriorityGet( xTaskHandle xTask )
 908:../FreeRTOS/Sources/tasks.c **** 	{
 737              		.loc 1 908 0
 738              		.cfi_startproc
 739              		@ args = 0, pretend = 0, frame = 16
 740              		@ frame_needed = 1, uses_anonymous_args = 0
 741 0000 80B5     		push	{r7, lr}
 742              	.LCFI12:
 743              		.cfi_def_cfa_offset 8
 744              		.cfi_offset 7, -8
 745              		.cfi_offset 14, -4
 746 0002 84B0     		sub	sp, sp, #16
 747              	.LCFI13:
 748              		.cfi_def_cfa_offset 24
 749 0004 00AF     		add	r7, sp, #0
 750              	.LCFI14:
 751              		.cfi_def_cfa_register 7
 752 0006 7860     		str	r0, [r7, #4]
 909:../FreeRTOS/Sources/tasks.c **** 	tskTCB *pxTCB;
 910:../FreeRTOS/Sources/tasks.c **** 	unsigned portBASE_TYPE uxReturn;
 911:../FreeRTOS/Sources/tasks.c **** 
 912:../FreeRTOS/Sources/tasks.c **** 		taskENTER_CRITICAL();
 753              		.loc 1 912 0
 754 0008 FFF7FEFF 		bl	vPortEnterCritical
 913:../FreeRTOS/Sources/tasks.c **** 		{
 914:../FreeRTOS/Sources/tasks.c **** 			/* If null is passed in here then we are changing the
 915:../FreeRTOS/Sources/tasks.c **** 			priority of the calling function. */
 916:../FreeRTOS/Sources/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTask );
 755              		.loc 1 916 0
 756 000c 7B68     		ldr	r3, [r7, #4]
 757 000e 002B     		cmp	r3, #0
 758 0010 05D1     		bne	.L39
 759              		.loc 1 916 0 is_stmt 0 discriminator 1
 760 0012 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 761 0016 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 762 001a 1B68     		ldr	r3, [r3, #0]
 763 001c 00E0     		b	.L40
 764              	.L39:
 765              		.loc 1 916 0 discriminator 2
 766 001e 7B68     		ldr	r3, [r7, #4]
 767              	.L40:
 768              		.loc 1 916 0 discriminator 3
 769 0020 FB60     		str	r3, [r7, #12]
 917:../FreeRTOS/Sources/tasks.c **** 			uxReturn = pxTCB->uxPriority;
 770              		.loc 1 917 0 is_stmt 1 discriminator 3
 771 0022 FB68     		ldr	r3, [r7, #12]
 772 0024 DB6A     		ldr	r3, [r3, #44]
 773 0026 BB60     		str	r3, [r7, #8]
 918:../FreeRTOS/Sources/tasks.c **** 		}
 919:../FreeRTOS/Sources/tasks.c **** 		taskEXIT_CRITICAL();
 774              		.loc 1 919 0 discriminator 3
 775 0028 FFF7FEFF 		bl	vPortExitCritical
 920:../FreeRTOS/Sources/tasks.c **** 
 921:../FreeRTOS/Sources/tasks.c **** 		return uxReturn;
 776              		.loc 1 921 0 discriminator 3
 777 002c BB68     		ldr	r3, [r7, #8]
 922:../FreeRTOS/Sources/tasks.c **** 	}
 778              		.loc 1 922 0 discriminator 3
 779 002e 1846     		mov	r0, r3
 780 0030 07F11007 		add	r7, r7, #16
 781 0034 BD46     		mov	sp, r7
 782 0036 80BD     		pop	{r7, pc}
 783              		.cfi_endproc
 784              	.LFE4:
 786              		.section	.text.vTaskPrioritySet,"ax",%progbits
 787              		.align	2
 788              		.global	vTaskPrioritySet
 789              		.thumb
 790              		.thumb_func
 792              	vTaskPrioritySet:
 793              	.LFB5:
 923:../FreeRTOS/Sources/tasks.c **** 
 924:../FreeRTOS/Sources/tasks.c **** #endif /* INCLUDE_uxTaskPriorityGet */
 925:../FreeRTOS/Sources/tasks.c **** /*-----------------------------------------------------------*/
 926:../FreeRTOS/Sources/tasks.c **** 
 927:../FreeRTOS/Sources/tasks.c **** #if ( INCLUDE_vTaskPrioritySet == 1 )
 928:../FreeRTOS/Sources/tasks.c **** 
 929:../FreeRTOS/Sources/tasks.c **** 	void vTaskPrioritySet( xTaskHandle xTask, unsigned portBASE_TYPE uxNewPriority )
 930:../FreeRTOS/Sources/tasks.c **** 	{
 794              		.loc 1 930 0
 795              		.cfi_startproc
 796              		@ args = 0, pretend = 0, frame = 24
 797              		@ frame_needed = 1, uses_anonymous_args = 0
 798 0000 80B5     		push	{r7, lr}
 799              	.LCFI15:
 800              		.cfi_def_cfa_offset 8
 801              		.cfi_offset 7, -8
 802              		.cfi_offset 14, -4
 803 0002 86B0     		sub	sp, sp, #24
 804              	.LCFI16:
 805              		.cfi_def_cfa_offset 32
 806 0004 00AF     		add	r7, sp, #0
 807              	.LCFI17:
 808              		.cfi_def_cfa_register 7
 809 0006 7860     		str	r0, [r7, #4]
 810 0008 3960     		str	r1, [r7, #0]
 931:../FreeRTOS/Sources/tasks.c **** 	tskTCB *pxTCB;
 932:../FreeRTOS/Sources/tasks.c **** 	unsigned portBASE_TYPE uxCurrentPriority, uxPriorityUsedOnEntry;
 933:../FreeRTOS/Sources/tasks.c **** 	portBASE_TYPE xYieldRequired = pdFALSE;
 811              		.loc 1 933 0
 812 000a 4FF00003 		mov	r3, #0
 813 000e 7B61     		str	r3, [r7, #20]
 934:../FreeRTOS/Sources/tasks.c **** 
 935:../FreeRTOS/Sources/tasks.c **** 		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
 814              		.loc 1 935 0
 815 0010 3B68     		ldr	r3, [r7, #0]
 816 0012 042B     		cmp	r3, #4
 817 0014 02D9     		bls	.L43
 818              		.loc 1 935 0 is_stmt 0 discriminator 1
 819 0016 FFF7FEFF 		bl	ulPortSetInterruptMask
 820              	.L44:
 821              		.loc 1 935 0 discriminator 2
 822 001a FEE7     		b	.L44
 823              	.L43:
 936:../FreeRTOS/Sources/tasks.c **** 
 937:../FreeRTOS/Sources/tasks.c **** 		/* Ensure the new priority is valid. */
 938:../FreeRTOS/Sources/tasks.c **** 		if( uxNewPriority >= configMAX_PRIORITIES )
 824              		.loc 1 938 0 is_stmt 1
 825 001c 3B68     		ldr	r3, [r7, #0]
 826 001e 042B     		cmp	r3, #4
 827 0020 02D9     		bls	.L45
 939:../FreeRTOS/Sources/tasks.c **** 		{
 940:../FreeRTOS/Sources/tasks.c **** 			uxNewPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
 828              		.loc 1 940 0
 829 0022 4FF00403 		mov	r3, #4
 830 0026 3B60     		str	r3, [r7, #0]
 831              	.L45:
 941:../FreeRTOS/Sources/tasks.c **** 		}
 942:../FreeRTOS/Sources/tasks.c **** 
 943:../FreeRTOS/Sources/tasks.c **** 		taskENTER_CRITICAL();
 832              		.loc 1 943 0
 833 0028 FFF7FEFF 		bl	vPortEnterCritical
 944:../FreeRTOS/Sources/tasks.c **** 		{
 945:../FreeRTOS/Sources/tasks.c **** 			if( xTask == ( xTaskHandle ) pxCurrentTCB )
 834              		.loc 1 945 0
 835 002c 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 836 0030 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 837 0034 1B68     		ldr	r3, [r3, #0]
 838 0036 7A68     		ldr	r2, [r7, #4]
 839 0038 9A42     		cmp	r2, r3
 840 003a 02D1     		bne	.L46
 946:../FreeRTOS/Sources/tasks.c **** 			{
 947:../FreeRTOS/Sources/tasks.c **** 				xTask = NULL;
 841              		.loc 1 947 0
 842 003c 4FF00003 		mov	r3, #0
 843 0040 7B60     		str	r3, [r7, #4]
 844              	.L46:
 948:../FreeRTOS/Sources/tasks.c **** 			}
 949:../FreeRTOS/Sources/tasks.c **** 
 950:../FreeRTOS/Sources/tasks.c **** 			/* If null is passed in here then we are changing the
 951:../FreeRTOS/Sources/tasks.c **** 			priority of the calling function. */
 952:../FreeRTOS/Sources/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTask );
 845              		.loc 1 952 0
 846 0042 7B68     		ldr	r3, [r7, #4]
 847 0044 002B     		cmp	r3, #0
 848 0046 05D1     		bne	.L47
 849              		.loc 1 952 0 is_stmt 0 discriminator 1
 850 0048 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 851 004c C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 852 0050 1B68     		ldr	r3, [r3, #0]
 853 0052 00E0     		b	.L48
 854              	.L47:
 855              		.loc 1 952 0 discriminator 2
 856 0054 7B68     		ldr	r3, [r7, #4]
 857              	.L48:
 858              		.loc 1 952 0 discriminator 3
 859 0056 3B61     		str	r3, [r7, #16]
 953:../FreeRTOS/Sources/tasks.c **** 
 954:../FreeRTOS/Sources/tasks.c **** 			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
 955:../FreeRTOS/Sources/tasks.c **** 
 956:../FreeRTOS/Sources/tasks.c **** 			#if ( configUSE_MUTEXES == 1 )
 957:../FreeRTOS/Sources/tasks.c **** 			{
 958:../FreeRTOS/Sources/tasks.c **** 				uxCurrentPriority = pxTCB->uxBasePriority;
 860              		.loc 1 958 0 is_stmt 1 discriminator 3
 861 0058 3B69     		ldr	r3, [r7, #16]
 862 005a 1B6C     		ldr	r3, [r3, #64]
 863 005c FB60     		str	r3, [r7, #12]
 959:../FreeRTOS/Sources/tasks.c **** 			}
 960:../FreeRTOS/Sources/tasks.c **** 			#else
 961:../FreeRTOS/Sources/tasks.c **** 			{
 962:../FreeRTOS/Sources/tasks.c **** 				uxCurrentPriority = pxTCB->uxPriority;
 963:../FreeRTOS/Sources/tasks.c **** 			}
 964:../FreeRTOS/Sources/tasks.c **** 			#endif
 965:../FreeRTOS/Sources/tasks.c **** 
 966:../FreeRTOS/Sources/tasks.c **** 			if( uxCurrentPriority != uxNewPriority )
 864              		.loc 1 966 0 discriminator 3
 865 005e FA68     		ldr	r2, [r7, #12]
 866 0060 3B68     		ldr	r3, [r7, #0]
 867 0062 9A42     		cmp	r2, r3
 868 0064 63D0     		beq	.L49
 967:../FreeRTOS/Sources/tasks.c **** 			{
 968:../FreeRTOS/Sources/tasks.c **** 				/* The priority change may have readied a task of higher
 969:../FreeRTOS/Sources/tasks.c **** 				priority than the calling task. */
 970:../FreeRTOS/Sources/tasks.c **** 				if( uxNewPriority > uxCurrentPriority )
 869              		.loc 1 970 0
 870 0066 3A68     		ldr	r2, [r7, #0]
 871 0068 FB68     		ldr	r3, [r7, #12]
 872 006a 9A42     		cmp	r2, r3
 873 006c 06D9     		bls	.L50
 971:../FreeRTOS/Sources/tasks.c **** 				{
 972:../FreeRTOS/Sources/tasks.c **** 					if( xTask != NULL )
 874              		.loc 1 972 0
 875 006e 7B68     		ldr	r3, [r7, #4]
 876 0070 002B     		cmp	r3, #0
 877 0072 09D0     		beq	.L51
 973:../FreeRTOS/Sources/tasks.c **** 					{
 974:../FreeRTOS/Sources/tasks.c **** 						/* The priority of another task is being raised.  If we
 975:../FreeRTOS/Sources/tasks.c **** 						were raising the priority of the currently running task
 976:../FreeRTOS/Sources/tasks.c **** 						there would be no need to switch as it must have already
 977:../FreeRTOS/Sources/tasks.c **** 						been the highest priority task. */
 978:../FreeRTOS/Sources/tasks.c **** 						xYieldRequired = pdTRUE;
 878              		.loc 1 978 0
 879 0074 4FF00103 		mov	r3, #1
 880 0078 7B61     		str	r3, [r7, #20]
 881 007a 05E0     		b	.L51
 882              	.L50:
 979:../FreeRTOS/Sources/tasks.c **** 					}
 980:../FreeRTOS/Sources/tasks.c **** 				}
 981:../FreeRTOS/Sources/tasks.c **** 				else if( xTask == NULL )
 883              		.loc 1 981 0
 884 007c 7B68     		ldr	r3, [r7, #4]
 885 007e 002B     		cmp	r3, #0
 886 0080 02D1     		bne	.L51
 982:../FreeRTOS/Sources/tasks.c **** 				{
 983:../FreeRTOS/Sources/tasks.c **** 					/* Setting our own priority down means there may now be another
 984:../FreeRTOS/Sources/tasks.c **** 					task of higher priority that is ready to execute. */
 985:../FreeRTOS/Sources/tasks.c **** 					xYieldRequired = pdTRUE;
 887              		.loc 1 985 0
 888 0082 4FF00103 		mov	r3, #1
 889 0086 7B61     		str	r3, [r7, #20]
 890              	.L51:
 986:../FreeRTOS/Sources/tasks.c **** 				}
 987:../FreeRTOS/Sources/tasks.c **** 
 988:../FreeRTOS/Sources/tasks.c **** 				/* Remember the ready list the task might be referenced from
 989:../FreeRTOS/Sources/tasks.c **** 				before its uxPriority member is changed so the
 990:../FreeRTOS/Sources/tasks.c **** 				taskRESET_READY_PRIORITY() macro can function correctly. */
 991:../FreeRTOS/Sources/tasks.c **** 				uxPriorityUsedOnEntry = pxTCB->uxPriority;
 891              		.loc 1 991 0
 892 0088 3B69     		ldr	r3, [r7, #16]
 893 008a DB6A     		ldr	r3, [r3, #44]
 894 008c BB60     		str	r3, [r7, #8]
 992:../FreeRTOS/Sources/tasks.c **** 
 993:../FreeRTOS/Sources/tasks.c **** 				#if ( configUSE_MUTEXES == 1 )
 994:../FreeRTOS/Sources/tasks.c **** 				{
 995:../FreeRTOS/Sources/tasks.c **** 					/* Only change the priority being used if the task is not
 996:../FreeRTOS/Sources/tasks.c **** 					currently using an inherited priority. */
 997:../FreeRTOS/Sources/tasks.c **** 					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
 895              		.loc 1 997 0
 896 008e 3B69     		ldr	r3, [r7, #16]
 897 0090 1A6C     		ldr	r2, [r3, #64]
 898 0092 3B69     		ldr	r3, [r7, #16]
 899 0094 DB6A     		ldr	r3, [r3, #44]
 900 0096 9A42     		cmp	r2, r3
 901 0098 02D1     		bne	.L52
 998:../FreeRTOS/Sources/tasks.c **** 					{
 999:../FreeRTOS/Sources/tasks.c **** 						pxTCB->uxPriority = uxNewPriority;
 902              		.loc 1 999 0
 903 009a 3B69     		ldr	r3, [r7, #16]
 904 009c 3A68     		ldr	r2, [r7, #0]
 905 009e DA62     		str	r2, [r3, #44]
 906              	.L52:
1000:../FreeRTOS/Sources/tasks.c **** 					}
1001:../FreeRTOS/Sources/tasks.c **** 
1002:../FreeRTOS/Sources/tasks.c **** 					/* The base priority gets set whatever. */
1003:../FreeRTOS/Sources/tasks.c **** 					pxTCB->uxBasePriority = uxNewPriority;
 907              		.loc 1 1003 0
 908 00a0 3B69     		ldr	r3, [r7, #16]
 909 00a2 3A68     		ldr	r2, [r7, #0]
 910 00a4 1A64     		str	r2, [r3, #64]
1004:../FreeRTOS/Sources/tasks.c **** 				}
1005:../FreeRTOS/Sources/tasks.c **** 				#else
1006:../FreeRTOS/Sources/tasks.c **** 				{
1007:../FreeRTOS/Sources/tasks.c **** 					pxTCB->uxPriority = uxNewPriority;
1008:../FreeRTOS/Sources/tasks.c **** 				}
1009:../FreeRTOS/Sources/tasks.c **** 				#endif
1010:../FreeRTOS/Sources/tasks.c **** 
1011:../FreeRTOS/Sources/tasks.c **** 				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( configMAX_PRIORITIES - ( portTickType ) 
 911              		.loc 1 1011 0
 912 00a6 3B68     		ldr	r3, [r7, #0]
 913 00a8 C3F10502 		rsb	r2, r3, #5
 914 00ac 3B69     		ldr	r3, [r7, #16]
 915 00ae 9A61     		str	r2, [r3, #24]
1012:../FreeRTOS/Sources/tasks.c **** 
1013:../FreeRTOS/Sources/tasks.c **** 				/* If the task is in the blocked or suspended list we need do
1014:../FreeRTOS/Sources/tasks.c **** 				nothing more than change it's priority variable. However, if
1015:../FreeRTOS/Sources/tasks.c **** 				the task is in a ready list it needs to be removed and placed
1016:../FreeRTOS/Sources/tasks.c **** 				in the queue appropriate to its new priority. */
1017:../FreeRTOS/Sources/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxCurrentPriority ] ), &( pxTCB->xGenericLis
 916              		.loc 1 1017 0
 917 00b0 3B69     		ldr	r3, [r7, #16]
 918 00b2 5969     		ldr	r1, [r3, #20]
 919 00b4 FA68     		ldr	r2, [r7, #12]
 920 00b6 1346     		mov	r3, r2
 921 00b8 4FEA8303 		lsl	r3, r3, #2
 922 00bc 9B18     		adds	r3, r3, r2
 923 00be 4FEA8303 		lsl	r3, r3, #2
 924 00c2 40F20002 		movw	r2, #:lower16:pxReadyTasksLists
 925 00c6 C0F20002 		movt	r2, #:upper16:pxReadyTasksLists
 926 00ca 9B18     		adds	r3, r3, r2
 927 00cc 9942     		cmp	r1, r3
 928 00ce 29D1     		bne	.L53
1018:../FreeRTOS/Sources/tasks.c **** 				{
1019:../FreeRTOS/Sources/tasks.c **** 					/* The task is currently in its ready list - remove before adding
1020:../FreeRTOS/Sources/tasks.c **** 					it to it's new ready list.  As we are in a critical section we
1021:../FreeRTOS/Sources/tasks.c **** 					can do this even if the scheduler is suspended. */
1022:../FreeRTOS/Sources/tasks.c **** 					if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
 929              		.loc 1 1022 0
 930 00d0 3B69     		ldr	r3, [r7, #16]
 931 00d2 03F10403 		add	r3, r3, #4
 932 00d6 1846     		mov	r0, r3
 933 00d8 FFF7FEFF 		bl	uxListRemove
1023:../FreeRTOS/Sources/tasks.c **** 					{
1024:../FreeRTOS/Sources/tasks.c **** 						taskRESET_READY_PRIORITY( uxPriorityUsedOnEntry );
1025:../FreeRTOS/Sources/tasks.c **** 					}
1026:../FreeRTOS/Sources/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 934              		.loc 1 1026 0
 935 00dc 3B69     		ldr	r3, [r7, #16]
 936 00de DA6A     		ldr	r2, [r3, #44]
 937 00e0 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 938 00e4 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 939 00e8 1B68     		ldr	r3, [r3, #0]
 940 00ea 9A42     		cmp	r2, r3
 941 00ec 06D9     		bls	.L54
 942              		.loc 1 1026 0 is_stmt 0 discriminator 1
 943 00ee 3B69     		ldr	r3, [r7, #16]
 944 00f0 DA6A     		ldr	r2, [r3, #44]
 945 00f2 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 946 00f6 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 947 00fa 1A60     		str	r2, [r3, #0]
 948              	.L54:
 949              		.loc 1 1026 0 discriminator 2
 950 00fc 3B69     		ldr	r3, [r7, #16]
 951 00fe DA6A     		ldr	r2, [r3, #44]
 952 0100 1346     		mov	r3, r2
 953 0102 4FEA8303 		lsl	r3, r3, #2
 954 0106 9B18     		adds	r3, r3, r2
 955 0108 4FEA8303 		lsl	r3, r3, #2
 956 010c 40F20002 		movw	r2, #:lower16:pxReadyTasksLists
 957 0110 C0F20002 		movt	r2, #:upper16:pxReadyTasksLists
 958 0114 9A18     		adds	r2, r3, r2
 959 0116 3B69     		ldr	r3, [r7, #16]
 960 0118 03F10403 		add	r3, r3, #4
 961 011c 1046     		mov	r0, r2
 962 011e 1946     		mov	r1, r3
 963 0120 FFF7FEFF 		bl	vListInsertEnd
 964              	.L53:
1027:../FreeRTOS/Sources/tasks.c **** 				}
1028:../FreeRTOS/Sources/tasks.c **** 
1029:../FreeRTOS/Sources/tasks.c **** 				if( xYieldRequired == pdTRUE )
 965              		.loc 1 1029 0 is_stmt 1
 966 0124 7B69     		ldr	r3, [r7, #20]
 967 0126 012B     		cmp	r3, #1
 968 0128 01D1     		bne	.L49
1030:../FreeRTOS/Sources/tasks.c **** 				{
1031:../FreeRTOS/Sources/tasks.c **** 					portYIELD_WITHIN_API();
 969              		.loc 1 1031 0
 970 012a FFF7FEFF 		bl	vPortYieldFromISR
 971              	.L49:
1032:../FreeRTOS/Sources/tasks.c **** 				}
1033:../FreeRTOS/Sources/tasks.c **** 			}
1034:../FreeRTOS/Sources/tasks.c **** 		}
1035:../FreeRTOS/Sources/tasks.c **** 		taskEXIT_CRITICAL();
 972              		.loc 1 1035 0
 973 012e FFF7FEFF 		bl	vPortExitCritical
1036:../FreeRTOS/Sources/tasks.c **** 
1037:../FreeRTOS/Sources/tasks.c **** 		/* Remove compiler warning about unused parameter when the port
1038:../FreeRTOS/Sources/tasks.c **** 		optimised task selection is not being used. */
1039:../FreeRTOS/Sources/tasks.c **** 		( void ) uxPriorityUsedOnEntry;
1040:../FreeRTOS/Sources/tasks.c **** 	}
 974              		.loc 1 1040 0
 975 0132 07F11807 		add	r7, r7, #24
 976 0136 BD46     		mov	sp, r7
 977 0138 80BD     		pop	{r7, pc}
 978              		.cfi_endproc
 979              	.LFE5:
 981 013a 00BF     		.section	.text.vTaskSuspend,"ax",%progbits
 982              		.align	2
 983              		.global	vTaskSuspend
 984              		.thumb
 985              		.thumb_func
 987              	vTaskSuspend:
 988              	.LFB6:
1041:../FreeRTOS/Sources/tasks.c **** 
1042:../FreeRTOS/Sources/tasks.c **** #endif /* INCLUDE_vTaskPrioritySet */
1043:../FreeRTOS/Sources/tasks.c **** /*-----------------------------------------------------------*/
1044:../FreeRTOS/Sources/tasks.c **** 
1045:../FreeRTOS/Sources/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1046:../FreeRTOS/Sources/tasks.c **** 
1047:../FreeRTOS/Sources/tasks.c **** 	void vTaskSuspend( xTaskHandle xTaskToSuspend )
1048:../FreeRTOS/Sources/tasks.c **** 	{
 989              		.loc 1 1048 0
 990              		.cfi_startproc
 991              		@ args = 0, pretend = 0, frame = 16
 992              		@ frame_needed = 1, uses_anonymous_args = 0
 993 0000 80B5     		push	{r7, lr}
 994              	.LCFI18:
 995              		.cfi_def_cfa_offset 8
 996              		.cfi_offset 7, -8
 997              		.cfi_offset 14, -4
 998 0002 84B0     		sub	sp, sp, #16
 999              	.LCFI19:
 1000              		.cfi_def_cfa_offset 24
 1001 0004 00AF     		add	r7, sp, #0
 1002              	.LCFI20:
 1003              		.cfi_def_cfa_register 7
 1004 0006 7860     		str	r0, [r7, #4]
1049:../FreeRTOS/Sources/tasks.c **** 	tskTCB *pxTCB;
1050:../FreeRTOS/Sources/tasks.c **** 
1051:../FreeRTOS/Sources/tasks.c **** 		taskENTER_CRITICAL();
 1005              		.loc 1 1051 0
 1006 0008 FFF7FEFF 		bl	vPortEnterCritical
1052:../FreeRTOS/Sources/tasks.c **** 		{
1053:../FreeRTOS/Sources/tasks.c **** 			/* Ensure a yield is performed if the current task is being
1054:../FreeRTOS/Sources/tasks.c **** 			suspended. */
1055:../FreeRTOS/Sources/tasks.c **** 			if( xTaskToSuspend == ( xTaskHandle ) pxCurrentTCB )
 1007              		.loc 1 1055 0
 1008 000c 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 1009 0010 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 1010 0014 1B68     		ldr	r3, [r3, #0]
 1011 0016 7A68     		ldr	r2, [r7, #4]
 1012 0018 9A42     		cmp	r2, r3
 1013 001a 02D1     		bne	.L56
1056:../FreeRTOS/Sources/tasks.c **** 			{
1057:../FreeRTOS/Sources/tasks.c **** 				xTaskToSuspend = NULL;
 1014              		.loc 1 1057 0
 1015 001c 4FF00003 		mov	r3, #0
 1016 0020 7B60     		str	r3, [r7, #4]
 1017              	.L56:
1058:../FreeRTOS/Sources/tasks.c **** 			}
1059:../FreeRTOS/Sources/tasks.c **** 
1060:../FreeRTOS/Sources/tasks.c **** 			/* If null is passed in here then we are suspending ourselves. */
1061:../FreeRTOS/Sources/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
 1018              		.loc 1 1061 0
 1019 0022 7B68     		ldr	r3, [r7, #4]
 1020 0024 002B     		cmp	r3, #0
 1021 0026 05D1     		bne	.L57
 1022              		.loc 1 1061 0 is_stmt 0 discriminator 1
 1023 0028 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 1024 002c C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 1025 0030 1B68     		ldr	r3, [r3, #0]
 1026 0032 00E0     		b	.L58
 1027              	.L57:
 1028              		.loc 1 1061 0 discriminator 2
 1029 0034 7B68     		ldr	r3, [r7, #4]
 1030              	.L58:
 1031              		.loc 1 1061 0 discriminator 3
 1032 0036 FB60     		str	r3, [r7, #12]
1062:../FreeRTOS/Sources/tasks.c **** 
1063:../FreeRTOS/Sources/tasks.c **** 			traceTASK_SUSPEND( pxTCB );
1064:../FreeRTOS/Sources/tasks.c **** 
1065:../FreeRTOS/Sources/tasks.c **** 			/* Remove task from the ready/delayed list and place in the	suspended list. */
1066:../FreeRTOS/Sources/tasks.c **** 			if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
 1033              		.loc 1 1066 0 is_stmt 1 discriminator 3
 1034 0038 FB68     		ldr	r3, [r7, #12]
 1035 003a 03F10403 		add	r3, r3, #4
 1036 003e 1846     		mov	r0, r3
 1037 0040 FFF7FEFF 		bl	uxListRemove
1067:../FreeRTOS/Sources/tasks.c **** 			{
1068:../FreeRTOS/Sources/tasks.c **** 				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
1069:../FreeRTOS/Sources/tasks.c **** 			}
1070:../FreeRTOS/Sources/tasks.c **** 
1071:../FreeRTOS/Sources/tasks.c **** 			/* Is the task waiting on an event also? */
1072:../FreeRTOS/Sources/tasks.c **** 			if( pxTCB->xEventListItem.pvContainer != NULL )
 1038              		.loc 1 1072 0 discriminator 3
 1039 0044 FB68     		ldr	r3, [r7, #12]
 1040 0046 9B6A     		ldr	r3, [r3, #40]
 1041 0048 002B     		cmp	r3, #0
 1042 004a 05D0     		beq	.L59
1073:../FreeRTOS/Sources/tasks.c **** 			{
1074:../FreeRTOS/Sources/tasks.c **** 				uxListRemove( &( pxTCB->xEventListItem ) );
 1043              		.loc 1 1074 0
 1044 004c FB68     		ldr	r3, [r7, #12]
 1045 004e 03F11803 		add	r3, r3, #24
 1046 0052 1846     		mov	r0, r3
 1047 0054 FFF7FEFF 		bl	uxListRemove
 1048              	.L59:
1075:../FreeRTOS/Sources/tasks.c **** 			}
1076:../FreeRTOS/Sources/tasks.c **** 
1077:../FreeRTOS/Sources/tasks.c **** 			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
 1049              		.loc 1 1077 0
 1050 0058 FB68     		ldr	r3, [r7, #12]
 1051 005a 03F10403 		add	r3, r3, #4
 1052 005e 40F20000 		movw	r0, #:lower16:xSuspendedTaskList
 1053 0062 C0F20000 		movt	r0, #:upper16:xSuspendedTaskList
 1054 0066 1946     		mov	r1, r3
 1055 0068 FFF7FEFF 		bl	vListInsertEnd
1078:../FreeRTOS/Sources/tasks.c **** 		}
1079:../FreeRTOS/Sources/tasks.c **** 		taskEXIT_CRITICAL();
 1056              		.loc 1 1079 0
 1057 006c FFF7FEFF 		bl	vPortExitCritical
1080:../FreeRTOS/Sources/tasks.c **** 
1081:../FreeRTOS/Sources/tasks.c **** 		if( ( void * ) xTaskToSuspend == NULL )
 1058              		.loc 1 1081 0
 1059 0070 7B68     		ldr	r3, [r7, #4]
 1060 0072 002B     		cmp	r3, #0
 1061 0074 1FD1     		bne	.L55
1082:../FreeRTOS/Sources/tasks.c **** 		{
1083:../FreeRTOS/Sources/tasks.c **** 			if( xSchedulerRunning != pdFALSE )
 1062              		.loc 1 1083 0
 1063 0076 40F20003 		movw	r3, #:lower16:xSchedulerRunning
 1064 007a C0F20003 		movt	r3, #:upper16:xSchedulerRunning
 1065 007e 1B68     		ldr	r3, [r3, #0]
 1066 0080 002B     		cmp	r3, #0
 1067 0082 02D0     		beq	.L61
1084:../FreeRTOS/Sources/tasks.c **** 			{
1085:../FreeRTOS/Sources/tasks.c **** 				/* We have just suspended the current task. */
1086:../FreeRTOS/Sources/tasks.c **** 				portYIELD_WITHIN_API();
 1068              		.loc 1 1086 0
 1069 0084 FFF7FEFF 		bl	vPortYieldFromISR
 1070 0088 15E0     		b	.L55
 1071              	.L61:
1087:../FreeRTOS/Sources/tasks.c **** 			}
1088:../FreeRTOS/Sources/tasks.c **** 			else
1089:../FreeRTOS/Sources/tasks.c **** 			{
1090:../FreeRTOS/Sources/tasks.c **** 				/* The scheduler is not running, but the task that was pointed
1091:../FreeRTOS/Sources/tasks.c **** 				to by pxCurrentTCB has just been suspended and pxCurrentTCB
1092:../FreeRTOS/Sources/tasks.c **** 				must be adjusted to point to a different task. */
1093:../FreeRTOS/Sources/tasks.c **** 				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
 1072              		.loc 1 1093 0
 1073 008a 40F20003 		movw	r3, #:lower16:xSuspendedTaskList
 1074 008e C0F20003 		movt	r3, #:upper16:xSuspendedTaskList
 1075 0092 1A68     		ldr	r2, [r3, #0]
 1076 0094 40F20003 		movw	r3, #:lower16:uxCurrentNumberOfTasks
 1077 0098 C0F20003 		movt	r3, #:upper16:uxCurrentNumberOfTasks
 1078 009c 1B68     		ldr	r3, [r3, #0]
 1079 009e 9A42     		cmp	r2, r3
 1080 00a0 07D1     		bne	.L62
1094:../FreeRTOS/Sources/tasks.c **** 				{
1095:../FreeRTOS/Sources/tasks.c **** 					/* No other tasks are ready, so set pxCurrentTCB back to
1096:../FreeRTOS/Sources/tasks.c **** 					NULL so when the next task is created pxCurrentTCB will
1097:../FreeRTOS/Sources/tasks.c **** 					be set to point to it no matter what its relative priority
1098:../FreeRTOS/Sources/tasks.c **** 					is. */
1099:../FreeRTOS/Sources/tasks.c **** 					pxCurrentTCB = NULL;
 1081              		.loc 1 1099 0
 1082 00a2 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 1083 00a6 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 1084 00aa 4FF00002 		mov	r2, #0
 1085 00ae 1A60     		str	r2, [r3, #0]
 1086 00b0 01E0     		b	.L55
 1087              	.L62:
1100:../FreeRTOS/Sources/tasks.c **** 				}
1101:../FreeRTOS/Sources/tasks.c **** 				else
1102:../FreeRTOS/Sources/tasks.c **** 				{
1103:../FreeRTOS/Sources/tasks.c **** 					vTaskSwitchContext();
 1088              		.loc 1 1103 0
 1089 00b2 FFF7FEFF 		bl	vTaskSwitchContext
 1090              	.L55:
1104:../FreeRTOS/Sources/tasks.c **** 				}
1105:../FreeRTOS/Sources/tasks.c **** 			}
1106:../FreeRTOS/Sources/tasks.c **** 		}
1107:../FreeRTOS/Sources/tasks.c **** 	}
 1091              		.loc 1 1107 0
 1092 00b6 07F11007 		add	r7, r7, #16
 1093 00ba BD46     		mov	sp, r7
 1094 00bc 80BD     		pop	{r7, pc}
 1095              		.cfi_endproc
 1096              	.LFE6:
 1098 00be 00BF     		.section	.text.xTaskIsTaskSuspended,"ax",%progbits
 1099              		.align	2
 1100              		.global	xTaskIsTaskSuspended
 1101              		.thumb
 1102              		.thumb_func
 1104              	xTaskIsTaskSuspended:
 1105              	.LFB7:
1108:../FreeRTOS/Sources/tasks.c **** 
1109:../FreeRTOS/Sources/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1110:../FreeRTOS/Sources/tasks.c **** /*-----------------------------------------------------------*/
1111:../FreeRTOS/Sources/tasks.c **** 
1112:../FreeRTOS/Sources/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1113:../FreeRTOS/Sources/tasks.c **** 
1114:../FreeRTOS/Sources/tasks.c **** 	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
1115:../FreeRTOS/Sources/tasks.c **** 	{
 1106              		.loc 1 1115 0
 1107              		.cfi_startproc
 1108              		@ args = 0, pretend = 0, frame = 16
 1109              		@ frame_needed = 1, uses_anonymous_args = 0
 1110 0000 80B5     		push	{r7, lr}
 1111              	.LCFI21:
 1112              		.cfi_def_cfa_offset 8
 1113              		.cfi_offset 7, -8
 1114              		.cfi_offset 14, -4
 1115 0002 84B0     		sub	sp, sp, #16
 1116              	.LCFI22:
 1117              		.cfi_def_cfa_offset 24
 1118 0004 00AF     		add	r7, sp, #0
 1119              	.LCFI23:
 1120              		.cfi_def_cfa_register 7
 1121 0006 7860     		str	r0, [r7, #4]
1116:../FreeRTOS/Sources/tasks.c **** 	portBASE_TYPE xReturn = pdFALSE;
 1122              		.loc 1 1116 0
 1123 0008 4FF00003 		mov	r3, #0
 1124 000c FB60     		str	r3, [r7, #12]
1117:../FreeRTOS/Sources/tasks.c **** 	const tskTCB * const pxTCB = ( tskTCB * ) xTask;
 1125              		.loc 1 1117 0
 1126 000e 7B68     		ldr	r3, [r7, #4]
 1127 0010 BB60     		str	r3, [r7, #8]
1118:../FreeRTOS/Sources/tasks.c **** 
1119:../FreeRTOS/Sources/tasks.c **** 		/* It does not make sense to check if the calling task is suspended. */
1120:../FreeRTOS/Sources/tasks.c **** 		configASSERT( xTask );
 1128              		.loc 1 1120 0
 1129 0012 7B68     		ldr	r3, [r7, #4]
 1130 0014 002B     		cmp	r3, #0
 1131 0016 02D1     		bne	.L64
 1132              		.loc 1 1120 0 is_stmt 0 discriminator 1
 1133 0018 FFF7FEFF 		bl	ulPortSetInterruptMask
 1134              	.L65:
 1135              		.loc 1 1120 0 discriminator 2
 1136 001c FEE7     		b	.L65
 1137              	.L64:
1121:../FreeRTOS/Sources/tasks.c **** 
1122:../FreeRTOS/Sources/tasks.c **** 		/* Is the task we are attempting to resume actually in the
1123:../FreeRTOS/Sources/tasks.c **** 		suspended list? */
1124:../FreeRTOS/Sources/tasks.c **** 		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
 1138              		.loc 1 1124 0 is_stmt 1
 1139 001e BB68     		ldr	r3, [r7, #8]
 1140 0020 5A69     		ldr	r2, [r3, #20]
 1141 0022 40F20003 		movw	r3, #:lower16:xSuspendedTaskList
 1142 0026 C0F20003 		movt	r3, #:upper16:xSuspendedTaskList
 1143 002a 9A42     		cmp	r2, r3
 1144 002c 0ED1     		bne	.L66
1125:../FreeRTOS/Sources/tasks.c **** 		{
1126:../FreeRTOS/Sources/tasks.c **** 			/* Has the task already been resumed from within an ISR? */
1127:../FreeRTOS/Sources/tasks.c **** 			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
 1145              		.loc 1 1127 0
 1146 002e BB68     		ldr	r3, [r7, #8]
 1147 0030 9A6A     		ldr	r2, [r3, #40]
 1148 0032 40F20003 		movw	r3, #:lower16:xPendingReadyList
 1149 0036 C0F20003 		movt	r3, #:upper16:xPendingReadyList
 1150 003a 9A42     		cmp	r2, r3
 1151 003c 06D0     		beq	.L66
1128:../FreeRTOS/Sources/tasks.c **** 			{
1129:../FreeRTOS/Sources/tasks.c **** 				/* Is it in the suspended list because it is in the
1130:../FreeRTOS/Sources/tasks.c **** 				Suspended state?  It is possible to be in the suspended
1131:../FreeRTOS/Sources/tasks.c **** 				list because it is blocked on a task with no timeout
1132:../FreeRTOS/Sources/tasks.c **** 				specified. */
1133:../FreeRTOS/Sources/tasks.c **** 				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) == pdTRUE )
 1152              		.loc 1 1133 0
 1153 003e BB68     		ldr	r3, [r7, #8]
 1154 0040 9B6A     		ldr	r3, [r3, #40]
 1155 0042 002B     		cmp	r3, #0
 1156 0044 02D1     		bne	.L66
1134:../FreeRTOS/Sources/tasks.c **** 				{
1135:../FreeRTOS/Sources/tasks.c **** 					xReturn = pdTRUE;
 1157              		.loc 1 1135 0
 1158 0046 4FF00103 		mov	r3, #1
 1159 004a FB60     		str	r3, [r7, #12]
 1160              	.L66:
1136:../FreeRTOS/Sources/tasks.c **** 				}
1137:../FreeRTOS/Sources/tasks.c **** 			}
1138:../FreeRTOS/Sources/tasks.c **** 		}
1139:../FreeRTOS/Sources/tasks.c **** 
1140:../FreeRTOS/Sources/tasks.c **** 		return xReturn;
 1161              		.loc 1 1140 0
 1162 004c FB68     		ldr	r3, [r7, #12]
1141:../FreeRTOS/Sources/tasks.c **** 	}
 1163              		.loc 1 1141 0
 1164 004e 1846     		mov	r0, r3
 1165 0050 07F11007 		add	r7, r7, #16
 1166 0054 BD46     		mov	sp, r7
 1167 0056 80BD     		pop	{r7, pc}
 1168              		.cfi_endproc
 1169              	.LFE7:
 1171              		.section	.text.vTaskResume,"ax",%progbits
 1172              		.align	2
 1173              		.global	vTaskResume
 1174              		.thumb
 1175              		.thumb_func
 1177              	vTaskResume:
 1178              	.LFB8:
1142:../FreeRTOS/Sources/tasks.c **** 
1143:../FreeRTOS/Sources/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1144:../FreeRTOS/Sources/tasks.c **** /*-----------------------------------------------------------*/
1145:../FreeRTOS/Sources/tasks.c **** 
1146:../FreeRTOS/Sources/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1147:../FreeRTOS/Sources/tasks.c **** 
1148:../FreeRTOS/Sources/tasks.c **** 	void vTaskResume( xTaskHandle xTaskToResume )
1149:../FreeRTOS/Sources/tasks.c **** 	{
 1179              		.loc 1 1149 0
 1180              		.cfi_startproc
 1181              		@ args = 0, pretend = 0, frame = 16
 1182              		@ frame_needed = 1, uses_anonymous_args = 0
 1183 0000 80B5     		push	{r7, lr}
 1184              	.LCFI24:
 1185              		.cfi_def_cfa_offset 8
 1186              		.cfi_offset 7, -8
 1187              		.cfi_offset 14, -4
 1188 0002 84B0     		sub	sp, sp, #16
 1189              	.LCFI25:
 1190              		.cfi_def_cfa_offset 24
 1191 0004 00AF     		add	r7, sp, #0
 1192              	.LCFI26:
 1193              		.cfi_def_cfa_register 7
 1194 0006 7860     		str	r0, [r7, #4]
1150:../FreeRTOS/Sources/tasks.c **** 	tskTCB *pxTCB;
1151:../FreeRTOS/Sources/tasks.c **** 
1152:../FreeRTOS/Sources/tasks.c **** 		/* It does not make sense to resume the calling task. */
1153:../FreeRTOS/Sources/tasks.c **** 		configASSERT( xTaskToResume );
 1195              		.loc 1 1153 0
 1196 0008 7B68     		ldr	r3, [r7, #4]
 1197 000a 002B     		cmp	r3, #0
 1198 000c 02D1     		bne	.L69
 1199              		.loc 1 1153 0 is_stmt 0 discriminator 1
 1200 000e FFF7FEFF 		bl	ulPortSetInterruptMask
 1201              	.L70:
 1202              		.loc 1 1153 0 discriminator 2
 1203 0012 FEE7     		b	.L70
 1204              	.L69:
1154:../FreeRTOS/Sources/tasks.c **** 
1155:../FreeRTOS/Sources/tasks.c **** 		/* Remove the task from whichever list it is currently in, and place
1156:../FreeRTOS/Sources/tasks.c **** 		it in the ready list. */
1157:../FreeRTOS/Sources/tasks.c **** 		pxTCB = ( tskTCB * ) xTaskToResume;
 1205              		.loc 1 1157 0 is_stmt 1
 1206 0014 7B68     		ldr	r3, [r7, #4]
 1207 0016 FB60     		str	r3, [r7, #12]
1158:../FreeRTOS/Sources/tasks.c **** 
1159:../FreeRTOS/Sources/tasks.c **** 		/* The parameter cannot be NULL as it is impossible to resume the
1160:../FreeRTOS/Sources/tasks.c **** 		currently executing task. */
1161:../FreeRTOS/Sources/tasks.c **** 		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
 1208              		.loc 1 1161 0
 1209 0018 FB68     		ldr	r3, [r7, #12]
 1210 001a 002B     		cmp	r3, #0
 1211 001c 47D0     		beq	.L68
 1212              		.loc 1 1161 0 is_stmt 0 discriminator 1
 1213 001e 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 1214 0022 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 1215 0026 1B68     		ldr	r3, [r3, #0]
 1216 0028 FA68     		ldr	r2, [r7, #12]
 1217 002a 9A42     		cmp	r2, r3
 1218 002c 3FD0     		beq	.L68
1162:../FreeRTOS/Sources/tasks.c **** 		{
1163:../FreeRTOS/Sources/tasks.c **** 			taskENTER_CRITICAL();
 1219              		.loc 1 1163 0 is_stmt 1
 1220 002e FFF7FEFF 		bl	vPortEnterCritical
1164:../FreeRTOS/Sources/tasks.c **** 			{
1165:../FreeRTOS/Sources/tasks.c **** 				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 1221              		.loc 1 1165 0
 1222 0032 F868     		ldr	r0, [r7, #12]
 1223 0034 FFF7FEFF 		bl	xTaskIsTaskSuspended
 1224 0038 0346     		mov	r3, r0
 1225 003a 012B     		cmp	r3, #1
 1226 003c 35D1     		bne	.L72
1166:../FreeRTOS/Sources/tasks.c **** 				{
1167:../FreeRTOS/Sources/tasks.c **** 					traceTASK_RESUME( pxTCB );
1168:../FreeRTOS/Sources/tasks.c **** 
1169:../FreeRTOS/Sources/tasks.c **** 					/* As we are in a critical section we can access the ready
1170:../FreeRTOS/Sources/tasks.c **** 					lists even if the scheduler is suspended. */
1171:../FreeRTOS/Sources/tasks.c **** 					uxListRemove(  &( pxTCB->xGenericListItem ) );
 1227              		.loc 1 1171 0
 1228 003e FB68     		ldr	r3, [r7, #12]
 1229 0040 03F10403 		add	r3, r3, #4
 1230 0044 1846     		mov	r0, r3
 1231 0046 FFF7FEFF 		bl	uxListRemove
1172:../FreeRTOS/Sources/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 1232              		.loc 1 1172 0
 1233 004a FB68     		ldr	r3, [r7, #12]
 1234 004c DA6A     		ldr	r2, [r3, #44]
 1235 004e 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 1236 0052 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 1237 0056 1B68     		ldr	r3, [r3, #0]
 1238 0058 9A42     		cmp	r2, r3
 1239 005a 06D9     		bls	.L73
 1240              		.loc 1 1172 0 is_stmt 0 discriminator 1
 1241 005c FB68     		ldr	r3, [r7, #12]
 1242 005e DA6A     		ldr	r2, [r3, #44]
 1243 0060 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 1244 0064 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 1245 0068 1A60     		str	r2, [r3, #0]
 1246              	.L73:
 1247              		.loc 1 1172 0 discriminator 2
 1248 006a FB68     		ldr	r3, [r7, #12]
 1249 006c DA6A     		ldr	r2, [r3, #44]
 1250 006e 1346     		mov	r3, r2
 1251 0070 4FEA8303 		lsl	r3, r3, #2
 1252 0074 9B18     		adds	r3, r3, r2
 1253 0076 4FEA8303 		lsl	r3, r3, #2
 1254 007a 40F20002 		movw	r2, #:lower16:pxReadyTasksLists
 1255 007e C0F20002 		movt	r2, #:upper16:pxReadyTasksLists
 1256 0082 9A18     		adds	r2, r3, r2
 1257 0084 FB68     		ldr	r3, [r7, #12]
 1258 0086 03F10403 		add	r3, r3, #4
 1259 008a 1046     		mov	r0, r2
 1260 008c 1946     		mov	r1, r3
 1261 008e FFF7FEFF 		bl	vListInsertEnd
1173:../FreeRTOS/Sources/tasks.c **** 
1174:../FreeRTOS/Sources/tasks.c **** 					/* We may have just resumed a higher priority task. */
1175:../FreeRTOS/Sources/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1262              		.loc 1 1175 0 is_stmt 1 discriminator 2
 1263 0092 FB68     		ldr	r3, [r7, #12]
 1264 0094 DA6A     		ldr	r2, [r3, #44]
 1265 0096 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 1266 009a C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 1267 009e 1B68     		ldr	r3, [r3, #0]
 1268 00a0 DB6A     		ldr	r3, [r3, #44]
 1269 00a2 9A42     		cmp	r2, r3
 1270 00a4 01D3     		bcc	.L72
1176:../FreeRTOS/Sources/tasks.c **** 					{
1177:../FreeRTOS/Sources/tasks.c **** 						/* This yield may not cause the task just resumed to run, but
1178:../FreeRTOS/Sources/tasks.c **** 						will leave the lists in the correct state for the next yield. */
1179:../FreeRTOS/Sources/tasks.c **** 						portYIELD_WITHIN_API();
 1271              		.loc 1 1179 0
 1272 00a6 FFF7FEFF 		bl	vPortYieldFromISR
 1273              	.L72:
1180:../FreeRTOS/Sources/tasks.c **** 					}
1181:../FreeRTOS/Sources/tasks.c **** 				}
1182:../FreeRTOS/Sources/tasks.c **** 			}
1183:../FreeRTOS/Sources/tasks.c **** 			taskEXIT_CRITICAL();
 1274              		.loc 1 1183 0
 1275 00aa FFF7FEFF 		bl	vPortExitCritical
 1276              	.L68:
1184:../FreeRTOS/Sources/tasks.c **** 		}
1185:../FreeRTOS/Sources/tasks.c **** 	}
 1277              		.loc 1 1185 0
 1278 00ae 07F11007 		add	r7, r7, #16
 1279 00b2 BD46     		mov	sp, r7
 1280 00b4 80BD     		pop	{r7, pc}
 1281              		.cfi_endproc
 1282              	.LFE8:
 1284 00b6 00BF     		.section	.text.xTaskResumeFromISR,"ax",%progbits
 1285              		.align	2
 1286              		.global	xTaskResumeFromISR
 1287              		.thumb
 1288              		.thumb_func
 1290              	xTaskResumeFromISR:
 1291              	.LFB9:
1186:../FreeRTOS/Sources/tasks.c **** 
1187:../FreeRTOS/Sources/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1188:../FreeRTOS/Sources/tasks.c **** 
1189:../FreeRTOS/Sources/tasks.c **** /*-----------------------------------------------------------*/
1190:../FreeRTOS/Sources/tasks.c **** 
1191:../FreeRTOS/Sources/tasks.c **** #if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
1192:../FreeRTOS/Sources/tasks.c **** 
1193:../FreeRTOS/Sources/tasks.c **** 	portBASE_TYPE xTaskResumeFromISR( xTaskHandle xTaskToResume )
1194:../FreeRTOS/Sources/tasks.c **** 	{
 1292              		.loc 1 1194 0
 1293              		.cfi_startproc
 1294              		@ args = 0, pretend = 0, frame = 24
 1295              		@ frame_needed = 1, uses_anonymous_args = 0
 1296 0000 80B5     		push	{r7, lr}
 1297              	.LCFI27:
 1298              		.cfi_def_cfa_offset 8
 1299              		.cfi_offset 7, -8
 1300              		.cfi_offset 14, -4
 1301 0002 86B0     		sub	sp, sp, #24
 1302              	.LCFI28:
 1303              		.cfi_def_cfa_offset 32
 1304 0004 00AF     		add	r7, sp, #0
 1305              	.LCFI29:
 1306              		.cfi_def_cfa_register 7
 1307 0006 7860     		str	r0, [r7, #4]
1195:../FreeRTOS/Sources/tasks.c **** 	portBASE_TYPE xYieldRequired = pdFALSE;
 1308              		.loc 1 1195 0
 1309 0008 4FF00003 		mov	r3, #0
 1310 000c 7B61     		str	r3, [r7, #20]
1196:../FreeRTOS/Sources/tasks.c **** 	tskTCB *pxTCB;
1197:../FreeRTOS/Sources/tasks.c **** 	unsigned portBASE_TYPE uxSavedInterruptStatus;
1198:../FreeRTOS/Sources/tasks.c **** 
1199:../FreeRTOS/Sources/tasks.c **** 		configASSERT( xTaskToResume );
 1311              		.loc 1 1199 0
 1312 000e 7B68     		ldr	r3, [r7, #4]
 1313 0010 002B     		cmp	r3, #0
 1314 0012 02D1     		bne	.L75
 1315              		.loc 1 1199 0 is_stmt 0 discriminator 1
 1316 0014 FFF7FEFF 		bl	ulPortSetInterruptMask
 1317              	.L76:
 1318              		.loc 1 1199 0 discriminator 2
 1319 0018 FEE7     		b	.L76
 1320              	.L75:
1200:../FreeRTOS/Sources/tasks.c **** 
1201:../FreeRTOS/Sources/tasks.c **** 		pxTCB = ( tskTCB * ) xTaskToResume;
 1321              		.loc 1 1201 0 is_stmt 1
 1322 001a 7B68     		ldr	r3, [r7, #4]
 1323 001c 3B61     		str	r3, [r7, #16]
1202:../FreeRTOS/Sources/tasks.c **** 
1203:../FreeRTOS/Sources/tasks.c **** 		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1324              		.loc 1 1203 0
 1325 001e FFF7FEFF 		bl	ulPortSetInterruptMask
 1326 0022 F860     		str	r0, [r7, #12]
1204:../FreeRTOS/Sources/tasks.c **** 		{
1205:../FreeRTOS/Sources/tasks.c **** 			if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 1327              		.loc 1 1205 0
 1328 0024 3869     		ldr	r0, [r7, #16]
 1329 0026 FFF7FEFF 		bl	xTaskIsTaskSuspended
 1330 002a 0346     		mov	r3, r0
 1331 002c 012B     		cmp	r3, #1
 1332 002e 49D1     		bne	.L77
1206:../FreeRTOS/Sources/tasks.c **** 			{
1207:../FreeRTOS/Sources/tasks.c **** 				traceTASK_RESUME_FROM_ISR( pxTCB );
1208:../FreeRTOS/Sources/tasks.c **** 
1209:../FreeRTOS/Sources/tasks.c **** 				if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 1333              		.loc 1 1209 0
 1334 0030 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 1335 0034 C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 1336 0038 1B68     		ldr	r3, [r3, #0]
 1337 003a 002B     		cmp	r3, #0
 1338 003c 38D1     		bne	.L78
1210:../FreeRTOS/Sources/tasks.c **** 				{
1211:../FreeRTOS/Sources/tasks.c **** 					xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
 1339              		.loc 1 1211 0
 1340 003e 3B69     		ldr	r3, [r7, #16]
 1341 0040 DA6A     		ldr	r2, [r3, #44]
 1342 0042 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 1343 0046 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 1344 004a 1B68     		ldr	r3, [r3, #0]
 1345 004c DB6A     		ldr	r3, [r3, #44]
 1346 004e 9A42     		cmp	r2, r3
 1347 0050 34BF     		ite	cc
 1348 0052 0023     		movcc	r3, #0
 1349 0054 0123     		movcs	r3, #1
 1350 0056 DBB2     		uxtb	r3, r3
 1351 0058 7B61     		str	r3, [r7, #20]
1212:../FreeRTOS/Sources/tasks.c **** 					uxListRemove(  &( pxTCB->xGenericListItem ) );
 1352              		.loc 1 1212 0
 1353 005a 3B69     		ldr	r3, [r7, #16]
 1354 005c 03F10403 		add	r3, r3, #4
 1355 0060 1846     		mov	r0, r3
 1356 0062 FFF7FEFF 		bl	uxListRemove
1213:../FreeRTOS/Sources/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 1357              		.loc 1 1213 0
 1358 0066 3B69     		ldr	r3, [r7, #16]
 1359 0068 DA6A     		ldr	r2, [r3, #44]
 1360 006a 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 1361 006e C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 1362 0072 1B68     		ldr	r3, [r3, #0]
 1363 0074 9A42     		cmp	r2, r3
 1364 0076 06D9     		bls	.L79
 1365              		.loc 1 1213 0 is_stmt 0 discriminator 1
 1366 0078 3B69     		ldr	r3, [r7, #16]
 1367 007a DA6A     		ldr	r2, [r3, #44]
 1368 007c 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 1369 0080 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 1370 0084 1A60     		str	r2, [r3, #0]
 1371              	.L79:
 1372              		.loc 1 1213 0 discriminator 2
 1373 0086 3B69     		ldr	r3, [r7, #16]
 1374 0088 DA6A     		ldr	r2, [r3, #44]
 1375 008a 1346     		mov	r3, r2
 1376 008c 4FEA8303 		lsl	r3, r3, #2
 1377 0090 9B18     		adds	r3, r3, r2
 1378 0092 4FEA8303 		lsl	r3, r3, #2
 1379 0096 40F20002 		movw	r2, #:lower16:pxReadyTasksLists
 1380 009a C0F20002 		movt	r2, #:upper16:pxReadyTasksLists
 1381 009e 9A18     		adds	r2, r3, r2
 1382 00a0 3B69     		ldr	r3, [r7, #16]
 1383 00a2 03F10403 		add	r3, r3, #4
 1384 00a6 1046     		mov	r0, r2
 1385 00a8 1946     		mov	r1, r3
 1386 00aa FFF7FEFF 		bl	vListInsertEnd
 1387 00ae 09E0     		b	.L77
 1388              	.L78:
1214:../FreeRTOS/Sources/tasks.c **** 				}
1215:../FreeRTOS/Sources/tasks.c **** 				else
1216:../FreeRTOS/Sources/tasks.c **** 				{
1217:../FreeRTOS/Sources/tasks.c **** 					/* We cannot access the delayed or ready lists, so will hold this
1218:../FreeRTOS/Sources/tasks.c **** 					task pending until the scheduler is resumed, at which point a
1219:../FreeRTOS/Sources/tasks.c **** 					yield will be performed if necessary. */
1220:../FreeRTOS/Sources/tasks.c **** 					vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 1389              		.loc 1 1220 0 is_stmt 1
 1390 00b0 3B69     		ldr	r3, [r7, #16]
 1391 00b2 03F11803 		add	r3, r3, #24
 1392 00b6 40F20000 		movw	r0, #:lower16:xPendingReadyList
 1393 00ba C0F20000 		movt	r0, #:upper16:xPendingReadyList
 1394 00be 1946     		mov	r1, r3
 1395 00c0 FFF7FEFF 		bl	vListInsertEnd
 1396              	.L77:
1221:../FreeRTOS/Sources/tasks.c **** 				}
1222:../FreeRTOS/Sources/tasks.c **** 			}
1223:../FreeRTOS/Sources/tasks.c **** 		}
1224:../FreeRTOS/Sources/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 1397              		.loc 1 1224 0
 1398 00c4 F868     		ldr	r0, [r7, #12]
 1399 00c6 FFF7FEFF 		bl	vPortClearInterruptMask
1225:../FreeRTOS/Sources/tasks.c **** 
1226:../FreeRTOS/Sources/tasks.c **** 		return xYieldRequired;
 1400              		.loc 1 1226 0
 1401 00ca 7B69     		ldr	r3, [r7, #20]
1227:../FreeRTOS/Sources/tasks.c **** 	}
 1402              		.loc 1 1227 0
 1403 00cc 1846     		mov	r0, r3
 1404 00ce 07F11807 		add	r7, r7, #24
 1405 00d2 BD46     		mov	sp, r7
 1406 00d4 80BD     		pop	{r7, pc}
 1407              		.cfi_endproc
 1408              	.LFE9:
 1410 00d6 00BF     		.section	.rodata
 1411              		.align	2
 1412              	.LC0:
 1413 0000 49444C45 		.ascii	"IDLE\000"
 1413      00
 1414 0005 000000   		.section	.text.vTaskStartScheduler,"ax",%progbits
 1415              		.align	2
 1416              		.global	vTaskStartScheduler
 1417              		.thumb
 1418              		.thumb_func
 1420              	vTaskStartScheduler:
 1421              	.LFB10:
1228:../FreeRTOS/Sources/tasks.c **** 
1229:../FreeRTOS/Sources/tasks.c **** #endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
1230:../FreeRTOS/Sources/tasks.c **** /*-----------------------------------------------------------*/
1231:../FreeRTOS/Sources/tasks.c **** 
1232:../FreeRTOS/Sources/tasks.c **** void vTaskStartScheduler( void )
1233:../FreeRTOS/Sources/tasks.c **** {
 1422              		.loc 1 1233 0
 1423              		.cfi_startproc
 1424              		@ args = 0, pretend = 0, frame = 8
 1425              		@ frame_needed = 1, uses_anonymous_args = 0
 1426 0000 80B5     		push	{r7, lr}
 1427              	.LCFI30:
 1428              		.cfi_def_cfa_offset 8
 1429              		.cfi_offset 7, -8
 1430              		.cfi_offset 14, -4
 1431 0002 86B0     		sub	sp, sp, #24
 1432              	.LCFI31:
 1433              		.cfi_def_cfa_offset 32
 1434 0004 04AF     		add	r7, sp, #16
 1435              	.LCFI32:
 1436              		.cfi_def_cfa 7, 16
1234:../FreeRTOS/Sources/tasks.c **** portBASE_TYPE xReturn;
1235:../FreeRTOS/Sources/tasks.c **** 
1236:../FreeRTOS/Sources/tasks.c **** 	/* Add the idle task at the lowest priority. */
1237:../FreeRTOS/Sources/tasks.c **** 	#if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
1238:../FreeRTOS/Sources/tasks.c **** 	{
1239:../FreeRTOS/Sources/tasks.c **** 		/* Create the idle task, storing its handle in xIdleTaskHandle so it can
1240:../FreeRTOS/Sources/tasks.c **** 		be returned by the xTaskGetIdleTaskHandle() function. */
1241:../FreeRTOS/Sources/tasks.c **** 		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL
1242:../FreeRTOS/Sources/tasks.c **** 	}
1243:../FreeRTOS/Sources/tasks.c **** 	#else
1244:../FreeRTOS/Sources/tasks.c **** 	{
1245:../FreeRTOS/Sources/tasks.c **** 		/* Create the idle task without storing its handle. */
1246:../FreeRTOS/Sources/tasks.c **** 		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL
 1437              		.loc 1 1246 0
 1438 0006 4FF00003 		mov	r3, #0
 1439 000a 0093     		str	r3, [sp, #0]
 1440 000c 4FF00003 		mov	r3, #0
 1441 0010 0193     		str	r3, [sp, #4]
 1442 0012 4FF00003 		mov	r3, #0
 1443 0016 0293     		str	r3, [sp, #8]
 1444 0018 4FF00003 		mov	r3, #0
 1445 001c 0393     		str	r3, [sp, #12]
 1446 001e 40F20000 		movw	r0, #:lower16:prvIdleTask
 1447 0022 C0F20000 		movt	r0, #:upper16:prvIdleTask
 1448 0026 40F20001 		movw	r1, #:lower16:.LC0
 1449 002a C0F20001 		movt	r1, #:upper16:.LC0
 1450 002e 4FF04602 		mov	r2, #70
 1451 0032 4FF00003 		mov	r3, #0
 1452 0036 FFF7FEFF 		bl	xTaskGenericCreate
 1453 003a 7860     		str	r0, [r7, #4]
1247:../FreeRTOS/Sources/tasks.c **** 	}
1248:../FreeRTOS/Sources/tasks.c **** 	#endif /* INCLUDE_xTaskGetIdleTaskHandle */
1249:../FreeRTOS/Sources/tasks.c **** 
1250:../FreeRTOS/Sources/tasks.c **** 	#if ( configUSE_TIMERS == 1 )
1251:../FreeRTOS/Sources/tasks.c **** 	{
1252:../FreeRTOS/Sources/tasks.c **** 		if( xReturn == pdPASS )
 1454              		.loc 1 1252 0
 1455 003c 7B68     		ldr	r3, [r7, #4]
 1456 003e 012B     		cmp	r3, #1
 1457 0040 02D1     		bne	.L82
1253:../FreeRTOS/Sources/tasks.c **** 		{
1254:../FreeRTOS/Sources/tasks.c **** 			xReturn = xTimerCreateTimerTask();
 1458              		.loc 1 1254 0
 1459 0042 FFF7FEFF 		bl	xTimerCreateTimerTask
 1460 0046 7860     		str	r0, [r7, #4]
 1461              	.L82:
1255:../FreeRTOS/Sources/tasks.c **** 		}
1256:../FreeRTOS/Sources/tasks.c **** 	}
1257:../FreeRTOS/Sources/tasks.c **** 	#endif /* configUSE_TIMERS */
1258:../FreeRTOS/Sources/tasks.c **** 
1259:../FreeRTOS/Sources/tasks.c **** 	if( xReturn == pdPASS )
 1462              		.loc 1 1259 0
 1463 0048 7B68     		ldr	r3, [r7, #4]
 1464 004a 012B     		cmp	r3, #1
 1465 004c 12D1     		bne	.L83
1260:../FreeRTOS/Sources/tasks.c **** 	{
1261:../FreeRTOS/Sources/tasks.c **** 		/* Interrupts are turned off here, to ensure a tick does not occur
1262:../FreeRTOS/Sources/tasks.c **** 		before or during the call to xPortStartScheduler().  The stacks of
1263:../FreeRTOS/Sources/tasks.c **** 		the created tasks contain a status word with interrupts switched on
1264:../FreeRTOS/Sources/tasks.c **** 		so interrupts will automatically get re-enabled when the first task
1265:../FreeRTOS/Sources/tasks.c **** 		starts to run.
1266:../FreeRTOS/Sources/tasks.c **** 
1267:../FreeRTOS/Sources/tasks.c **** 		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
1268:../FreeRTOS/Sources/tasks.c **** 		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
1269:../FreeRTOS/Sources/tasks.c **** 		portDISABLE_INTERRUPTS();
 1466              		.loc 1 1269 0
 1467 004e FFF7FEFF 		bl	ulPortSetInterruptMask
1270:../FreeRTOS/Sources/tasks.c **** 
1271:../FreeRTOS/Sources/tasks.c **** 		xSchedulerRunning = pdTRUE;
 1468              		.loc 1 1271 0
 1469 0052 40F20003 		movw	r3, #:lower16:xSchedulerRunning
 1470 0056 C0F20003 		movt	r3, #:upper16:xSchedulerRunning
 1471 005a 4FF00102 		mov	r2, #1
 1472 005e 1A60     		str	r2, [r3, #0]
1272:../FreeRTOS/Sources/tasks.c **** 		xTickCount = ( portTickType ) 0U;
 1473              		.loc 1 1272 0
 1474 0060 40F20003 		movw	r3, #:lower16:xTickCount
 1475 0064 C0F20003 		movt	r3, #:upper16:xTickCount
 1476 0068 4FF00002 		mov	r2, #0
 1477 006c 1A60     		str	r2, [r3, #0]
1273:../FreeRTOS/Sources/tasks.c **** 
1274:../FreeRTOS/Sources/tasks.c **** 		/* If configGENERATE_RUN_TIME_STATS is defined then the following
1275:../FreeRTOS/Sources/tasks.c **** 		macro must be defined to configure the timer/counter used to generate
1276:../FreeRTOS/Sources/tasks.c **** 		the run time counter time base. */
1277:../FreeRTOS/Sources/tasks.c **** 		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
1278:../FreeRTOS/Sources/tasks.c **** 
1279:../FreeRTOS/Sources/tasks.c **** 		/* Setting up the timer tick is hardware specific and thus in the
1280:../FreeRTOS/Sources/tasks.c **** 		portable interface. */
1281:../FreeRTOS/Sources/tasks.c **** 		if( xPortStartScheduler() != pdFALSE )
 1478              		.loc 1 1281 0
 1479 006e FFF7FEFF 		bl	xPortStartScheduler
 1480 0072 05E0     		b	.L81
 1481              	.L83:
1282:../FreeRTOS/Sources/tasks.c **** 		{
1283:../FreeRTOS/Sources/tasks.c **** 			/* Should not reach here as if the scheduler is running the
1284:../FreeRTOS/Sources/tasks.c **** 			function will not return. */
1285:../FreeRTOS/Sources/tasks.c **** 		}
1286:../FreeRTOS/Sources/tasks.c **** 		else
1287:../FreeRTOS/Sources/tasks.c **** 		{
1288:../FreeRTOS/Sources/tasks.c **** 			/* Should only reach here if a task calls xTaskEndScheduler(). */
1289:../FreeRTOS/Sources/tasks.c **** 		}
1290:../FreeRTOS/Sources/tasks.c **** 	}
1291:../FreeRTOS/Sources/tasks.c **** 	else
1292:../FreeRTOS/Sources/tasks.c **** 	{
1293:../FreeRTOS/Sources/tasks.c **** 		/* This line will only be reached if the kernel could not be started,
1294:../FreeRTOS/Sources/tasks.c **** 		because there was not enough FreeRTOS heap to create the idle task
1295:../FreeRTOS/Sources/tasks.c **** 		or the timer task. */
1296:../FreeRTOS/Sources/tasks.c **** 		configASSERT( xReturn );
 1482              		.loc 1 1296 0
 1483 0074 7B68     		ldr	r3, [r7, #4]
 1484 0076 002B     		cmp	r3, #0
 1485 0078 02D1     		bne	.L81
 1486              		.loc 1 1296 0 is_stmt 0 discriminator 1
 1487 007a FFF7FEFF 		bl	ulPortSetInterruptMask
 1488              	.L85:
 1489              		.loc 1 1296 0 discriminator 2
 1490 007e FEE7     		b	.L85
 1491              	.L81:
1297:../FreeRTOS/Sources/tasks.c **** 	}
1298:../FreeRTOS/Sources/tasks.c **** }
 1492              		.loc 1 1298 0 is_stmt 1
 1493 0080 07F10807 		add	r7, r7, #8
 1494 0084 BD46     		mov	sp, r7
 1495 0086 80BD     		pop	{r7, pc}
 1496              		.cfi_endproc
 1497              	.LFE10:
 1499              		.section	.text.vTaskEndScheduler,"ax",%progbits
 1500              		.align	2
 1501              		.global	vTaskEndScheduler
 1502              		.thumb
 1503              		.thumb_func
 1505              	vTaskEndScheduler:
 1506              	.LFB11:
1299:../FreeRTOS/Sources/tasks.c **** /*-----------------------------------------------------------*/
1300:../FreeRTOS/Sources/tasks.c **** 
1301:../FreeRTOS/Sources/tasks.c **** void vTaskEndScheduler( void )
1302:../FreeRTOS/Sources/tasks.c **** {
 1507              		.loc 1 1302 0
 1508              		.cfi_startproc
 1509              		@ args = 0, pretend = 0, frame = 0
 1510              		@ frame_needed = 1, uses_anonymous_args = 0
 1511 0000 80B5     		push	{r7, lr}
 1512              	.LCFI33:
 1513              		.cfi_def_cfa_offset 8
 1514              		.cfi_offset 7, -8
 1515              		.cfi_offset 14, -4
 1516 0002 00AF     		add	r7, sp, #0
 1517              	.LCFI34:
 1518              		.cfi_def_cfa_register 7
1303:../FreeRTOS/Sources/tasks.c **** 	/* Stop the scheduler interrupts and call the portable scheduler end
1304:../FreeRTOS/Sources/tasks.c **** 	routine so the original ISRs can be restored if necessary.  The port
1305:../FreeRTOS/Sources/tasks.c **** 	layer must ensure interrupts enable	bit is left in the correct state. */
1306:../FreeRTOS/Sources/tasks.c **** 	portDISABLE_INTERRUPTS();
 1519              		.loc 1 1306 0
 1520 0004 FFF7FEFF 		bl	ulPortSetInterruptMask
1307:../FreeRTOS/Sources/tasks.c **** 	xSchedulerRunning = pdFALSE;
 1521              		.loc 1 1307 0
 1522 0008 40F20003 		movw	r3, #:lower16:xSchedulerRunning
 1523 000c C0F20003 		movt	r3, #:upper16:xSchedulerRunning
 1524 0010 4FF00002 		mov	r2, #0
 1525 0014 1A60     		str	r2, [r3, #0]
1308:../FreeRTOS/Sources/tasks.c **** 	vPortEndScheduler();
 1526              		.loc 1 1308 0
 1527 0016 FFF7FEFF 		bl	vPortEndScheduler
1309:../FreeRTOS/Sources/tasks.c **** }
 1528              		.loc 1 1309 0
 1529 001a 80BD     		pop	{r7, pc}
 1530              		.cfi_endproc
 1531              	.LFE11:
 1533              		.section	.text.vTaskSuspendAll,"ax",%progbits
 1534              		.align	2
 1535              		.global	vTaskSuspendAll
 1536              		.thumb
 1537              		.thumb_func
 1539              	vTaskSuspendAll:
 1540              	.LFB12:
1310:../FreeRTOS/Sources/tasks.c **** /*----------------------------------------------------------*/
1311:../FreeRTOS/Sources/tasks.c **** 
1312:../FreeRTOS/Sources/tasks.c **** void vTaskSuspendAll( void )
1313:../FreeRTOS/Sources/tasks.c **** {
 1541              		.loc 1 1313 0
 1542              		.cfi_startproc
 1543              		@ args = 0, pretend = 0, frame = 0
 1544              		@ frame_needed = 1, uses_anonymous_args = 0
 1545              		@ link register save eliminated.
 1546 0000 80B4     		push	{r7}
 1547              	.LCFI35:
 1548              		.cfi_def_cfa_offset 4
 1549              		.cfi_offset 7, -4
 1550 0002 00AF     		add	r7, sp, #0
 1551              	.LCFI36:
 1552              		.cfi_def_cfa_register 7
1314:../FreeRTOS/Sources/tasks.c **** 	/* A critical section is not required as the variable is of type
1315:../FreeRTOS/Sources/tasks.c **** 	portBASE_TYPE. */
1316:../FreeRTOS/Sources/tasks.c **** 	++uxSchedulerSuspended;
 1553              		.loc 1 1316 0
 1554 0004 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 1555 0008 C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 1556 000c 1B68     		ldr	r3, [r3, #0]
 1557 000e 03F10102 		add	r2, r3, #1
 1558 0012 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 1559 0016 C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 1560 001a 1A60     		str	r2, [r3, #0]
1317:../FreeRTOS/Sources/tasks.c **** }
 1561              		.loc 1 1317 0
 1562 001c BD46     		mov	sp, r7
 1563 001e 80BC     		pop	{r7}
 1564 0020 7047     		bx	lr
 1565              		.cfi_endproc
 1566              	.LFE12:
 1568 0022 00BF     		.section	.text.xTaskResumeAll,"ax",%progbits
 1569              		.align	2
 1570              		.global	xTaskResumeAll
 1571              		.thumb
 1572              		.thumb_func
 1574              	xTaskResumeAll:
 1575              	.LFB13:
1318:../FreeRTOS/Sources/tasks.c **** /*----------------------------------------------------------*/
1319:../FreeRTOS/Sources/tasks.c **** 
1320:../FreeRTOS/Sources/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
1321:../FreeRTOS/Sources/tasks.c **** 
1322:../FreeRTOS/Sources/tasks.c **** 	static portTickType prvGetExpectedIdleTime( void )
1323:../FreeRTOS/Sources/tasks.c **** 	{
1324:../FreeRTOS/Sources/tasks.c **** 	portTickType xReturn;
1325:../FreeRTOS/Sources/tasks.c **** 
1326:../FreeRTOS/Sources/tasks.c **** 		if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
1327:../FreeRTOS/Sources/tasks.c **** 		{
1328:../FreeRTOS/Sources/tasks.c **** 			xReturn = 0;
1329:../FreeRTOS/Sources/tasks.c **** 		}
1330:../FreeRTOS/Sources/tasks.c **** 		else if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > 1 )
1331:../FreeRTOS/Sources/tasks.c **** 		{
1332:../FreeRTOS/Sources/tasks.c **** 			/* There are other idle priority tasks in the ready state.  If
1333:../FreeRTOS/Sources/tasks.c **** 			time slicing is used then the very next tick interrupt must be
1334:../FreeRTOS/Sources/tasks.c **** 			processed. */
1335:../FreeRTOS/Sources/tasks.c **** 			xReturn = 0;
1336:../FreeRTOS/Sources/tasks.c **** 		}
1337:../FreeRTOS/Sources/tasks.c **** 		else
1338:../FreeRTOS/Sources/tasks.c **** 		{
1339:../FreeRTOS/Sources/tasks.c **** 			xReturn = xNextTaskUnblockTime - xTickCount;
1340:../FreeRTOS/Sources/tasks.c **** 		}
1341:../FreeRTOS/Sources/tasks.c **** 
1342:../FreeRTOS/Sources/tasks.c **** 		return xReturn;
1343:../FreeRTOS/Sources/tasks.c **** 	}
1344:../FreeRTOS/Sources/tasks.c **** 
1345:../FreeRTOS/Sources/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
1346:../FreeRTOS/Sources/tasks.c **** /*----------------------------------------------------------*/
1347:../FreeRTOS/Sources/tasks.c **** 
1348:../FreeRTOS/Sources/tasks.c **** signed portBASE_TYPE xTaskResumeAll( void )
1349:../FreeRTOS/Sources/tasks.c **** {
 1576              		.loc 1 1349 0
 1577              		.cfi_startproc
 1578              		@ args = 0, pretend = 0, frame = 8
 1579              		@ frame_needed = 1, uses_anonymous_args = 0
 1580 0000 90B5     		push	{r4, r7, lr}
 1581              	.LCFI37:
 1582              		.cfi_def_cfa_offset 12
 1583              		.cfi_offset 4, -12
 1584              		.cfi_offset 7, -8
 1585              		.cfi_offset 14, -4
 1586 0002 83B0     		sub	sp, sp, #12
 1587              	.LCFI38:
 1588              		.cfi_def_cfa_offset 24
 1589 0004 00AF     		add	r7, sp, #0
 1590              	.LCFI39:
 1591              		.cfi_def_cfa_register 7
1350:../FreeRTOS/Sources/tasks.c **** register tskTCB *pxTCB;
1351:../FreeRTOS/Sources/tasks.c **** signed portBASE_TYPE xAlreadyYielded = pdFALSE;
 1592              		.loc 1 1351 0
 1593 0006 4FF00003 		mov	r3, #0
 1594 000a 7B60     		str	r3, [r7, #4]
1352:../FreeRTOS/Sources/tasks.c **** 
1353:../FreeRTOS/Sources/tasks.c **** 	/* If uxSchedulerSuspended is zero then this function does not match a
1354:../FreeRTOS/Sources/tasks.c **** 	previous call to vTaskSuspendAll(). */
1355:../FreeRTOS/Sources/tasks.c **** 	configASSERT( uxSchedulerSuspended );
 1595              		.loc 1 1355 0
 1596 000c 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 1597 0010 C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 1598 0014 1B68     		ldr	r3, [r3, #0]
 1599 0016 002B     		cmp	r3, #0
 1600 0018 02D1     		bne	.L89
 1601              		.loc 1 1355 0 is_stmt 0 discriminator 1
 1602 001a FFF7FEFF 		bl	ulPortSetInterruptMask
 1603              	.L90:
 1604              		.loc 1 1355 0 discriminator 2
 1605 001e FEE7     		b	.L90
 1606              	.L89:
1356:../FreeRTOS/Sources/tasks.c **** 
1357:../FreeRTOS/Sources/tasks.c **** 	/* It is possible that an ISR caused a task to be removed from an event
1358:../FreeRTOS/Sources/tasks.c **** 	list while the scheduler was suspended.  If this was the case then the
1359:../FreeRTOS/Sources/tasks.c **** 	removed task will have been added to the xPendingReadyList.  Once the
1360:../FreeRTOS/Sources/tasks.c **** 	scheduler has been resumed it is safe to move all the pending ready
1361:../FreeRTOS/Sources/tasks.c **** 	tasks from this list into their appropriate ready list. */
1362:../FreeRTOS/Sources/tasks.c **** 	taskENTER_CRITICAL();
 1607              		.loc 1 1362 0 is_stmt 1
 1608 0020 FFF7FEFF 		bl	vPortEnterCritical
1363:../FreeRTOS/Sources/tasks.c **** 	{
1364:../FreeRTOS/Sources/tasks.c **** 		--uxSchedulerSuspended;
 1609              		.loc 1 1364 0
 1610 0024 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 1611 0028 C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 1612 002c 1B68     		ldr	r3, [r3, #0]
 1613 002e 03F1FF32 		add	r2, r3, #-1
 1614 0032 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 1615 0036 C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 1616 003a 1A60     		str	r2, [r3, #0]
1365:../FreeRTOS/Sources/tasks.c **** 
1366:../FreeRTOS/Sources/tasks.c **** 		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 1617              		.loc 1 1366 0
 1618 003c 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 1619 0040 C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 1620 0044 1B68     		ldr	r3, [r3, #0]
 1621 0046 002B     		cmp	r3, #0
 1622 0048 40F08480 		bne	.L91
1367:../FreeRTOS/Sources/tasks.c **** 		{
1368:../FreeRTOS/Sources/tasks.c **** 			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
 1623              		.loc 1 1368 0
 1624 004c 40F20003 		movw	r3, #:lower16:uxCurrentNumberOfTasks
 1625 0050 C0F20003 		movt	r3, #:upper16:uxCurrentNumberOfTasks
 1626 0054 1B68     		ldr	r3, [r3, #0]
 1627 0056 002B     		cmp	r3, #0
 1628 0058 7CD0     		beq	.L91
 1629              	.LBB3:
1369:../FreeRTOS/Sources/tasks.c **** 			{
1370:../FreeRTOS/Sources/tasks.c **** 				portBASE_TYPE xYieldRequired = pdFALSE;
 1630              		.loc 1 1370 0
 1631 005a 4FF00003 		mov	r3, #0
 1632 005e 3B60     		str	r3, [r7, #0]
1371:../FreeRTOS/Sources/tasks.c **** 
1372:../FreeRTOS/Sources/tasks.c **** 				/* Move any readied tasks from the pending list into the
1373:../FreeRTOS/Sources/tasks.c **** 				appropriate ready list. */
1374:../FreeRTOS/Sources/tasks.c **** 				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
 1633              		.loc 1 1374 0
 1634 0060 3BE0     		b	.L92
 1635              	.L94:
1375:../FreeRTOS/Sources/tasks.c **** 				{
1376:../FreeRTOS/Sources/tasks.c **** 					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
 1636              		.loc 1 1376 0
 1637 0062 40F20003 		movw	r3, #:lower16:xPendingReadyList
 1638 0066 C0F20003 		movt	r3, #:upper16:xPendingReadyList
 1639 006a DB68     		ldr	r3, [r3, #12]
 1640 006c DC68     		ldr	r4, [r3, #12]
1377:../FreeRTOS/Sources/tasks.c **** 					uxListRemove( &( pxTCB->xEventListItem ) );
 1641              		.loc 1 1377 0
 1642 006e 04F11803 		add	r3, r4, #24
 1643 0072 1846     		mov	r0, r3
 1644 0074 FFF7FEFF 		bl	uxListRemove
1378:../FreeRTOS/Sources/tasks.c **** 					uxListRemove( &( pxTCB->xGenericListItem ) );
 1645              		.loc 1 1378 0
 1646 0078 04F10403 		add	r3, r4, #4
 1647 007c 1846     		mov	r0, r3
 1648 007e FFF7FEFF 		bl	uxListRemove
1379:../FreeRTOS/Sources/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 1649              		.loc 1 1379 0
 1650 0082 E26A     		ldr	r2, [r4, #44]
 1651 0084 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 1652 0088 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 1653 008c 1B68     		ldr	r3, [r3, #0]
 1654 008e 9A42     		cmp	r2, r3
 1655 0090 05D9     		bls	.L93
 1656              		.loc 1 1379 0 is_stmt 0 discriminator 1
 1657 0092 E26A     		ldr	r2, [r4, #44]
 1658 0094 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 1659 0098 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 1660 009c 1A60     		str	r2, [r3, #0]
 1661              	.L93:
 1662              		.loc 1 1379 0 discriminator 2
 1663 009e E26A     		ldr	r2, [r4, #44]
 1664 00a0 1346     		mov	r3, r2
 1665 00a2 4FEA8303 		lsl	r3, r3, #2
 1666 00a6 9B18     		adds	r3, r3, r2
 1667 00a8 4FEA8303 		lsl	r3, r3, #2
 1668 00ac 40F20002 		movw	r2, #:lower16:pxReadyTasksLists
 1669 00b0 C0F20002 		movt	r2, #:upper16:pxReadyTasksLists
 1670 00b4 9A18     		adds	r2, r3, r2
 1671 00b6 04F10403 		add	r3, r4, #4
 1672 00ba 1046     		mov	r0, r2
 1673 00bc 1946     		mov	r1, r3
 1674 00be FFF7FEFF 		bl	vListInsertEnd
1380:../FreeRTOS/Sources/tasks.c **** 
1381:../FreeRTOS/Sources/tasks.c **** 					/* If we have moved a task that has a priority higher than
1382:../FreeRTOS/Sources/tasks.c **** 					the current task then we should yield. */
1383:../FreeRTOS/Sources/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1675              		.loc 1 1383 0 is_stmt 1 discriminator 2
 1676 00c2 E26A     		ldr	r2, [r4, #44]
 1677 00c4 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 1678 00c8 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 1679 00cc 1B68     		ldr	r3, [r3, #0]
 1680 00ce DB6A     		ldr	r3, [r3, #44]
 1681 00d0 9A42     		cmp	r2, r3
 1682 00d2 02D3     		bcc	.L92
1384:../FreeRTOS/Sources/tasks.c **** 					{
1385:../FreeRTOS/Sources/tasks.c **** 						xYieldRequired = pdTRUE;
 1683              		.loc 1 1385 0
 1684 00d4 4FF00103 		mov	r3, #1
 1685 00d8 3B60     		str	r3, [r7, #0]
 1686              	.L92:
1374:../FreeRTOS/Sources/tasks.c **** 				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
 1687              		.loc 1 1374 0 discriminator 1
 1688 00da 40F20003 		movw	r3, #:lower16:xPendingReadyList
 1689 00de C0F20003 		movt	r3, #:upper16:xPendingReadyList
 1690 00e2 1B68     		ldr	r3, [r3, #0]
 1691 00e4 002B     		cmp	r3, #0
 1692 00e6 BCD1     		bne	.L94
1386:../FreeRTOS/Sources/tasks.c **** 					}
1387:../FreeRTOS/Sources/tasks.c **** 				}
1388:../FreeRTOS/Sources/tasks.c **** 
1389:../FreeRTOS/Sources/tasks.c **** 				/* If any ticks occurred while the scheduler was suspended then
1390:../FreeRTOS/Sources/tasks.c **** 				they should be processed now.  This ensures the tick count does not
1391:../FreeRTOS/Sources/tasks.c **** 				slip, and that any delayed tasks are resumed at the correct time. */
1392:../FreeRTOS/Sources/tasks.c **** 				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
 1693              		.loc 1 1392 0
 1694 00e8 40F20003 		movw	r3, #:lower16:uxMissedTicks
 1695 00ec C0F20003 		movt	r3, #:upper16:uxMissedTicks
 1696 00f0 1B68     		ldr	r3, [r3, #0]
 1697 00f2 002B     		cmp	r3, #0
 1698 00f4 18D0     		beq	.L95
1393:../FreeRTOS/Sources/tasks.c **** 				{
1394:../FreeRTOS/Sources/tasks.c **** 					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
 1699              		.loc 1 1394 0
 1700 00f6 0DE0     		b	.L96
 1701              	.L97:
1395:../FreeRTOS/Sources/tasks.c **** 					{
1396:../FreeRTOS/Sources/tasks.c **** 						vTaskIncrementTick();
 1702              		.loc 1 1396 0
 1703 00f8 FFF7FEFF 		bl	vTaskIncrementTick
1397:../FreeRTOS/Sources/tasks.c **** 						--uxMissedTicks;
 1704              		.loc 1 1397 0
 1705 00fc 40F20003 		movw	r3, #:lower16:uxMissedTicks
 1706 0100 C0F20003 		movt	r3, #:upper16:uxMissedTicks
 1707 0104 1B68     		ldr	r3, [r3, #0]
 1708 0106 03F1FF32 		add	r2, r3, #-1
 1709 010a 40F20003 		movw	r3, #:lower16:uxMissedTicks
 1710 010e C0F20003 		movt	r3, #:upper16:uxMissedTicks
 1711 0112 1A60     		str	r2, [r3, #0]
 1712              	.L96:
1394:../FreeRTOS/Sources/tasks.c **** 					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
 1713              		.loc 1 1394 0 discriminator 1
 1714 0114 40F20003 		movw	r3, #:lower16:uxMissedTicks
 1715 0118 C0F20003 		movt	r3, #:upper16:uxMissedTicks
 1716 011c 1B68     		ldr	r3, [r3, #0]
 1717 011e 002B     		cmp	r3, #0
 1718 0120 EAD1     		bne	.L97
1398:../FreeRTOS/Sources/tasks.c **** 					}
1399:../FreeRTOS/Sources/tasks.c **** 
1400:../FreeRTOS/Sources/tasks.c **** 					/* As we have processed some ticks it is appropriate to yield
1401:../FreeRTOS/Sources/tasks.c **** 					to ensure the highest priority task that is ready to run is
1402:../FreeRTOS/Sources/tasks.c **** 					the task actually running. */
1403:../FreeRTOS/Sources/tasks.c **** 					#if configUSE_PREEMPTION == 1
1404:../FreeRTOS/Sources/tasks.c **** 					{
1405:../FreeRTOS/Sources/tasks.c **** 						xYieldRequired = pdTRUE;
 1719              		.loc 1 1405 0
 1720 0122 4FF00103 		mov	r3, #1
 1721 0126 3B60     		str	r3, [r7, #0]
 1722              	.L95:
1406:../FreeRTOS/Sources/tasks.c **** 					}
1407:../FreeRTOS/Sources/tasks.c **** 					#endif
1408:../FreeRTOS/Sources/tasks.c **** 				}
1409:../FreeRTOS/Sources/tasks.c **** 
1410:../FreeRTOS/Sources/tasks.c **** 				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
 1723              		.loc 1 1410 0
 1724 0128 3B68     		ldr	r3, [r7, #0]
 1725 012a 012B     		cmp	r3, #1
 1726 012c 06D0     		beq	.L98
 1727              		.loc 1 1410 0 is_stmt 0 discriminator 1
 1728 012e 40F20003 		movw	r3, #:lower16:xMissedYield
 1729 0132 C0F20003 		movt	r3, #:upper16:xMissedYield
 1730 0136 1B68     		ldr	r3, [r3, #0]
 1731 0138 012B     		cmp	r3, #1
 1732 013a 0BD1     		bne	.L91
 1733              	.L98:
1411:../FreeRTOS/Sources/tasks.c **** 				{
1412:../FreeRTOS/Sources/tasks.c **** 					xAlreadyYielded = pdTRUE;
 1734              		.loc 1 1412 0 is_stmt 1
 1735 013c 4FF00103 		mov	r3, #1
 1736 0140 7B60     		str	r3, [r7, #4]
1413:../FreeRTOS/Sources/tasks.c **** 					xMissedYield = pdFALSE;
 1737              		.loc 1 1413 0
 1738 0142 40F20003 		movw	r3, #:lower16:xMissedYield
 1739 0146 C0F20003 		movt	r3, #:upper16:xMissedYield
 1740 014a 4FF00002 		mov	r2, #0
 1741 014e 1A60     		str	r2, [r3, #0]
1414:../FreeRTOS/Sources/tasks.c **** 					portYIELD_WITHIN_API();
 1742              		.loc 1 1414 0
 1743 0150 FFF7FEFF 		bl	vPortYieldFromISR
 1744              	.L91:
 1745              	.LBE3:
1415:../FreeRTOS/Sources/tasks.c **** 				}
1416:../FreeRTOS/Sources/tasks.c **** 			}
1417:../FreeRTOS/Sources/tasks.c **** 		}
1418:../FreeRTOS/Sources/tasks.c **** 	}
1419:../FreeRTOS/Sources/tasks.c **** 	taskEXIT_CRITICAL();
 1746              		.loc 1 1419 0
 1747 0154 FFF7FEFF 		bl	vPortExitCritical
1420:../FreeRTOS/Sources/tasks.c **** 
1421:../FreeRTOS/Sources/tasks.c **** 	return xAlreadyYielded;
 1748              		.loc 1 1421 0
 1749 0158 7B68     		ldr	r3, [r7, #4]
1422:../FreeRTOS/Sources/tasks.c **** }
 1750              		.loc 1 1422 0
 1751 015a 1846     		mov	r0, r3
 1752 015c 07F10C07 		add	r7, r7, #12
 1753 0160 BD46     		mov	sp, r7
 1754 0162 90BD     		pop	{r4, r7, pc}
 1755              		.cfi_endproc
 1756              	.LFE13:
 1758              		.section	.text.xTaskGetTickCount,"ax",%progbits
 1759              		.align	2
 1760              		.global	xTaskGetTickCount
 1761              		.thumb
 1762              		.thumb_func
 1764              	xTaskGetTickCount:
 1765              	.LFB14:
1423:../FreeRTOS/Sources/tasks.c **** /*-----------------------------------------------------------*/
1424:../FreeRTOS/Sources/tasks.c **** 
1425:../FreeRTOS/Sources/tasks.c **** portTickType xTaskGetTickCount( void )
1426:../FreeRTOS/Sources/tasks.c **** {
 1766              		.loc 1 1426 0
 1767              		.cfi_startproc
 1768              		@ args = 0, pretend = 0, frame = 8
 1769              		@ frame_needed = 1, uses_anonymous_args = 0
 1770 0000 80B5     		push	{r7, lr}
 1771              	.LCFI40:
 1772              		.cfi_def_cfa_offset 8
 1773              		.cfi_offset 7, -8
 1774              		.cfi_offset 14, -4
 1775 0002 82B0     		sub	sp, sp, #8
 1776              	.LCFI41:
 1777              		.cfi_def_cfa_offset 16
 1778 0004 00AF     		add	r7, sp, #0
 1779              	.LCFI42:
 1780              		.cfi_def_cfa_register 7
1427:../FreeRTOS/Sources/tasks.c **** portTickType xTicks;
1428:../FreeRTOS/Sources/tasks.c **** 
1429:../FreeRTOS/Sources/tasks.c **** 	/* Critical section required if running on a 16 bit processor. */
1430:../FreeRTOS/Sources/tasks.c **** 	taskENTER_CRITICAL();
 1781              		.loc 1 1430 0
 1782 0006 FFF7FEFF 		bl	vPortEnterCritical
1431:../FreeRTOS/Sources/tasks.c **** 	{
1432:../FreeRTOS/Sources/tasks.c **** 		xTicks = xTickCount;
 1783              		.loc 1 1432 0
 1784 000a 40F20003 		movw	r3, #:lower16:xTickCount
 1785 000e C0F20003 		movt	r3, #:upper16:xTickCount
 1786 0012 1B68     		ldr	r3, [r3, #0]
 1787 0014 7B60     		str	r3, [r7, #4]
1433:../FreeRTOS/Sources/tasks.c **** 	}
1434:../FreeRTOS/Sources/tasks.c **** 	taskEXIT_CRITICAL();
 1788              		.loc 1 1434 0
 1789 0016 FFF7FEFF 		bl	vPortExitCritical
1435:../FreeRTOS/Sources/tasks.c **** 
1436:../FreeRTOS/Sources/tasks.c **** 	return xTicks;
 1790              		.loc 1 1436 0
 1791 001a 7B68     		ldr	r3, [r7, #4]
1437:../FreeRTOS/Sources/tasks.c **** }
 1792              		.loc 1 1437 0
 1793 001c 1846     		mov	r0, r3
 1794 001e 07F10807 		add	r7, r7, #8
 1795 0022 BD46     		mov	sp, r7
 1796 0024 80BD     		pop	{r7, pc}
 1797              		.cfi_endproc
 1798              	.LFE14:
 1800 0026 00BF     		.section	.text.xTaskGetTickCountFromISR,"ax",%progbits
 1801              		.align	2
 1802              		.global	xTaskGetTickCountFromISR
 1803              		.thumb
 1804              		.thumb_func
 1806              	xTaskGetTickCountFromISR:
 1807              	.LFB15:
1438:../FreeRTOS/Sources/tasks.c **** /*-----------------------------------------------------------*/
1439:../FreeRTOS/Sources/tasks.c **** 
1440:../FreeRTOS/Sources/tasks.c **** portTickType xTaskGetTickCountFromISR( void )
1441:../FreeRTOS/Sources/tasks.c **** {
 1808              		.loc 1 1441 0
 1809              		.cfi_startproc
 1810              		@ args = 0, pretend = 0, frame = 8
 1811              		@ frame_needed = 1, uses_anonymous_args = 0
 1812 0000 80B5     		push	{r7, lr}
 1813              	.LCFI43:
 1814              		.cfi_def_cfa_offset 8
 1815              		.cfi_offset 7, -8
 1816              		.cfi_offset 14, -4
 1817 0002 82B0     		sub	sp, sp, #8
 1818              	.LCFI44:
 1819              		.cfi_def_cfa_offset 16
 1820 0004 00AF     		add	r7, sp, #0
 1821              	.LCFI45:
 1822              		.cfi_def_cfa_register 7
1442:../FreeRTOS/Sources/tasks.c **** portTickType xReturn;
1443:../FreeRTOS/Sources/tasks.c **** unsigned portBASE_TYPE uxSavedInterruptStatus;
1444:../FreeRTOS/Sources/tasks.c **** 
1445:../FreeRTOS/Sources/tasks.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1823              		.loc 1 1445 0
 1824 0006 FFF7FEFF 		bl	ulPortSetInterruptMask
 1825 000a 7860     		str	r0, [r7, #4]
1446:../FreeRTOS/Sources/tasks.c **** 	xReturn = xTickCount;
 1826              		.loc 1 1446 0
 1827 000c 40F20003 		movw	r3, #:lower16:xTickCount
 1828 0010 C0F20003 		movt	r3, #:upper16:xTickCount
 1829 0014 1B68     		ldr	r3, [r3, #0]
 1830 0016 3B60     		str	r3, [r7, #0]
1447:../FreeRTOS/Sources/tasks.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 1831              		.loc 1 1447 0
 1832 0018 7868     		ldr	r0, [r7, #4]
 1833 001a FFF7FEFF 		bl	vPortClearInterruptMask
1448:../FreeRTOS/Sources/tasks.c **** 
1449:../FreeRTOS/Sources/tasks.c **** 	return xReturn;
 1834              		.loc 1 1449 0
 1835 001e 3B68     		ldr	r3, [r7, #0]
1450:../FreeRTOS/Sources/tasks.c **** }
 1836              		.loc 1 1450 0
 1837 0020 1846     		mov	r0, r3
 1838 0022 07F10807 		add	r7, r7, #8
 1839 0026 BD46     		mov	sp, r7
 1840 0028 80BD     		pop	{r7, pc}
 1841              		.cfi_endproc
 1842              	.LFE15:
 1844 002a 00BF     		.section	.text.uxTaskGetNumberOfTasks,"ax",%progbits
 1845              		.align	2
 1846              		.global	uxTaskGetNumberOfTasks
 1847              		.thumb
 1848              		.thumb_func
 1850              	uxTaskGetNumberOfTasks:
 1851              	.LFB16:
1451:../FreeRTOS/Sources/tasks.c **** /*-----------------------------------------------------------*/
1452:../FreeRTOS/Sources/tasks.c **** 
1453:../FreeRTOS/Sources/tasks.c **** unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
1454:../FreeRTOS/Sources/tasks.c **** {
 1852              		.loc 1 1454 0
 1853              		.cfi_startproc
 1854              		@ args = 0, pretend = 0, frame = 0
 1855              		@ frame_needed = 1, uses_anonymous_args = 0
 1856              		@ link register save eliminated.
 1857 0000 80B4     		push	{r7}
 1858              	.LCFI46:
 1859              		.cfi_def_cfa_offset 4
 1860              		.cfi_offset 7, -4
 1861 0002 00AF     		add	r7, sp, #0
 1862              	.LCFI47:
 1863              		.cfi_def_cfa_register 7
1455:../FreeRTOS/Sources/tasks.c **** 	/* A critical section is not required because the variables are of type
1456:../FreeRTOS/Sources/tasks.c **** 	portBASE_TYPE. */
1457:../FreeRTOS/Sources/tasks.c **** 	return uxCurrentNumberOfTasks;
 1864              		.loc 1 1457 0
 1865 0004 40F20003 		movw	r3, #:lower16:uxCurrentNumberOfTasks
 1866 0008 C0F20003 		movt	r3, #:upper16:uxCurrentNumberOfTasks
 1867 000c 1B68     		ldr	r3, [r3, #0]
1458:../FreeRTOS/Sources/tasks.c **** }
 1868              		.loc 1 1458 0
 1869 000e 1846     		mov	r0, r3
 1870 0010 BD46     		mov	sp, r7
 1871 0012 80BC     		pop	{r7}
 1872 0014 7047     		bx	lr
 1873              		.cfi_endproc
 1874              	.LFE16:
 1876 0016 00BF     		.section	.text.vTaskIncrementTick,"ax",%progbits
 1877              		.align	2
 1878              		.global	vTaskIncrementTick
 1879              		.thumb
 1880              		.thumb_func
 1882              	vTaskIncrementTick:
 1883              	.LFB17:
1459:../FreeRTOS/Sources/tasks.c **** /*-----------------------------------------------------------*/
1460:../FreeRTOS/Sources/tasks.c **** 
1461:../FreeRTOS/Sources/tasks.c **** #if ( INCLUDE_pcTaskGetTaskName == 1 )
1462:../FreeRTOS/Sources/tasks.c **** 
1463:../FreeRTOS/Sources/tasks.c **** 	signed char *pcTaskGetTaskName( xTaskHandle xTaskToQuery )
1464:../FreeRTOS/Sources/tasks.c **** 	{
1465:../FreeRTOS/Sources/tasks.c **** 	tskTCB *pxTCB;
1466:../FreeRTOS/Sources/tasks.c **** 
1467:../FreeRTOS/Sources/tasks.c **** 		/* If null is passed in here then the name of the calling task is being queried. */
1468:../FreeRTOS/Sources/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
1469:../FreeRTOS/Sources/tasks.c **** 		configASSERT( pxTCB );
1470:../FreeRTOS/Sources/tasks.c **** 		return &( pxTCB->pcTaskName[ 0 ] );
1471:../FreeRTOS/Sources/tasks.c **** 	}
1472:../FreeRTOS/Sources/tasks.c **** 
1473:../FreeRTOS/Sources/tasks.c **** #endif /* INCLUDE_pcTaskGetTaskName */
1474:../FreeRTOS/Sources/tasks.c **** /*-----------------------------------------------------------*/
1475:../FreeRTOS/Sources/tasks.c **** 
1476:../FreeRTOS/Sources/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1477:../FreeRTOS/Sources/tasks.c **** 
1478:../FreeRTOS/Sources/tasks.c **** 	void vTaskList( signed char *pcWriteBuffer )
1479:../FreeRTOS/Sources/tasks.c **** 	{
1480:../FreeRTOS/Sources/tasks.c **** 	unsigned portBASE_TYPE uxQueue;
1481:../FreeRTOS/Sources/tasks.c **** 
1482:../FreeRTOS/Sources/tasks.c **** 		/* This is a VERY costly function that should be used for debug only.
1483:../FreeRTOS/Sources/tasks.c **** 		It leaves interrupts disabled for a LONG time. */
1484:../FreeRTOS/Sources/tasks.c **** 
1485:../FreeRTOS/Sources/tasks.c **** 		vTaskSuspendAll();
1486:../FreeRTOS/Sources/tasks.c **** 		{
1487:../FreeRTOS/Sources/tasks.c **** 			/* Run through all the lists that could potentially contain a TCB and
1488:../FreeRTOS/Sources/tasks.c **** 			report the task name, state and stack high water mark. */
1489:../FreeRTOS/Sources/tasks.c **** 
1490:../FreeRTOS/Sources/tasks.c **** 			*pcWriteBuffer = ( signed char ) 0x00;
1491:../FreeRTOS/Sources/tasks.c **** 			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
1492:../FreeRTOS/Sources/tasks.c **** 
1493:../FreeRTOS/Sources/tasks.c **** 			uxQueue = uxTopUsedPriority + ( unsigned portBASE_TYPE ) 1U;
1494:../FreeRTOS/Sources/tasks.c **** 
1495:../FreeRTOS/Sources/tasks.c **** 			do
1496:../FreeRTOS/Sources/tasks.c **** 			{
1497:../FreeRTOS/Sources/tasks.c **** 				uxQueue--;
1498:../FreeRTOS/Sources/tasks.c **** 
1499:../FreeRTOS/Sources/tasks.c **** 				if( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) == pdFALSE )
1500:../FreeRTOS/Sources/tasks.c **** 				{
1501:../FreeRTOS/Sources/tasks.c **** 					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueue ] ), tsk
1502:../FreeRTOS/Sources/tasks.c **** 				}
1503:../FreeRTOS/Sources/tasks.c **** 			}while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );
1504:../FreeRTOS/Sources/tasks.c **** 
1505:../FreeRTOS/Sources/tasks.c **** 			if( listLIST_IS_EMPTY( pxDelayedTaskList ) == pdFALSE )
1506:../FreeRTOS/Sources/tasks.c **** 			{
1507:../FreeRTOS/Sources/tasks.c **** 				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, tskBLOCKED_CHAR );
1508:../FreeRTOS/Sources/tasks.c **** 			}
1509:../FreeRTOS/Sources/tasks.c **** 
1510:../FreeRTOS/Sources/tasks.c **** 			if( listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) == pdFALSE )
1511:../FreeRTOS/Sources/tasks.c **** 			{
1512:../FreeRTOS/Sources/tasks.c **** 				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxOverflowDelayedTaskList, tskBLOCKED_C
1513:../FreeRTOS/Sources/tasks.c **** 			}
1514:../FreeRTOS/Sources/tasks.c **** 
1515:../FreeRTOS/Sources/tasks.c **** 			#if( INCLUDE_vTaskDelete == 1 )
1516:../FreeRTOS/Sources/tasks.c **** 			{
1517:../FreeRTOS/Sources/tasks.c **** 				if( listLIST_IS_EMPTY( &xTasksWaitingTermination ) == pdFALSE )
1518:../FreeRTOS/Sources/tasks.c **** 				{
1519:../FreeRTOS/Sources/tasks.c **** 					prvListTaskWithinSingleList( pcWriteBuffer, &xTasksWaitingTermination, tskDELETED_CHAR );
1520:../FreeRTOS/Sources/tasks.c **** 				}
1521:../FreeRTOS/Sources/tasks.c **** 			}
1522:../FreeRTOS/Sources/tasks.c **** 			#endif
1523:../FreeRTOS/Sources/tasks.c **** 
1524:../FreeRTOS/Sources/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
1525:../FreeRTOS/Sources/tasks.c **** 			{
1526:../FreeRTOS/Sources/tasks.c **** 				if( listLIST_IS_EMPTY( &xSuspendedTaskList ) == pdFALSE )
1527:../FreeRTOS/Sources/tasks.c **** 				{
1528:../FreeRTOS/Sources/tasks.c **** 					prvListTaskWithinSingleList( pcWriteBuffer, &xSuspendedTaskList, tskSUSPENDED_CHAR );
1529:../FreeRTOS/Sources/tasks.c **** 				}
1530:../FreeRTOS/Sources/tasks.c **** 			}
1531:../FreeRTOS/Sources/tasks.c **** 			#endif
1532:../FreeRTOS/Sources/tasks.c **** 		}
1533:../FreeRTOS/Sources/tasks.c **** 		xTaskResumeAll();
1534:../FreeRTOS/Sources/tasks.c **** 	}
1535:../FreeRTOS/Sources/tasks.c **** 
1536:../FreeRTOS/Sources/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
1537:../FreeRTOS/Sources/tasks.c **** /*----------------------------------------------------------*/
1538:../FreeRTOS/Sources/tasks.c **** 
1539:../FreeRTOS/Sources/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
1540:../FreeRTOS/Sources/tasks.c **** 
1541:../FreeRTOS/Sources/tasks.c **** 	void vTaskGetRunTimeStats( signed char *pcWriteBuffer )
1542:../FreeRTOS/Sources/tasks.c **** 	{
1543:../FreeRTOS/Sources/tasks.c **** 	unsigned portBASE_TYPE uxQueue;
1544:../FreeRTOS/Sources/tasks.c **** 	unsigned long ulTotalRunTimeDiv100;
1545:../FreeRTOS/Sources/tasks.c **** 
1546:../FreeRTOS/Sources/tasks.c **** 		/* This is a VERY costly function that should be used for debug only.
1547:../FreeRTOS/Sources/tasks.c **** 		It leaves interrupts disabled for a LONG time. */
1548:../FreeRTOS/Sources/tasks.c **** 
1549:../FreeRTOS/Sources/tasks.c **** 		vTaskSuspendAll();
1550:../FreeRTOS/Sources/tasks.c **** 		{
1551:../FreeRTOS/Sources/tasks.c **** 			#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
1552:../FreeRTOS/Sources/tasks.c **** 				portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
1553:../FreeRTOS/Sources/tasks.c **** 			#else
1554:../FreeRTOS/Sources/tasks.c **** 				ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
1555:../FreeRTOS/Sources/tasks.c **** 			#endif
1556:../FreeRTOS/Sources/tasks.c **** 
1557:../FreeRTOS/Sources/tasks.c **** 			/* Divide ulTotalRunTime by 100 to make the percentage caluclations
1558:../FreeRTOS/Sources/tasks.c **** 			simpler in the prvGenerateRunTimeStatsForTasksInList() function. */
1559:../FreeRTOS/Sources/tasks.c **** 			ulTotalRunTimeDiv100 = ulTotalRunTime / 100UL;
1560:../FreeRTOS/Sources/tasks.c **** 
1561:../FreeRTOS/Sources/tasks.c **** 			/* Run through all the lists that could potentially contain a TCB,
1562:../FreeRTOS/Sources/tasks.c **** 			generating a table of run timer percentages in the provided
1563:../FreeRTOS/Sources/tasks.c **** 			buffer. */
1564:../FreeRTOS/Sources/tasks.c **** 
1565:../FreeRTOS/Sources/tasks.c **** 			*pcWriteBuffer = ( signed char ) 0x00;
1566:../FreeRTOS/Sources/tasks.c **** 			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
1567:../FreeRTOS/Sources/tasks.c **** 
1568:../FreeRTOS/Sources/tasks.c **** 			uxQueue = uxTopUsedPriority + ( unsigned portBASE_TYPE ) 1U;
1569:../FreeRTOS/Sources/tasks.c **** 
1570:../FreeRTOS/Sources/tasks.c **** 			do
1571:../FreeRTOS/Sources/tasks.c **** 			{
1572:../FreeRTOS/Sources/tasks.c **** 				uxQueue--;
1573:../FreeRTOS/Sources/tasks.c **** 
1574:../FreeRTOS/Sources/tasks.c **** 				if( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) == pdFALSE )
1575:../FreeRTOS/Sources/tasks.c **** 				{
1576:../FreeRTOS/Sources/tasks.c **** 					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueu
1577:../FreeRTOS/Sources/tasks.c **** 				}
1578:../FreeRTOS/Sources/tasks.c **** 			}while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );
1579:../FreeRTOS/Sources/tasks.c **** 
1580:../FreeRTOS/Sources/tasks.c **** 			if( listLIST_IS_EMPTY( pxDelayedTaskList ) == pdFALSE )
1581:../FreeRTOS/Sources/tasks.c **** 			{
1582:../FreeRTOS/Sources/tasks.c **** 				prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, ulTotalRun
1583:../FreeRTOS/Sources/tasks.c **** 			}
1584:../FreeRTOS/Sources/tasks.c **** 
1585:../FreeRTOS/Sources/tasks.c **** 			if( listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) == pdFALSE )
1586:../FreeRTOS/Sources/tasks.c **** 			{
1587:../FreeRTOS/Sources/tasks.c **** 				prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) pxOverflowDelayedTaskList, ul
1588:../FreeRTOS/Sources/tasks.c **** 			}
1589:../FreeRTOS/Sources/tasks.c **** 
1590:../FreeRTOS/Sources/tasks.c **** 			#if ( INCLUDE_vTaskDelete == 1 )
1591:../FreeRTOS/Sources/tasks.c **** 			{
1592:../FreeRTOS/Sources/tasks.c **** 				if( listLIST_IS_EMPTY( &xTasksWaitingTermination ) == pdFALSE )
1593:../FreeRTOS/Sources/tasks.c **** 				{
1594:../FreeRTOS/Sources/tasks.c **** 					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, &xTasksWaitingTermination, ulTotalRunTim
1595:../FreeRTOS/Sources/tasks.c **** 				}
1596:../FreeRTOS/Sources/tasks.c **** 			}
1597:../FreeRTOS/Sources/tasks.c **** 			#endif
1598:../FreeRTOS/Sources/tasks.c **** 
1599:../FreeRTOS/Sources/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
1600:../FreeRTOS/Sources/tasks.c **** 			{
1601:../FreeRTOS/Sources/tasks.c **** 				if( listLIST_IS_EMPTY( &xSuspendedTaskList ) == pdFALSE )
1602:../FreeRTOS/Sources/tasks.c **** 				{
1603:../FreeRTOS/Sources/tasks.c **** 					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, &xSuspendedTaskList, ulTotalRunTimeDiv10
1604:../FreeRTOS/Sources/tasks.c **** 				}
1605:../FreeRTOS/Sources/tasks.c **** 			}
1606:../FreeRTOS/Sources/tasks.c **** 			#endif
1607:../FreeRTOS/Sources/tasks.c **** 		}
1608:../FreeRTOS/Sources/tasks.c **** 		xTaskResumeAll();
1609:../FreeRTOS/Sources/tasks.c **** 	}
1610:../FreeRTOS/Sources/tasks.c **** 
1611:../FreeRTOS/Sources/tasks.c **** #endif /* configGENERATE_RUN_TIME_STATS */
1612:../FreeRTOS/Sources/tasks.c **** /*----------------------------------------------------------*/
1613:../FreeRTOS/Sources/tasks.c **** 
1614:../FreeRTOS/Sources/tasks.c **** #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
1615:../FreeRTOS/Sources/tasks.c **** 
1616:../FreeRTOS/Sources/tasks.c **** 	xTaskHandle xTaskGetIdleTaskHandle( void )
1617:../FreeRTOS/Sources/tasks.c **** 	{
1618:../FreeRTOS/Sources/tasks.c **** 		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
1619:../FreeRTOS/Sources/tasks.c **** 		started, then xIdleTaskHandle will be NULL. */
1620:../FreeRTOS/Sources/tasks.c **** 		configASSERT( ( xIdleTaskHandle != NULL ) );
1621:../FreeRTOS/Sources/tasks.c **** 		return xIdleTaskHandle;
1622:../FreeRTOS/Sources/tasks.c **** 	}
1623:../FreeRTOS/Sources/tasks.c **** 
1624:../FreeRTOS/Sources/tasks.c **** #endif /* INCLUDE_xTaskGetIdleTaskHandle */
1625:../FreeRTOS/Sources/tasks.c **** /*----------------------------------------------------------*/
1626:../FreeRTOS/Sources/tasks.c **** 
1627:../FreeRTOS/Sources/tasks.c **** /* This conditional compilation should use inequality to 0, not equality to 1.
1628:../FreeRTOS/Sources/tasks.c **** This is to ensure vTaskStepTick() is available when user defined low power mode
1629:../FreeRTOS/Sources/tasks.c **** implementations require configUSE_TICKLESS_IDLE to be set to a value other than
1630:../FreeRTOS/Sources/tasks.c **** 1. */
1631:../FreeRTOS/Sources/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
1632:../FreeRTOS/Sources/tasks.c **** 
1633:../FreeRTOS/Sources/tasks.c **** 	void vTaskStepTick( portTickType xTicksToJump )
1634:../FreeRTOS/Sources/tasks.c **** 	{
1635:../FreeRTOS/Sources/tasks.c **** 		configASSERT( ( xTickCount + xTicksToJump ) <= xNextTaskUnblockTime );
1636:../FreeRTOS/Sources/tasks.c **** 		xTickCount += xTicksToJump;
1637:../FreeRTOS/Sources/tasks.c **** 	}
1638:../FreeRTOS/Sources/tasks.c **** 
1639:../FreeRTOS/Sources/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
1640:../FreeRTOS/Sources/tasks.c **** /*----------------------------------------------------------*/
1641:../FreeRTOS/Sources/tasks.c **** 
1642:../FreeRTOS/Sources/tasks.c **** void vTaskIncrementTick( void )
1643:../FreeRTOS/Sources/tasks.c **** {
 1884              		.loc 1 1643 0
 1885              		.cfi_startproc
 1886              		@ args = 0, pretend = 0, frame = 16
 1887              		@ frame_needed = 1, uses_anonymous_args = 0
 1888 0000 80B5     		push	{r7, lr}
 1889              	.LCFI48:
 1890              		.cfi_def_cfa_offset 8
 1891              		.cfi_offset 7, -8
 1892              		.cfi_offset 14, -4
 1893 0002 84B0     		sub	sp, sp, #16
 1894              	.LCFI49:
 1895              		.cfi_def_cfa_offset 24
 1896 0004 00AF     		add	r7, sp, #0
 1897              	.LCFI50:
 1898              		.cfi_def_cfa_register 7
1644:../FreeRTOS/Sources/tasks.c **** tskTCB * pxTCB;
1645:../FreeRTOS/Sources/tasks.c **** 
1646:../FreeRTOS/Sources/tasks.c **** 	/* Called by the portable layer each time a tick interrupt occurs.
1647:../FreeRTOS/Sources/tasks.c **** 	Increments the tick then checks to see if the new tick value will cause any
1648:../FreeRTOS/Sources/tasks.c **** 	tasks to be unblocked. */
1649:../FreeRTOS/Sources/tasks.c **** 	traceTASK_INCREMENT_TICK( xTickCount );
1650:../FreeRTOS/Sources/tasks.c **** 	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 1899              		.loc 1 1650 0
 1900 0006 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 1901 000a C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 1902 000e 1B68     		ldr	r3, [r3, #0]
 1903 0010 002B     		cmp	r3, #0
 1904 0012 40F0CA80 		bne	.L107
1651:../FreeRTOS/Sources/tasks.c **** 	{
1652:../FreeRTOS/Sources/tasks.c **** 		++xTickCount;
 1905              		.loc 1 1652 0
 1906 0016 40F20003 		movw	r3, #:lower16:xTickCount
 1907 001a C0F20003 		movt	r3, #:upper16:xTickCount
 1908 001e 1B68     		ldr	r3, [r3, #0]
 1909 0020 03F10102 		add	r2, r3, #1
 1910 0024 40F20003 		movw	r3, #:lower16:xTickCount
 1911 0028 C0F20003 		movt	r3, #:upper16:xTickCount
 1912 002c 1A60     		str	r2, [r3, #0]
1653:../FreeRTOS/Sources/tasks.c **** 		if( xTickCount == ( portTickType ) 0U )
 1913              		.loc 1 1653 0
 1914 002e 40F20003 		movw	r3, #:lower16:xTickCount
 1915 0032 C0F20003 		movt	r3, #:upper16:xTickCount
 1916 0036 1B68     		ldr	r3, [r3, #0]
 1917 0038 002B     		cmp	r3, #0
 1918 003a 4BD1     		bne	.L108
 1919              	.LBB4:
1654:../FreeRTOS/Sources/tasks.c **** 		{
1655:../FreeRTOS/Sources/tasks.c **** 			xList *pxTemp;
1656:../FreeRTOS/Sources/tasks.c **** 
1657:../FreeRTOS/Sources/tasks.c **** 			/* Tick count has overflowed so we need to swap the delay lists.
1658:../FreeRTOS/Sources/tasks.c **** 			If there are any items in pxDelayedTaskList here then there is
1659:../FreeRTOS/Sources/tasks.c **** 			an error! */
1660:../FreeRTOS/Sources/tasks.c **** 			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
 1920              		.loc 1 1660 0
 1921 003c 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 1922 0040 C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 1923 0044 1B68     		ldr	r3, [r3, #0]
 1924 0046 1B68     		ldr	r3, [r3, #0]
 1925 0048 002B     		cmp	r3, #0
 1926 004a 02D0     		beq	.L109
 1927              		.loc 1 1660 0 is_stmt 0 discriminator 1
 1928 004c FFF7FEFF 		bl	ulPortSetInterruptMask
 1929              	.L110:
 1930              		.loc 1 1660 0 discriminator 2
 1931 0050 FEE7     		b	.L110
 1932              	.L109:
1661:../FreeRTOS/Sources/tasks.c **** 
1662:../FreeRTOS/Sources/tasks.c **** 			pxTemp = pxDelayedTaskList;
 1933              		.loc 1 1662 0 is_stmt 1
 1934 0052 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 1935 0056 C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 1936 005a 1B68     		ldr	r3, [r3, #0]
 1937 005c FB60     		str	r3, [r7, #12]
1663:../FreeRTOS/Sources/tasks.c **** 			pxDelayedTaskList = pxOverflowDelayedTaskList;
 1938              		.loc 1 1663 0
 1939 005e 40F20003 		movw	r3, #:lower16:pxOverflowDelayedTaskList
 1940 0062 C0F20003 		movt	r3, #:upper16:pxOverflowDelayedTaskList
 1941 0066 1A68     		ldr	r2, [r3, #0]
 1942 0068 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 1943 006c C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 1944 0070 1A60     		str	r2, [r3, #0]
1664:../FreeRTOS/Sources/tasks.c **** 			pxOverflowDelayedTaskList = pxTemp;
 1945              		.loc 1 1664 0
 1946 0072 40F20003 		movw	r3, #:lower16:pxOverflowDelayedTaskList
 1947 0076 C0F20003 		movt	r3, #:upper16:pxOverflowDelayedTaskList
 1948 007a FA68     		ldr	r2, [r7, #12]
 1949 007c 1A60     		str	r2, [r3, #0]
1665:../FreeRTOS/Sources/tasks.c **** 			xNumOfOverflows++;
 1950              		.loc 1 1665 0
 1951 007e 40F20003 		movw	r3, #:lower16:xNumOfOverflows
 1952 0082 C0F20003 		movt	r3, #:upper16:xNumOfOverflows
 1953 0086 1B68     		ldr	r3, [r3, #0]
 1954 0088 03F10102 		add	r2, r3, #1
 1955 008c 40F20003 		movw	r3, #:lower16:xNumOfOverflows
 1956 0090 C0F20003 		movt	r3, #:upper16:xNumOfOverflows
 1957 0094 1A60     		str	r2, [r3, #0]
1666:../FreeRTOS/Sources/tasks.c **** 
1667:../FreeRTOS/Sources/tasks.c **** 			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 1958              		.loc 1 1667 0
 1959 0096 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 1960 009a C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 1961 009e 1B68     		ldr	r3, [r3, #0]
 1962 00a0 1B68     		ldr	r3, [r3, #0]
 1963 00a2 002B     		cmp	r3, #0
 1964 00a4 07D1     		bne	.L111
1668:../FreeRTOS/Sources/tasks.c **** 			{
1669:../FreeRTOS/Sources/tasks.c **** 				/* The new current delayed list is empty.  Set
1670:../FreeRTOS/Sources/tasks.c **** 				xNextTaskUnblockTime to the maximum possible value so it is
1671:../FreeRTOS/Sources/tasks.c **** 				extremely unlikely that the
1672:../FreeRTOS/Sources/tasks.c **** 				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
1673:../FreeRTOS/Sources/tasks.c **** 				there is an item in the delayed list. */
1674:../FreeRTOS/Sources/tasks.c **** 				xNextTaskUnblockTime = portMAX_DELAY;
 1965              		.loc 1 1674 0
 1966 00a6 40F20003 		movw	r3, #:lower16:xNextTaskUnblockTime
 1967 00aa C0F20003 		movt	r3, #:upper16:xNextTaskUnblockTime
 1968 00ae 4FF0FF32 		mov	r2, #-1
 1969 00b2 1A60     		str	r2, [r3, #0]
 1970 00b4 0EE0     		b	.L108
 1971              	.L111:
1675:../FreeRTOS/Sources/tasks.c **** 			}
1676:../FreeRTOS/Sources/tasks.c **** 			else
1677:../FreeRTOS/Sources/tasks.c **** 			{
1678:../FreeRTOS/Sources/tasks.c **** 				/* The new current delayed list is not empty, get the value of
1679:../FreeRTOS/Sources/tasks.c **** 				the item at the head of the delayed list.  This is the time at
1680:../FreeRTOS/Sources/tasks.c **** 				which the task at the head of the delayed list should be removed
1681:../FreeRTOS/Sources/tasks.c **** 				from the Blocked state. */
1682:../FreeRTOS/Sources/tasks.c **** 				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 1972              		.loc 1 1682 0
 1973 00b6 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 1974 00ba C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 1975 00be 1B68     		ldr	r3, [r3, #0]
 1976 00c0 DB68     		ldr	r3, [r3, #12]
 1977 00c2 DB68     		ldr	r3, [r3, #12]
 1978 00c4 BB60     		str	r3, [r7, #8]
1683:../FreeRTOS/Sources/tasks.c **** 				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
 1979              		.loc 1 1683 0
 1980 00c6 BB68     		ldr	r3, [r7, #8]
 1981 00c8 5A68     		ldr	r2, [r3, #4]
 1982 00ca 40F20003 		movw	r3, #:lower16:xNextTaskUnblockTime
 1983 00ce C0F20003 		movt	r3, #:upper16:xNextTaskUnblockTime
 1984 00d2 1A60     		str	r2, [r3, #0]
 1985              	.L108:
 1986              	.LBE4:
 1987              	.LBB5:
1684:../FreeRTOS/Sources/tasks.c **** 			}
1685:../FreeRTOS/Sources/tasks.c **** 		}
1686:../FreeRTOS/Sources/tasks.c **** 
1687:../FreeRTOS/Sources/tasks.c **** 		/* See if this tick has made a timeout expire. */
1688:../FreeRTOS/Sources/tasks.c **** 		prvCheckDelayedTasks();
 1988              		.loc 1 1688 0
 1989 00d4 40F20003 		movw	r3, #:lower16:xTickCount
 1990 00d8 C0F20003 		movt	r3, #:upper16:xTickCount
 1991 00dc 1A68     		ldr	r2, [r3, #0]
 1992 00de 40F20003 		movw	r3, #:lower16:xNextTaskUnblockTime
 1993 00e2 C0F20003 		movt	r3, #:upper16:xNextTaskUnblockTime
 1994 00e6 1B68     		ldr	r3, [r3, #0]
 1995 00e8 9A42     		cmp	r2, r3
 1996 00ea 6AD3     		bcc	.L106
 1997              	.L117:
 1998              		.loc 1 1688 0 is_stmt 0 discriminator 1
 1999 00ec 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 2000 00f0 C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 2001 00f4 1B68     		ldr	r3, [r3, #0]
 2002 00f6 1B68     		ldr	r3, [r3, #0]
 2003 00f8 002B     		cmp	r3, #0
 2004 00fa 07D1     		bne	.L113
 2005              		.loc 1 1688 0 discriminator 2
 2006 00fc 40F20003 		movw	r3, #:lower16:xNextTaskUnblockTime
 2007 0100 C0F20003 		movt	r3, #:upper16:xNextTaskUnblockTime
 2008 0104 4FF0FF32 		mov	r2, #-1
 2009 0108 1A60     		str	r2, [r3, #0]
 2010 010a 5AE0     		b	.L106
 2011              	.L113:
 2012              		.loc 1 1688 0 discriminator 3
 2013 010c 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 2014 0110 C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 2015 0114 1B68     		ldr	r3, [r3, #0]
 2016 0116 DB68     		ldr	r3, [r3, #12]
 2017 0118 DB68     		ldr	r3, [r3, #12]
 2018 011a BB60     		str	r3, [r7, #8]
 2019 011c BB68     		ldr	r3, [r7, #8]
 2020 011e 5B68     		ldr	r3, [r3, #4]
 2021 0120 7B60     		str	r3, [r7, #4]
 2022 0122 40F20003 		movw	r3, #:lower16:xTickCount
 2023 0126 C0F20003 		movt	r3, #:upper16:xTickCount
 2024 012a 1A68     		ldr	r2, [r3, #0]
 2025 012c 7B68     		ldr	r3, [r7, #4]
 2026 012e 9A42     		cmp	r2, r3
 2027 0130 06D2     		bcs	.L114
 2028              		.loc 1 1688 0 discriminator 4
 2029 0132 40F20003 		movw	r3, #:lower16:xNextTaskUnblockTime
 2030 0136 C0F20003 		movt	r3, #:upper16:xNextTaskUnblockTime
 2031 013a 7A68     		ldr	r2, [r7, #4]
 2032 013c 1A60     		str	r2, [r3, #0]
 2033 013e 40E0     		b	.L106
 2034              	.L114:
 2035              		.loc 1 1688 0 discriminator 5
 2036 0140 BB68     		ldr	r3, [r7, #8]
 2037 0142 03F10403 		add	r3, r3, #4
 2038 0146 1846     		mov	r0, r3
 2039 0148 FFF7FEFF 		bl	uxListRemove
 2040 014c BB68     		ldr	r3, [r7, #8]
 2041 014e 9B6A     		ldr	r3, [r3, #40]
 2042 0150 002B     		cmp	r3, #0
 2043 0152 05D0     		beq	.L115
 2044              		.loc 1 1688 0 discriminator 6
 2045 0154 BB68     		ldr	r3, [r7, #8]
 2046 0156 03F11803 		add	r3, r3, #24
 2047 015a 1846     		mov	r0, r3
 2048 015c FFF7FEFF 		bl	uxListRemove
 2049              	.L115:
 2050              		.loc 1 1688 0 discriminator 7
 2051 0160 BB68     		ldr	r3, [r7, #8]
 2052 0162 DA6A     		ldr	r2, [r3, #44]
 2053 0164 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 2054 0168 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 2055 016c 1B68     		ldr	r3, [r3, #0]
 2056 016e 9A42     		cmp	r2, r3
 2057 0170 06D9     		bls	.L116
 2058              		.loc 1 1688 0 discriminator 8
 2059 0172 BB68     		ldr	r3, [r7, #8]
 2060 0174 DA6A     		ldr	r2, [r3, #44]
 2061 0176 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 2062 017a C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 2063 017e 1A60     		str	r2, [r3, #0]
 2064              	.L116:
 2065              		.loc 1 1688 0 discriminator 9
 2066 0180 BB68     		ldr	r3, [r7, #8]
 2067 0182 DA6A     		ldr	r2, [r3, #44]
 2068 0184 1346     		mov	r3, r2
 2069 0186 4FEA8303 		lsl	r3, r3, #2
 2070 018a 9B18     		adds	r3, r3, r2
 2071 018c 4FEA8303 		lsl	r3, r3, #2
 2072 0190 40F20002 		movw	r2, #:lower16:pxReadyTasksLists
 2073 0194 C0F20002 		movt	r2, #:upper16:pxReadyTasksLists
 2074 0198 9A18     		adds	r2, r3, r2
 2075 019a BB68     		ldr	r3, [r7, #8]
 2076 019c 03F10403 		add	r3, r3, #4
 2077 01a0 1046     		mov	r0, r2
 2078 01a2 1946     		mov	r1, r3
 2079 01a4 FFF7FEFF 		bl	vListInsertEnd
 2080 01a8 A0E7     		b	.L117
 2081              	.L107:
 2082              	.LBE5:
1689:../FreeRTOS/Sources/tasks.c **** 	}
1690:../FreeRTOS/Sources/tasks.c **** 	else
1691:../FreeRTOS/Sources/tasks.c **** 	{
1692:../FreeRTOS/Sources/tasks.c **** 		++uxMissedTicks;
 2083              		.loc 1 1692 0 is_stmt 1
 2084 01aa 40F20003 		movw	r3, #:lower16:uxMissedTicks
 2085 01ae C0F20003 		movt	r3, #:upper16:uxMissedTicks
 2086 01b2 1B68     		ldr	r3, [r3, #0]
 2087 01b4 03F10102 		add	r2, r3, #1
 2088 01b8 40F20003 		movw	r3, #:lower16:uxMissedTicks
 2089 01bc C0F20003 		movt	r3, #:upper16:uxMissedTicks
 2090 01c0 1A60     		str	r2, [r3, #0]
 2091              	.L106:
1693:../FreeRTOS/Sources/tasks.c **** 
1694:../FreeRTOS/Sources/tasks.c **** 		/* The tick hook gets called at regular intervals, even if the
1695:../FreeRTOS/Sources/tasks.c **** 		scheduler is locked. */
1696:../FreeRTOS/Sources/tasks.c **** 		#if ( configUSE_TICK_HOOK == 1 )
1697:../FreeRTOS/Sources/tasks.c **** 		{
1698:../FreeRTOS/Sources/tasks.c **** 			vApplicationTickHook();
1699:../FreeRTOS/Sources/tasks.c **** 		}
1700:../FreeRTOS/Sources/tasks.c **** 		#endif
1701:../FreeRTOS/Sources/tasks.c **** 	}
1702:../FreeRTOS/Sources/tasks.c **** 
1703:../FreeRTOS/Sources/tasks.c **** 	#if ( configUSE_TICK_HOOK == 1 )
1704:../FreeRTOS/Sources/tasks.c **** 	{
1705:../FreeRTOS/Sources/tasks.c **** 		/* Guard against the tick hook being called when the missed tick
1706:../FreeRTOS/Sources/tasks.c **** 		count is being unwound (when the scheduler is being unlocked. */
1707:../FreeRTOS/Sources/tasks.c **** 		if( uxMissedTicks == ( unsigned portBASE_TYPE ) 0U )
1708:../FreeRTOS/Sources/tasks.c **** 		{
1709:../FreeRTOS/Sources/tasks.c **** 			vApplicationTickHook();
1710:../FreeRTOS/Sources/tasks.c **** 		}
1711:../FreeRTOS/Sources/tasks.c **** 	}
1712:../FreeRTOS/Sources/tasks.c **** 	#endif /* configUSE_TICK_HOOK */
1713:../FreeRTOS/Sources/tasks.c **** }
 2092              		.loc 1 1713 0
 2093 01c2 07F11007 		add	r7, r7, #16
 2094 01c6 BD46     		mov	sp, r7
 2095 01c8 80BD     		pop	{r7, pc}
 2096              		.cfi_endproc
 2097              	.LFE17:
 2099 01ca 00BF     		.section	.text.vTaskSwitchContext,"ax",%progbits
 2100              		.align	2
 2101              		.global	vTaskSwitchContext
 2102              		.thumb
 2103              		.thumb_func
 2105              	vTaskSwitchContext:
 2106              	.LFB18:
1714:../FreeRTOS/Sources/tasks.c **** /*-----------------------------------------------------------*/
1715:../FreeRTOS/Sources/tasks.c **** 
1716:../FreeRTOS/Sources/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1717:../FreeRTOS/Sources/tasks.c **** 
1718:../FreeRTOS/Sources/tasks.c **** 	void vTaskSetApplicationTaskTag( xTaskHandle xTask, pdTASK_HOOK_CODE pxHookFunction )
1719:../FreeRTOS/Sources/tasks.c **** 	{
1720:../FreeRTOS/Sources/tasks.c **** 	tskTCB *xTCB;
1721:../FreeRTOS/Sources/tasks.c **** 
1722:../FreeRTOS/Sources/tasks.c **** 		/* If xTask is NULL then we are setting our own task hook. */
1723:../FreeRTOS/Sources/tasks.c **** 		if( xTask == NULL )
1724:../FreeRTOS/Sources/tasks.c **** 		{
1725:../FreeRTOS/Sources/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
1726:../FreeRTOS/Sources/tasks.c **** 		}
1727:../FreeRTOS/Sources/tasks.c **** 		else
1728:../FreeRTOS/Sources/tasks.c **** 		{
1729:../FreeRTOS/Sources/tasks.c **** 			xTCB = ( tskTCB * ) xTask;
1730:../FreeRTOS/Sources/tasks.c **** 		}
1731:../FreeRTOS/Sources/tasks.c **** 
1732:../FreeRTOS/Sources/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
1733:../FreeRTOS/Sources/tasks.c **** 		the value can be accessed from an interrupt. */
1734:../FreeRTOS/Sources/tasks.c **** 		taskENTER_CRITICAL();
1735:../FreeRTOS/Sources/tasks.c **** 			xTCB->pxTaskTag = pxHookFunction;
1736:../FreeRTOS/Sources/tasks.c **** 		taskEXIT_CRITICAL();
1737:../FreeRTOS/Sources/tasks.c **** 	}
1738:../FreeRTOS/Sources/tasks.c **** 
1739:../FreeRTOS/Sources/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
1740:../FreeRTOS/Sources/tasks.c **** /*-----------------------------------------------------------*/
1741:../FreeRTOS/Sources/tasks.c **** 
1742:../FreeRTOS/Sources/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1743:../FreeRTOS/Sources/tasks.c **** 
1744:../FreeRTOS/Sources/tasks.c **** 	pdTASK_HOOK_CODE xTaskGetApplicationTaskTag( xTaskHandle xTask )
1745:../FreeRTOS/Sources/tasks.c **** 	{
1746:../FreeRTOS/Sources/tasks.c **** 	tskTCB *xTCB;
1747:../FreeRTOS/Sources/tasks.c **** 	pdTASK_HOOK_CODE xReturn;
1748:../FreeRTOS/Sources/tasks.c **** 
1749:../FreeRTOS/Sources/tasks.c **** 		/* If xTask is NULL then we are setting our own task hook. */
1750:../FreeRTOS/Sources/tasks.c **** 		if( xTask == NULL )
1751:../FreeRTOS/Sources/tasks.c **** 		{
1752:../FreeRTOS/Sources/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
1753:../FreeRTOS/Sources/tasks.c **** 		}
1754:../FreeRTOS/Sources/tasks.c **** 		else
1755:../FreeRTOS/Sources/tasks.c **** 		{
1756:../FreeRTOS/Sources/tasks.c **** 			xTCB = ( tskTCB * ) xTask;
1757:../FreeRTOS/Sources/tasks.c **** 		}
1758:../FreeRTOS/Sources/tasks.c **** 
1759:../FreeRTOS/Sources/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
1760:../FreeRTOS/Sources/tasks.c **** 		the value can be accessed from an interrupt. */
1761:../FreeRTOS/Sources/tasks.c **** 		taskENTER_CRITICAL();
1762:../FreeRTOS/Sources/tasks.c **** 			xReturn = xTCB->pxTaskTag;
1763:../FreeRTOS/Sources/tasks.c **** 		taskEXIT_CRITICAL();
1764:../FreeRTOS/Sources/tasks.c **** 
1765:../FreeRTOS/Sources/tasks.c **** 		return xReturn;
1766:../FreeRTOS/Sources/tasks.c **** 	}
1767:../FreeRTOS/Sources/tasks.c **** 
1768:../FreeRTOS/Sources/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
1769:../FreeRTOS/Sources/tasks.c **** /*-----------------------------------------------------------*/
1770:../FreeRTOS/Sources/tasks.c **** 
1771:../FreeRTOS/Sources/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1772:../FreeRTOS/Sources/tasks.c **** 
1773:../FreeRTOS/Sources/tasks.c **** 	portBASE_TYPE xTaskCallApplicationTaskHook( xTaskHandle xTask, void *pvParameter )
1774:../FreeRTOS/Sources/tasks.c **** 	{
1775:../FreeRTOS/Sources/tasks.c **** 	tskTCB *xTCB;
1776:../FreeRTOS/Sources/tasks.c **** 	portBASE_TYPE xReturn;
1777:../FreeRTOS/Sources/tasks.c **** 
1778:../FreeRTOS/Sources/tasks.c **** 		/* If xTask is NULL then we are calling our own task hook. */
1779:../FreeRTOS/Sources/tasks.c **** 		if( xTask == NULL )
1780:../FreeRTOS/Sources/tasks.c **** 		{
1781:../FreeRTOS/Sources/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
1782:../FreeRTOS/Sources/tasks.c **** 		}
1783:../FreeRTOS/Sources/tasks.c **** 		else
1784:../FreeRTOS/Sources/tasks.c **** 		{
1785:../FreeRTOS/Sources/tasks.c **** 			xTCB = ( tskTCB * ) xTask;
1786:../FreeRTOS/Sources/tasks.c **** 		}
1787:../FreeRTOS/Sources/tasks.c **** 
1788:../FreeRTOS/Sources/tasks.c **** 		if( xTCB->pxTaskTag != NULL )
1789:../FreeRTOS/Sources/tasks.c **** 		{
1790:../FreeRTOS/Sources/tasks.c **** 			xReturn = xTCB->pxTaskTag( pvParameter );
1791:../FreeRTOS/Sources/tasks.c **** 		}
1792:../FreeRTOS/Sources/tasks.c **** 		else
1793:../FreeRTOS/Sources/tasks.c **** 		{
1794:../FreeRTOS/Sources/tasks.c **** 			xReturn = pdFAIL;
1795:../FreeRTOS/Sources/tasks.c **** 		}
1796:../FreeRTOS/Sources/tasks.c **** 
1797:../FreeRTOS/Sources/tasks.c **** 		return xReturn;
1798:../FreeRTOS/Sources/tasks.c **** 	}
1799:../FreeRTOS/Sources/tasks.c **** 
1800:../FreeRTOS/Sources/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
1801:../FreeRTOS/Sources/tasks.c **** /*-----------------------------------------------------------*/
1802:../FreeRTOS/Sources/tasks.c **** 
1803:../FreeRTOS/Sources/tasks.c **** void vTaskSwitchContext( void )
1804:../FreeRTOS/Sources/tasks.c **** {
 2107              		.loc 1 1804 0
 2108              		.cfi_startproc
 2109              		@ args = 0, pretend = 0, frame = 8
 2110              		@ frame_needed = 1, uses_anonymous_args = 0
 2111 0000 80B5     		push	{r7, lr}
 2112              	.LCFI51:
 2113              		.cfi_def_cfa_offset 8
 2114              		.cfi_offset 7, -8
 2115              		.cfi_offset 14, -4
 2116 0002 82B0     		sub	sp, sp, #8
 2117              	.LCFI52:
 2118              		.cfi_def_cfa_offset 16
 2119 0004 00AF     		add	r7, sp, #0
 2120              	.LCFI53:
 2121              		.cfi_def_cfa_register 7
1805:../FreeRTOS/Sources/tasks.c **** 	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
 2122              		.loc 1 1805 0
 2123 0006 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 2124 000a C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 2125 000e 1B68     		ldr	r3, [r3, #0]
 2126 0010 002B     		cmp	r3, #0
 2127 0012 07D0     		beq	.L120
1806:../FreeRTOS/Sources/tasks.c **** 	{
1807:../FreeRTOS/Sources/tasks.c **** 		/* The scheduler is currently suspended - do not allow a context
1808:../FreeRTOS/Sources/tasks.c **** 		switch. */
1809:../FreeRTOS/Sources/tasks.c **** 		xMissedYield = pdTRUE;
 2128              		.loc 1 1809 0
 2129 0014 40F20003 		movw	r3, #:lower16:xMissedYield
 2130 0018 C0F20003 		movt	r3, #:upper16:xMissedYield
 2131 001c 4FF00102 		mov	r2, #1
 2132 0020 1A60     		str	r2, [r3, #0]
 2133 0022 93E0     		b	.L119
 2134              	.L120:
1810:../FreeRTOS/Sources/tasks.c **** 	}
1811:../FreeRTOS/Sources/tasks.c **** 	else
1812:../FreeRTOS/Sources/tasks.c **** 	{
1813:../FreeRTOS/Sources/tasks.c **** 		traceTASK_SWITCHED_OUT();
1814:../FreeRTOS/Sources/tasks.c **** 
1815:../FreeRTOS/Sources/tasks.c **** 		#if ( configGENERATE_RUN_TIME_STATS == 1 )
1816:../FreeRTOS/Sources/tasks.c **** 		{
1817:../FreeRTOS/Sources/tasks.c **** 				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
1818:../FreeRTOS/Sources/tasks.c **** 					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
1819:../FreeRTOS/Sources/tasks.c **** 				#else
1820:../FreeRTOS/Sources/tasks.c **** 					ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
1821:../FreeRTOS/Sources/tasks.c **** 				#endif
1822:../FreeRTOS/Sources/tasks.c **** 
1823:../FreeRTOS/Sources/tasks.c **** 				/* Add the amount of time the task has been running to the accumulated
1824:../FreeRTOS/Sources/tasks.c **** 				time so far.  The time the task started running was stored in
1825:../FreeRTOS/Sources/tasks.c **** 				ulTaskSwitchedInTime.  Note that there is no overflow protection here
1826:../FreeRTOS/Sources/tasks.c **** 				so count values are only valid until the timer overflows.  Generally
1827:../FreeRTOS/Sources/tasks.c **** 				this will be about 1 hour assuming a 1uS timer increment. */
1828:../FreeRTOS/Sources/tasks.c **** 				pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
1829:../FreeRTOS/Sources/tasks.c **** 				ulTaskSwitchedInTime = ulTotalRunTime;
1830:../FreeRTOS/Sources/tasks.c **** 		}
1831:../FreeRTOS/Sources/tasks.c **** 		#endif /* configGENERATE_RUN_TIME_STATS */
1832:../FreeRTOS/Sources/tasks.c **** 
1833:../FreeRTOS/Sources/tasks.c **** 		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
 2135              		.loc 1 1833 0
 2136 0024 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2137 0028 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2138 002c 1B68     		ldr	r3, [r3, #0]
 2139 002e 1A68     		ldr	r2, [r3, #0]
 2140 0030 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2141 0034 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2142 0038 1B68     		ldr	r3, [r3, #0]
 2143 003a 1B6B     		ldr	r3, [r3, #48]
 2144 003c 9A42     		cmp	r2, r3
 2145 003e 0FD8     		bhi	.L122
 2146              		.loc 1 1833 0 is_stmt 0 discriminator 1
 2147 0040 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2148 0044 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2149 0048 1A68     		ldr	r2, [r3, #0]
 2150 004a 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2151 004e C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2152 0052 1B68     		ldr	r3, [r3, #0]
 2153 0054 03F13403 		add	r3, r3, #52
 2154 0058 1046     		mov	r0, r2
 2155 005a 1946     		mov	r1, r3
 2156 005c FFF7FEFF 		bl	vApplicationStackOverflowHook
 2157              	.L122:
 2158              	.LBB6:
1834:../FreeRTOS/Sources/tasks.c **** 		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
 2159              		.loc 1 1834 0 is_stmt 1
 2160 0060 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2161 0064 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2162 0068 1B68     		ldr	r3, [r3, #0]
 2163 006a 1B6B     		ldr	r3, [r3, #48]
 2164 006c 1846     		mov	r0, r3
 2165 006e 40F20001 		movw	r1, #:lower16:ucExpectedStackBytes.5898
 2166 0072 C0F20001 		movt	r1, #:upper16:ucExpectedStackBytes.5898
 2167 0076 4FF01402 		mov	r2, #20
 2168 007a FFF7FEFF 		bl	memcmp
 2169 007e 0346     		mov	r3, r0
 2170 0080 002B     		cmp	r3, #0
 2171 0082 26D0     		beq	.L124
 2172              		.loc 1 1834 0 is_stmt 0 discriminator 1
 2173 0084 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2174 0088 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2175 008c 1A68     		ldr	r2, [r3, #0]
 2176 008e 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2177 0092 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2178 0096 1B68     		ldr	r3, [r3, #0]
 2179 0098 03F13403 		add	r3, r3, #52
 2180 009c 1046     		mov	r0, r2
 2181 009e 1946     		mov	r1, r3
 2182 00a0 FFF7FEFF 		bl	vApplicationStackOverflowHook
 2183              	.LBE6:
1835:../FreeRTOS/Sources/tasks.c **** 
1836:../FreeRTOS/Sources/tasks.c **** 		taskSELECT_HIGHEST_PRIORITY_TASK();
 2184              		.loc 1 1836 0 is_stmt 1 discriminator 1
 2185 00a4 15E0     		b	.L124
 2186              	.L127:
 2187              		.loc 1 1836 0 is_stmt 0 discriminator 5
 2188 00a6 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 2189 00aa C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 2190 00ae 1B68     		ldr	r3, [r3, #0]
 2191 00b0 002B     		cmp	r3, #0
 2192 00b2 02D1     		bne	.L125
 2193              		.loc 1 1836 0 discriminator 2
 2194 00b4 FFF7FEFF 		bl	ulPortSetInterruptMask
 2195              	.L126:
 2196              		.loc 1 1836 0 discriminator 4
 2197 00b8 FEE7     		b	.L126
 2198              	.L125:
 2199              		.loc 1 1836 0 discriminator 3
 2200 00ba 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 2201 00be C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 2202 00c2 1B68     		ldr	r3, [r3, #0]
 2203 00c4 03F1FF32 		add	r2, r3, #-1
 2204 00c8 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 2205 00cc C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 2206 00d0 1A60     		str	r2, [r3, #0]
 2207              	.L124:
 2208              		.loc 1 1836 0 discriminator 1
 2209 00d2 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 2210 00d6 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 2211 00da 1968     		ldr	r1, [r3, #0]
 2212 00dc 40F20002 		movw	r2, #:lower16:pxReadyTasksLists
 2213 00e0 C0F20002 		movt	r2, #:upper16:pxReadyTasksLists
 2214 00e4 0B46     		mov	r3, r1
 2215 00e6 4FEA8303 		lsl	r3, r3, #2
 2216 00ea 5B18     		adds	r3, r3, r1
 2217 00ec 4FEA8303 		lsl	r3, r3, #2
 2218 00f0 D318     		adds	r3, r2, r3
 2219 00f2 1B68     		ldr	r3, [r3, #0]
 2220 00f4 002B     		cmp	r3, #0
 2221 00f6 D6D0     		beq	.L127
 2222              	.LBB7:
 2223              		.loc 1 1836 0 discriminator 6
 2224 00f8 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 2225 00fc C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 2226 0100 1A68     		ldr	r2, [r3, #0]
 2227 0102 1346     		mov	r3, r2
 2228 0104 4FEA8303 		lsl	r3, r3, #2
 2229 0108 9B18     		adds	r3, r3, r2
 2230 010a 4FEA8303 		lsl	r3, r3, #2
 2231 010e 40F20002 		movw	r2, #:lower16:pxReadyTasksLists
 2232 0112 C0F20002 		movt	r2, #:upper16:pxReadyTasksLists
 2233 0116 9B18     		adds	r3, r3, r2
 2234 0118 7B60     		str	r3, [r7, #4]
 2235 011a 7B68     		ldr	r3, [r7, #4]
 2236 011c 5B68     		ldr	r3, [r3, #4]
 2237 011e 5A68     		ldr	r2, [r3, #4]
 2238 0120 7B68     		ldr	r3, [r7, #4]
 2239 0122 5A60     		str	r2, [r3, #4]
 2240 0124 7B68     		ldr	r3, [r7, #4]
 2241 0126 5A68     		ldr	r2, [r3, #4]
 2242 0128 7B68     		ldr	r3, [r7, #4]
 2243 012a 03F10803 		add	r3, r3, #8
 2244 012e 9A42     		cmp	r2, r3
 2245 0130 04D1     		bne	.L128
 2246              		.loc 1 1836 0 discriminator 7
 2247 0132 7B68     		ldr	r3, [r7, #4]
 2248 0134 5B68     		ldr	r3, [r3, #4]
 2249 0136 5A68     		ldr	r2, [r3, #4]
 2250 0138 7B68     		ldr	r3, [r7, #4]
 2251 013a 5A60     		str	r2, [r3, #4]
 2252              	.L128:
 2253              		.loc 1 1836 0 discriminator 8
 2254 013c 7B68     		ldr	r3, [r7, #4]
 2255 013e 5B68     		ldr	r3, [r3, #4]
 2256 0140 DA68     		ldr	r2, [r3, #12]
 2257 0142 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2258 0146 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2259 014a 1A60     		str	r2, [r3, #0]
 2260              	.L119:
 2261              	.LBE7:
1837:../FreeRTOS/Sources/tasks.c **** 
1838:../FreeRTOS/Sources/tasks.c **** 		traceTASK_SWITCHED_IN();
1839:../FreeRTOS/Sources/tasks.c **** 	}
1840:../FreeRTOS/Sources/tasks.c **** }
 2262              		.loc 1 1840 0 is_stmt 1
 2263 014c 07F10807 		add	r7, r7, #8
 2264 0150 BD46     		mov	sp, r7
 2265 0152 80BD     		pop	{r7, pc}
 2266              		.cfi_endproc
 2267              	.LFE18:
 2269              		.section	.text.vTaskPlaceOnEventList,"ax",%progbits
 2270              		.align	2
 2271              		.global	vTaskPlaceOnEventList
 2272              		.thumb
 2273              		.thumb_func
 2275              	vTaskPlaceOnEventList:
 2276              	.LFB19:
1841:../FreeRTOS/Sources/tasks.c **** /*-----------------------------------------------------------*/
1842:../FreeRTOS/Sources/tasks.c **** 
1843:../FreeRTOS/Sources/tasks.c **** void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
1844:../FreeRTOS/Sources/tasks.c **** {
 2277              		.loc 1 1844 0
 2278              		.cfi_startproc
 2279              		@ args = 0, pretend = 0, frame = 16
 2280              		@ frame_needed = 1, uses_anonymous_args = 0
 2281 0000 80B5     		push	{r7, lr}
 2282              	.LCFI54:
 2283              		.cfi_def_cfa_offset 8
 2284              		.cfi_offset 7, -8
 2285              		.cfi_offset 14, -4
 2286 0002 84B0     		sub	sp, sp, #16
 2287              	.LCFI55:
 2288              		.cfi_def_cfa_offset 24
 2289 0004 00AF     		add	r7, sp, #0
 2290              	.LCFI56:
 2291              		.cfi_def_cfa_register 7
 2292 0006 7860     		str	r0, [r7, #4]
 2293 0008 3960     		str	r1, [r7, #0]
1845:../FreeRTOS/Sources/tasks.c **** portTickType xTimeToWake;
1846:../FreeRTOS/Sources/tasks.c **** 
1847:../FreeRTOS/Sources/tasks.c **** 	configASSERT( pxEventList );
 2294              		.loc 1 1847 0
 2295 000a 7B68     		ldr	r3, [r7, #4]
 2296 000c 002B     		cmp	r3, #0
 2297 000e 02D1     		bne	.L130
 2298              		.loc 1 1847 0 is_stmt 0 discriminator 1
 2299 0010 FFF7FEFF 		bl	ulPortSetInterruptMask
 2300              	.L131:
 2301              		.loc 1 1847 0 discriminator 2
 2302 0014 FEE7     		b	.L131
 2303              	.L130:
1848:../FreeRTOS/Sources/tasks.c **** 
1849:../FreeRTOS/Sources/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
1850:../FreeRTOS/Sources/tasks.c **** 	SCHEDULER SUSPENDED. */
1851:../FreeRTOS/Sources/tasks.c **** 
1852:../FreeRTOS/Sources/tasks.c **** 	/* Place the event list item of the TCB in the appropriate event list.
1853:../FreeRTOS/Sources/tasks.c **** 	This is placed in the list in priority order so the highest priority task
1854:../FreeRTOS/Sources/tasks.c **** 	is the first to be woken by the event. */
1855:../FreeRTOS/Sources/tasks.c **** 	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
 2304              		.loc 1 1855 0 is_stmt 1
 2305 0016 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2306 001a C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2307 001e 1B68     		ldr	r3, [r3, #0]
 2308 0020 03F11803 		add	r3, r3, #24
 2309 0024 7868     		ldr	r0, [r7, #4]
 2310 0026 1946     		mov	r1, r3
 2311 0028 FFF7FEFF 		bl	vListInsert
1856:../FreeRTOS/Sources/tasks.c **** 
1857:../FreeRTOS/Sources/tasks.c **** 	/* We must remove ourselves from the ready list before adding ourselves
1858:../FreeRTOS/Sources/tasks.c **** 	to the blocked list as the same list item is used for both lists.  We have
1859:../FreeRTOS/Sources/tasks.c **** 	exclusive access to the ready lists as the scheduler is locked. */
1860:../FreeRTOS/Sources/tasks.c **** 	if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
 2312              		.loc 1 1860 0
 2313 002c 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2314 0030 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2315 0034 1B68     		ldr	r3, [r3, #0]
 2316 0036 03F10403 		add	r3, r3, #4
 2317 003a 1846     		mov	r0, r3
 2318 003c FFF7FEFF 		bl	uxListRemove
1861:../FreeRTOS/Sources/tasks.c **** 	{
1862:../FreeRTOS/Sources/tasks.c **** 		/* The current task must be in a ready list, so there is no need to
1863:../FreeRTOS/Sources/tasks.c **** 		check, and the port reset macro can be called directly. */
1864:../FreeRTOS/Sources/tasks.c **** 		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
1865:../FreeRTOS/Sources/tasks.c **** 	}
1866:../FreeRTOS/Sources/tasks.c **** 
1867:../FreeRTOS/Sources/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
1868:../FreeRTOS/Sources/tasks.c **** 	{
1869:../FreeRTOS/Sources/tasks.c **** 		if( xTicksToWait == portMAX_DELAY )
 2319              		.loc 1 1869 0
 2320 0040 3B68     		ldr	r3, [r7, #0]
 2321 0042 B3F1FF3F 		cmp	r3, #-1
 2322 0046 0ED1     		bne	.L132
1870:../FreeRTOS/Sources/tasks.c **** 		{
1871:../FreeRTOS/Sources/tasks.c **** 			/* Add ourselves to the suspended task list instead of a delayed task
1872:../FreeRTOS/Sources/tasks.c **** 			list to ensure we are not woken by a timing event.  We will block
1873:../FreeRTOS/Sources/tasks.c **** 			indefinitely. */
1874:../FreeRTOS/Sources/tasks.c **** 			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListIt
 2323              		.loc 1 1874 0
 2324 0048 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2325 004c C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2326 0050 1B68     		ldr	r3, [r3, #0]
 2327 0052 03F10403 		add	r3, r3, #4
 2328 0056 40F20000 		movw	r0, #:lower16:xSuspendedTaskList
 2329 005a C0F20000 		movt	r0, #:upper16:xSuspendedTaskList
 2330 005e 1946     		mov	r1, r3
 2331 0060 FFF7FEFF 		bl	vListInsertEnd
 2332 0064 0AE0     		b	.L129
 2333              	.L132:
1875:../FreeRTOS/Sources/tasks.c **** 		}
1876:../FreeRTOS/Sources/tasks.c **** 		else
1877:../FreeRTOS/Sources/tasks.c **** 		{
1878:../FreeRTOS/Sources/tasks.c **** 			/* Calculate the time at which the task should be woken if the event does
1879:../FreeRTOS/Sources/tasks.c **** 			not occur.  This may overflow but this doesn't matter. */
1880:../FreeRTOS/Sources/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
 2334              		.loc 1 1880 0
 2335 0066 40F20003 		movw	r3, #:lower16:xTickCount
 2336 006a C0F20003 		movt	r3, #:upper16:xTickCount
 2337 006e 1A68     		ldr	r2, [r3, #0]
 2338 0070 3B68     		ldr	r3, [r7, #0]
 2339 0072 D318     		adds	r3, r2, r3
 2340 0074 FB60     		str	r3, [r7, #12]
1881:../FreeRTOS/Sources/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
 2341              		.loc 1 1881 0
 2342 0076 F868     		ldr	r0, [r7, #12]
 2343 0078 FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
 2344              	.L129:
1882:../FreeRTOS/Sources/tasks.c **** 		}
1883:../FreeRTOS/Sources/tasks.c **** 	}
1884:../FreeRTOS/Sources/tasks.c **** 	#else /* INCLUDE_vTaskSuspend */
1885:../FreeRTOS/Sources/tasks.c **** 	{
1886:../FreeRTOS/Sources/tasks.c **** 			/* Calculate the time at which the task should be woken if the event does
1887:../FreeRTOS/Sources/tasks.c **** 			not occur.  This may overflow but this doesn't matter. */
1888:../FreeRTOS/Sources/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
1889:../FreeRTOS/Sources/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
1890:../FreeRTOS/Sources/tasks.c **** 	}
1891:../FreeRTOS/Sources/tasks.c **** 	#endif /* INCLUDE_vTaskSuspend */
1892:../FreeRTOS/Sources/tasks.c **** }
 2345              		.loc 1 1892 0
 2346 007c 07F11007 		add	r7, r7, #16
 2347 0080 BD46     		mov	sp, r7
 2348 0082 80BD     		pop	{r7, pc}
 2349              		.cfi_endproc
 2350              	.LFE19:
 2352              		.section	.text.vTaskPlaceOnEventListRestricted,"ax",%progbits
 2353              		.align	2
 2354              		.global	vTaskPlaceOnEventListRestricted
 2355              		.thumb
 2356              		.thumb_func
 2358              	vTaskPlaceOnEventListRestricted:
 2359              	.LFB20:
1893:../FreeRTOS/Sources/tasks.c **** /*-----------------------------------------------------------*/
1894:../FreeRTOS/Sources/tasks.c **** 
1895:../FreeRTOS/Sources/tasks.c **** #if configUSE_TIMERS == 1
1896:../FreeRTOS/Sources/tasks.c **** 
1897:../FreeRTOS/Sources/tasks.c **** 	void vTaskPlaceOnEventListRestricted( const xList * const pxEventList, portTickType xTicksToWait )
1898:../FreeRTOS/Sources/tasks.c **** 	{
 2360              		.loc 1 1898 0
 2361              		.cfi_startproc
 2362              		@ args = 0, pretend = 0, frame = 16
 2363              		@ frame_needed = 1, uses_anonymous_args = 0
 2364 0000 80B5     		push	{r7, lr}
 2365              	.LCFI57:
 2366              		.cfi_def_cfa_offset 8
 2367              		.cfi_offset 7, -8
 2368              		.cfi_offset 14, -4
 2369 0002 84B0     		sub	sp, sp, #16
 2370              	.LCFI58:
 2371              		.cfi_def_cfa_offset 24
 2372 0004 00AF     		add	r7, sp, #0
 2373              	.LCFI59:
 2374              		.cfi_def_cfa_register 7
 2375 0006 7860     		str	r0, [r7, #4]
 2376 0008 3960     		str	r1, [r7, #0]
1899:../FreeRTOS/Sources/tasks.c **** 	portTickType xTimeToWake;
1900:../FreeRTOS/Sources/tasks.c **** 
1901:../FreeRTOS/Sources/tasks.c **** 		configASSERT( pxEventList );
 2377              		.loc 1 1901 0
 2378 000a 7B68     		ldr	r3, [r7, #4]
 2379 000c 002B     		cmp	r3, #0
 2380 000e 02D1     		bne	.L135
 2381              		.loc 1 1901 0 is_stmt 0 discriminator 1
 2382 0010 FFF7FEFF 		bl	ulPortSetInterruptMask
 2383              	.L136:
 2384              		.loc 1 1901 0 discriminator 2
 2385 0014 FEE7     		b	.L136
 2386              	.L135:
1902:../FreeRTOS/Sources/tasks.c **** 
1903:../FreeRTOS/Sources/tasks.c **** 		/* This function should not be called by application code hence the
1904:../FreeRTOS/Sources/tasks.c **** 		'Restricted' in its name.  It is not part of the public API.  It is
1905:../FreeRTOS/Sources/tasks.c **** 		designed for use by kernel code, and has special calling requirements -
1906:../FreeRTOS/Sources/tasks.c **** 		it should be called from a critical section. */
1907:../FreeRTOS/Sources/tasks.c **** 
1908:../FreeRTOS/Sources/tasks.c **** 
1909:../FreeRTOS/Sources/tasks.c **** 		/* Place the event list item of the TCB in the appropriate event list.
1910:../FreeRTOS/Sources/tasks.c **** 		In this case it is assume that this is the only task that is going to
1911:../FreeRTOS/Sources/tasks.c **** 		be waiting on this event list, so the faster vListInsertEnd() function
1912:../FreeRTOS/Sources/tasks.c **** 		can be used in place of vListInsert. */
1913:../FreeRTOS/Sources/tasks.c **** 		vListInsertEnd( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
 2387              		.loc 1 1913 0 is_stmt 1
 2388 0016 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2389 001a C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2390 001e 1B68     		ldr	r3, [r3, #0]
 2391 0020 03F11803 		add	r3, r3, #24
 2392 0024 7868     		ldr	r0, [r7, #4]
 2393 0026 1946     		mov	r1, r3
 2394 0028 FFF7FEFF 		bl	vListInsertEnd
1914:../FreeRTOS/Sources/tasks.c **** 
1915:../FreeRTOS/Sources/tasks.c **** 		/* We must remove this task from the ready list before adding it to the
1916:../FreeRTOS/Sources/tasks.c **** 		blocked list as the same list item is used for both lists.  This
1917:../FreeRTOS/Sources/tasks.c **** 		function is called form a critical section. */
1918:../FreeRTOS/Sources/tasks.c **** 		if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
 2395              		.loc 1 1918 0
 2396 002c 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2397 0030 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2398 0034 1B68     		ldr	r3, [r3, #0]
 2399 0036 03F10403 		add	r3, r3, #4
 2400 003a 1846     		mov	r0, r3
 2401 003c FFF7FEFF 		bl	uxListRemove
1919:../FreeRTOS/Sources/tasks.c **** 		{
1920:../FreeRTOS/Sources/tasks.c **** 			/* The current task must be in a ready list, so there is no need to
1921:../FreeRTOS/Sources/tasks.c **** 			check, and the port reset macro can be called directly. */
1922:../FreeRTOS/Sources/tasks.c **** 			portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
1923:../FreeRTOS/Sources/tasks.c **** 		}
1924:../FreeRTOS/Sources/tasks.c **** 
1925:../FreeRTOS/Sources/tasks.c **** 		/* Calculate the time at which the task should be woken if the event does
1926:../FreeRTOS/Sources/tasks.c **** 		not occur.  This may overflow but this doesn't matter. */
1927:../FreeRTOS/Sources/tasks.c **** 		xTimeToWake = xTickCount + xTicksToWait;
 2402              		.loc 1 1927 0
 2403 0040 40F20003 		movw	r3, #:lower16:xTickCount
 2404 0044 C0F20003 		movt	r3, #:upper16:xTickCount
 2405 0048 1A68     		ldr	r2, [r3, #0]
 2406 004a 3B68     		ldr	r3, [r7, #0]
 2407 004c D318     		adds	r3, r2, r3
 2408 004e FB60     		str	r3, [r7, #12]
1928:../FreeRTOS/Sources/tasks.c **** 
1929:../FreeRTOS/Sources/tasks.c **** 		traceTASK_DELAY_UNTIL();
1930:../FreeRTOS/Sources/tasks.c **** 		prvAddCurrentTaskToDelayedList( xTimeToWake );
 2409              		.loc 1 1930 0
 2410 0050 F868     		ldr	r0, [r7, #12]
 2411 0052 FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
1931:../FreeRTOS/Sources/tasks.c **** 	}
 2412              		.loc 1 1931 0
 2413 0056 07F11007 		add	r7, r7, #16
 2414 005a BD46     		mov	sp, r7
 2415 005c 80BD     		pop	{r7, pc}
 2416              		.cfi_endproc
 2417              	.LFE20:
 2419 005e 00BF     		.section	.text.xTaskRemoveFromEventList,"ax",%progbits
 2420              		.align	2
 2421              		.global	xTaskRemoveFromEventList
 2422              		.thumb
 2423              		.thumb_func
 2425              	xTaskRemoveFromEventList:
 2426              	.LFB21:
1932:../FreeRTOS/Sources/tasks.c **** 
1933:../FreeRTOS/Sources/tasks.c **** #endif /* configUSE_TIMERS */
1934:../FreeRTOS/Sources/tasks.c **** /*-----------------------------------------------------------*/
1935:../FreeRTOS/Sources/tasks.c **** 
1936:../FreeRTOS/Sources/tasks.c **** signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
1937:../FreeRTOS/Sources/tasks.c **** {
 2427              		.loc 1 1937 0
 2428              		.cfi_startproc
 2429              		@ args = 0, pretend = 0, frame = 16
 2430              		@ frame_needed = 1, uses_anonymous_args = 0
 2431 0000 80B5     		push	{r7, lr}
 2432              	.LCFI60:
 2433              		.cfi_def_cfa_offset 8
 2434              		.cfi_offset 7, -8
 2435              		.cfi_offset 14, -4
 2436 0002 84B0     		sub	sp, sp, #16
 2437              	.LCFI61:
 2438              		.cfi_def_cfa_offset 24
 2439 0004 00AF     		add	r7, sp, #0
 2440              	.LCFI62:
 2441              		.cfi_def_cfa_register 7
 2442 0006 7860     		str	r0, [r7, #4]
1938:../FreeRTOS/Sources/tasks.c **** tskTCB *pxUnblockedTCB;
1939:../FreeRTOS/Sources/tasks.c **** portBASE_TYPE xReturn;
1940:../FreeRTOS/Sources/tasks.c **** 
1941:../FreeRTOS/Sources/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
1942:../FreeRTOS/Sources/tasks.c **** 	SCHEDULER SUSPENDED.  It can also be called from within an ISR. */
1943:../FreeRTOS/Sources/tasks.c **** 
1944:../FreeRTOS/Sources/tasks.c **** 	/* The event list is sorted in priority order, so we can remove the
1945:../FreeRTOS/Sources/tasks.c **** 	first in the list, remove the TCB from the delayed list, and add
1946:../FreeRTOS/Sources/tasks.c **** 	it to the ready list.
1947:../FreeRTOS/Sources/tasks.c **** 
1948:../FreeRTOS/Sources/tasks.c **** 	If an event is for a queue that is locked then this function will never
1949:../FreeRTOS/Sources/tasks.c **** 	get called - the lock count on the queue will get modified instead.  This
1950:../FreeRTOS/Sources/tasks.c **** 	means we can always expect exclusive access to the event list here.
1951:../FreeRTOS/Sources/tasks.c **** 
1952:../FreeRTOS/Sources/tasks.c **** 	This function assumes that a check has already been made to ensure that
1953:../FreeRTOS/Sources/tasks.c **** 	pxEventList is not empty. */
1954:../FreeRTOS/Sources/tasks.c **** 	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 2443              		.loc 1 1954 0
 2444 0008 7B68     		ldr	r3, [r7, #4]
 2445 000a DB68     		ldr	r3, [r3, #12]
 2446 000c DB68     		ldr	r3, [r3, #12]
 2447 000e BB60     		str	r3, [r7, #8]
1955:../FreeRTOS/Sources/tasks.c **** 	configASSERT( pxUnblockedTCB );
 2448              		.loc 1 1955 0
 2449 0010 BB68     		ldr	r3, [r7, #8]
 2450 0012 002B     		cmp	r3, #0
 2451 0014 02D1     		bne	.L138
 2452              		.loc 1 1955 0 is_stmt 0 discriminator 1
 2453 0016 FFF7FEFF 		bl	ulPortSetInterruptMask
 2454              	.L139:
 2455              		.loc 1 1955 0 discriminator 2
 2456 001a FEE7     		b	.L139
 2457              	.L138:
1956:../FreeRTOS/Sources/tasks.c **** 	uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 2458              		.loc 1 1956 0 is_stmt 1
 2459 001c BB68     		ldr	r3, [r7, #8]
 2460 001e 03F11803 		add	r3, r3, #24
 2461 0022 1846     		mov	r0, r3
 2462 0024 FFF7FEFF 		bl	uxListRemove
1957:../FreeRTOS/Sources/tasks.c **** 
1958:../FreeRTOS/Sources/tasks.c **** 	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 2463              		.loc 1 1958 0
 2464 0028 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 2465 002c C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 2466 0030 1B68     		ldr	r3, [r3, #0]
 2467 0032 002B     		cmp	r3, #0
 2468 0034 2AD1     		bne	.L140
1959:../FreeRTOS/Sources/tasks.c **** 	{
1960:../FreeRTOS/Sources/tasks.c **** 		uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
 2469              		.loc 1 1960 0
 2470 0036 BB68     		ldr	r3, [r7, #8]
 2471 0038 03F10403 		add	r3, r3, #4
 2472 003c 1846     		mov	r0, r3
 2473 003e FFF7FEFF 		bl	uxListRemove
1961:../FreeRTOS/Sources/tasks.c **** 		prvAddTaskToReadyQueue( pxUnblockedTCB );
 2474              		.loc 1 1961 0
 2475 0042 BB68     		ldr	r3, [r7, #8]
 2476 0044 DA6A     		ldr	r2, [r3, #44]
 2477 0046 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 2478 004a C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 2479 004e 1B68     		ldr	r3, [r3, #0]
 2480 0050 9A42     		cmp	r2, r3
 2481 0052 06D9     		bls	.L141
 2482              		.loc 1 1961 0 is_stmt 0 discriminator 1
 2483 0054 BB68     		ldr	r3, [r7, #8]
 2484 0056 DA6A     		ldr	r2, [r3, #44]
 2485 0058 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 2486 005c C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 2487 0060 1A60     		str	r2, [r3, #0]
 2488              	.L141:
 2489              		.loc 1 1961 0 discriminator 2
 2490 0062 BB68     		ldr	r3, [r7, #8]
 2491 0064 DA6A     		ldr	r2, [r3, #44]
 2492 0066 1346     		mov	r3, r2
 2493 0068 4FEA8303 		lsl	r3, r3, #2
 2494 006c 9B18     		adds	r3, r3, r2
 2495 006e 4FEA8303 		lsl	r3, r3, #2
 2496 0072 40F20002 		movw	r2, #:lower16:pxReadyTasksLists
 2497 0076 C0F20002 		movt	r2, #:upper16:pxReadyTasksLists
 2498 007a 9A18     		adds	r2, r3, r2
 2499 007c BB68     		ldr	r3, [r7, #8]
 2500 007e 03F10403 		add	r3, r3, #4
 2501 0082 1046     		mov	r0, r2
 2502 0084 1946     		mov	r1, r3
 2503 0086 FFF7FEFF 		bl	vListInsertEnd
 2504 008a 09E0     		b	.L142
 2505              	.L140:
1962:../FreeRTOS/Sources/tasks.c **** 	}
1963:../FreeRTOS/Sources/tasks.c **** 	else
1964:../FreeRTOS/Sources/tasks.c **** 	{
1965:../FreeRTOS/Sources/tasks.c **** 		/* We cannot access the delayed or ready lists, so will hold this
1966:../FreeRTOS/Sources/tasks.c **** 		task pending until the scheduler is resumed. */
1967:../FreeRTOS/Sources/tasks.c **** 		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 2506              		.loc 1 1967 0 is_stmt 1
 2507 008c BB68     		ldr	r3, [r7, #8]
 2508 008e 03F11803 		add	r3, r3, #24
 2509 0092 40F20000 		movw	r0, #:lower16:xPendingReadyList
 2510 0096 C0F20000 		movt	r0, #:upper16:xPendingReadyList
 2511 009a 1946     		mov	r1, r3
 2512 009c FFF7FEFF 		bl	vListInsertEnd
 2513              	.L142:
1968:../FreeRTOS/Sources/tasks.c **** 	}
1969:../FreeRTOS/Sources/tasks.c **** 
1970:../FreeRTOS/Sources/tasks.c **** 	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
 2514              		.loc 1 1970 0
 2515 00a0 BB68     		ldr	r3, [r7, #8]
 2516 00a2 DA6A     		ldr	r2, [r3, #44]
 2517 00a4 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2518 00a8 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2519 00ac 1B68     		ldr	r3, [r3, #0]
 2520 00ae DB6A     		ldr	r3, [r3, #44]
 2521 00b0 9A42     		cmp	r2, r3
 2522 00b2 03D3     		bcc	.L143
1971:../FreeRTOS/Sources/tasks.c **** 	{
1972:../FreeRTOS/Sources/tasks.c **** 		/* Return true if the task removed from the event list has
1973:../FreeRTOS/Sources/tasks.c **** 		a higher priority than the calling task.  This allows
1974:../FreeRTOS/Sources/tasks.c **** 		the calling task to know if it should force a context
1975:../FreeRTOS/Sources/tasks.c **** 		switch now. */
1976:../FreeRTOS/Sources/tasks.c **** 		xReturn = pdTRUE;
 2523              		.loc 1 1976 0
 2524 00b4 4FF00103 		mov	r3, #1
 2525 00b8 FB60     		str	r3, [r7, #12]
 2526 00ba 02E0     		b	.L144
 2527              	.L143:
1977:../FreeRTOS/Sources/tasks.c **** 	}
1978:../FreeRTOS/Sources/tasks.c **** 	else
1979:../FreeRTOS/Sources/tasks.c **** 	{
1980:../FreeRTOS/Sources/tasks.c **** 		xReturn = pdFALSE;
 2528              		.loc 1 1980 0
 2529 00bc 4FF00003 		mov	r3, #0
 2530 00c0 FB60     		str	r3, [r7, #12]
 2531              	.L144:
1981:../FreeRTOS/Sources/tasks.c **** 	}
1982:../FreeRTOS/Sources/tasks.c **** 
1983:../FreeRTOS/Sources/tasks.c **** 	return xReturn;
 2532              		.loc 1 1983 0
 2533 00c2 FB68     		ldr	r3, [r7, #12]
1984:../FreeRTOS/Sources/tasks.c **** }
 2534              		.loc 1 1984 0
 2535 00c4 1846     		mov	r0, r3
 2536 00c6 07F11007 		add	r7, r7, #16
 2537 00ca BD46     		mov	sp, r7
 2538 00cc 80BD     		pop	{r7, pc}
 2539              		.cfi_endproc
 2540              	.LFE21:
 2542 00ce 00BF     		.section	.text.vTaskSetTimeOutState,"ax",%progbits
 2543              		.align	2
 2544              		.global	vTaskSetTimeOutState
 2545              		.thumb
 2546              		.thumb_func
 2548              	vTaskSetTimeOutState:
 2549              	.LFB22:
1985:../FreeRTOS/Sources/tasks.c **** /*-----------------------------------------------------------*/
1986:../FreeRTOS/Sources/tasks.c **** 
1987:../FreeRTOS/Sources/tasks.c **** void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
1988:../FreeRTOS/Sources/tasks.c **** {
 2550              		.loc 1 1988 0
 2551              		.cfi_startproc
 2552              		@ args = 0, pretend = 0, frame = 8
 2553              		@ frame_needed = 1, uses_anonymous_args = 0
 2554 0000 80B5     		push	{r7, lr}
 2555              	.LCFI63:
 2556              		.cfi_def_cfa_offset 8
 2557              		.cfi_offset 7, -8
 2558              		.cfi_offset 14, -4
 2559 0002 82B0     		sub	sp, sp, #8
 2560              	.LCFI64:
 2561              		.cfi_def_cfa_offset 16
 2562 0004 00AF     		add	r7, sp, #0
 2563              	.LCFI65:
 2564              		.cfi_def_cfa_register 7
 2565 0006 7860     		str	r0, [r7, #4]
1989:../FreeRTOS/Sources/tasks.c **** 	configASSERT( pxTimeOut );
 2566              		.loc 1 1989 0
 2567 0008 7B68     		ldr	r3, [r7, #4]
 2568 000a 002B     		cmp	r3, #0
 2569 000c 02D1     		bne	.L147
 2570              		.loc 1 1989 0 is_stmt 0 discriminator 1
 2571 000e FFF7FEFF 		bl	ulPortSetInterruptMask
 2572              	.L148:
 2573              		.loc 1 1989 0 discriminator 2
 2574 0012 FEE7     		b	.L148
 2575              	.L147:
1990:../FreeRTOS/Sources/tasks.c **** 	pxTimeOut->xOverflowCount = xNumOfOverflows;
 2576              		.loc 1 1990 0 is_stmt 1
 2577 0014 40F20003 		movw	r3, #:lower16:xNumOfOverflows
 2578 0018 C0F20003 		movt	r3, #:upper16:xNumOfOverflows
 2579 001c 1A68     		ldr	r2, [r3, #0]
 2580 001e 7B68     		ldr	r3, [r7, #4]
 2581 0020 1A60     		str	r2, [r3, #0]
1991:../FreeRTOS/Sources/tasks.c **** 	pxTimeOut->xTimeOnEntering = xTickCount;
 2582              		.loc 1 1991 0
 2583 0022 40F20003 		movw	r3, #:lower16:xTickCount
 2584 0026 C0F20003 		movt	r3, #:upper16:xTickCount
 2585 002a 1A68     		ldr	r2, [r3, #0]
 2586 002c 7B68     		ldr	r3, [r7, #4]
 2587 002e 5A60     		str	r2, [r3, #4]
1992:../FreeRTOS/Sources/tasks.c **** }
 2588              		.loc 1 1992 0
 2589 0030 07F10807 		add	r7, r7, #8
 2590 0034 BD46     		mov	sp, r7
 2591 0036 80BD     		pop	{r7, pc}
 2592              		.cfi_endproc
 2593              	.LFE22:
 2595              		.section	.text.xTaskCheckForTimeOut,"ax",%progbits
 2596              		.align	2
 2597              		.global	xTaskCheckForTimeOut
 2598              		.thumb
 2599              		.thumb_func
 2601              	xTaskCheckForTimeOut:
 2602              	.LFB23:
1993:../FreeRTOS/Sources/tasks.c **** /*-----------------------------------------------------------*/
1994:../FreeRTOS/Sources/tasks.c **** 
1995:../FreeRTOS/Sources/tasks.c **** portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToW
1996:../FreeRTOS/Sources/tasks.c **** {
 2603              		.loc 1 1996 0
 2604              		.cfi_startproc
 2605              		@ args = 0, pretend = 0, frame = 16
 2606              		@ frame_needed = 1, uses_anonymous_args = 0
 2607 0000 80B5     		push	{r7, lr}
 2608              	.LCFI66:
 2609              		.cfi_def_cfa_offset 8
 2610              		.cfi_offset 7, -8
 2611              		.cfi_offset 14, -4
 2612 0002 84B0     		sub	sp, sp, #16
 2613              	.LCFI67:
 2614              		.cfi_def_cfa_offset 24
 2615 0004 00AF     		add	r7, sp, #0
 2616              	.LCFI68:
 2617              		.cfi_def_cfa_register 7
 2618 0006 7860     		str	r0, [r7, #4]
 2619 0008 3960     		str	r1, [r7, #0]
1997:../FreeRTOS/Sources/tasks.c **** portBASE_TYPE xReturn;
1998:../FreeRTOS/Sources/tasks.c **** 
1999:../FreeRTOS/Sources/tasks.c **** 	configASSERT( pxTimeOut );
 2620              		.loc 1 1999 0
 2621 000a 7B68     		ldr	r3, [r7, #4]
 2622 000c 002B     		cmp	r3, #0
 2623 000e 02D1     		bne	.L150
 2624              		.loc 1 1999 0 is_stmt 0 discriminator 1
 2625 0010 FFF7FEFF 		bl	ulPortSetInterruptMask
 2626              	.L151:
 2627              		.loc 1 1999 0 discriminator 2
 2628 0014 FEE7     		b	.L151
 2629              	.L150:
2000:../FreeRTOS/Sources/tasks.c **** 	configASSERT( pxTicksToWait );
 2630              		.loc 1 2000 0 is_stmt 1
 2631 0016 3B68     		ldr	r3, [r7, #0]
 2632 0018 002B     		cmp	r3, #0
 2633 001a 02D1     		bne	.L152
 2634              		.loc 1 2000 0 is_stmt 0 discriminator 1
 2635 001c FFF7FEFF 		bl	ulPortSetInterruptMask
 2636              	.L153:
 2637              		.loc 1 2000 0 discriminator 2
 2638 0020 FEE7     		b	.L153
 2639              	.L152:
2001:../FreeRTOS/Sources/tasks.c **** 
2002:../FreeRTOS/Sources/tasks.c **** 	taskENTER_CRITICAL();
 2640              		.loc 1 2002 0 is_stmt 1
 2641 0022 FFF7FEFF 		bl	vPortEnterCritical
2003:../FreeRTOS/Sources/tasks.c **** 	{
2004:../FreeRTOS/Sources/tasks.c **** 		#if ( INCLUDE_vTaskSuspend == 1 )
2005:../FreeRTOS/Sources/tasks.c **** 			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
2006:../FreeRTOS/Sources/tasks.c **** 			the maximum block time then the task should block indefinitely, and
2007:../FreeRTOS/Sources/tasks.c **** 			therefore never time out. */
2008:../FreeRTOS/Sources/tasks.c **** 			if( *pxTicksToWait == portMAX_DELAY )
 2642              		.loc 1 2008 0
 2643 0026 3B68     		ldr	r3, [r7, #0]
 2644 0028 1B68     		ldr	r3, [r3, #0]
 2645 002a B3F1FF3F 		cmp	r3, #-1
 2646 002e 03D1     		bne	.L154
2009:../FreeRTOS/Sources/tasks.c **** 			{
2010:../FreeRTOS/Sources/tasks.c **** 				xReturn = pdFALSE;
 2647              		.loc 1 2010 0
 2648 0030 4FF00003 		mov	r3, #0
 2649 0034 FB60     		str	r3, [r7, #12]
 2650 0036 38E0     		b	.L155
 2651              	.L154:
2011:../FreeRTOS/Sources/tasks.c **** 			}
2012:../FreeRTOS/Sources/tasks.c **** 			else /* We are not blocking indefinitely, perform the checks below. */
2013:../FreeRTOS/Sources/tasks.c **** 		#endif
2014:../FreeRTOS/Sources/tasks.c **** 
2015:../FreeRTOS/Sources/tasks.c **** 		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTi
 2652              		.loc 1 2015 0
 2653 0038 7B68     		ldr	r3, [r7, #4]
 2654 003a 1A68     		ldr	r2, [r3, #0]
 2655 003c 40F20003 		movw	r3, #:lower16:xNumOfOverflows
 2656 0040 C0F20003 		movt	r3, #:upper16:xNumOfOverflows
 2657 0044 1B68     		ldr	r3, [r3, #0]
 2658 0046 9A42     		cmp	r2, r3
 2659 0048 0CD0     		beq	.L156
 2660              		.loc 1 2015 0 is_stmt 0 discriminator 1
 2661 004a 7B68     		ldr	r3, [r7, #4]
 2662 004c 5A68     		ldr	r2, [r3, #4]
 2663 004e 40F20003 		movw	r3, #:lower16:xTickCount
 2664 0052 C0F20003 		movt	r3, #:upper16:xTickCount
 2665 0056 1B68     		ldr	r3, [r3, #0]
 2666 0058 9A42     		cmp	r2, r3
 2667 005a 03D8     		bhi	.L156
2016:../FreeRTOS/Sources/tasks.c **** 		{
2017:../FreeRTOS/Sources/tasks.c **** 			/* The tick count is greater than the time at which vTaskSetTimeout()
2018:../FreeRTOS/Sources/tasks.c **** 			was called, but has also overflowed since vTaskSetTimeOut() was called.
2019:../FreeRTOS/Sources/tasks.c **** 			It must have wrapped all the way around and gone past us again. This
2020:../FreeRTOS/Sources/tasks.c **** 			passed since vTaskSetTimeout() was called. */
2021:../FreeRTOS/Sources/tasks.c **** 			xReturn = pdTRUE;
 2668              		.loc 1 2021 0 is_stmt 1
 2669 005c 4FF00103 		mov	r3, #1
 2670 0060 FB60     		str	r3, [r7, #12]
 2671 0062 22E0     		b	.L155
 2672              	.L156:
2022:../FreeRTOS/Sources/tasks.c **** 		}
2023:../FreeRTOS/Sources/tasks.c **** 		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEn
 2673              		.loc 1 2023 0
 2674 0064 40F20003 		movw	r3, #:lower16:xTickCount
 2675 0068 C0F20003 		movt	r3, #:upper16:xTickCount
 2676 006c 1A68     		ldr	r2, [r3, #0]
 2677 006e 7B68     		ldr	r3, [r7, #4]
 2678 0070 5B68     		ldr	r3, [r3, #4]
 2679 0072 D21A     		subs	r2, r2, r3
 2680 0074 3B68     		ldr	r3, [r7, #0]
 2681 0076 1B68     		ldr	r3, [r3, #0]
 2682 0078 9A42     		cmp	r2, r3
 2683 007a 13D2     		bcs	.L157
2024:../FreeRTOS/Sources/tasks.c **** 		{
2025:../FreeRTOS/Sources/tasks.c **** 			/* Not a genuine timeout. Adjust parameters for time remaining. */
2026:../FreeRTOS/Sources/tasks.c **** 			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
 2684              		.loc 1 2026 0
 2685 007c 3B68     		ldr	r3, [r7, #0]
 2686 007e 1A68     		ldr	r2, [r3, #0]
 2687 0080 7B68     		ldr	r3, [r7, #4]
 2688 0082 5968     		ldr	r1, [r3, #4]
 2689 0084 40F20003 		movw	r3, #:lower16:xTickCount
 2690 0088 C0F20003 		movt	r3, #:upper16:xTickCount
 2691 008c 1B68     		ldr	r3, [r3, #0]
 2692 008e CB1A     		subs	r3, r1, r3
 2693 0090 D218     		adds	r2, r2, r3
 2694 0092 3B68     		ldr	r3, [r7, #0]
 2695 0094 1A60     		str	r2, [r3, #0]
2027:../FreeRTOS/Sources/tasks.c **** 			vTaskSetTimeOutState( pxTimeOut );
 2696              		.loc 1 2027 0
 2697 0096 7868     		ldr	r0, [r7, #4]
 2698 0098 FFF7FEFF 		bl	vTaskSetTimeOutState
2028:../FreeRTOS/Sources/tasks.c **** 			xReturn = pdFALSE;
 2699              		.loc 1 2028 0
 2700 009c 4FF00003 		mov	r3, #0
 2701 00a0 FB60     		str	r3, [r7, #12]
 2702 00a2 02E0     		b	.L155
 2703              	.L157:
2029:../FreeRTOS/Sources/tasks.c **** 		}
2030:../FreeRTOS/Sources/tasks.c **** 		else
2031:../FreeRTOS/Sources/tasks.c **** 		{
2032:../FreeRTOS/Sources/tasks.c **** 			xReturn = pdTRUE;
 2704              		.loc 1 2032 0
 2705 00a4 4FF00103 		mov	r3, #1
 2706 00a8 FB60     		str	r3, [r7, #12]
 2707              	.L155:
2033:../FreeRTOS/Sources/tasks.c **** 		}
2034:../FreeRTOS/Sources/tasks.c **** 	}
2035:../FreeRTOS/Sources/tasks.c **** 	taskEXIT_CRITICAL();
 2708              		.loc 1 2035 0
 2709 00aa FFF7FEFF 		bl	vPortExitCritical
2036:../FreeRTOS/Sources/tasks.c **** 
2037:../FreeRTOS/Sources/tasks.c **** 	return xReturn;
 2710              		.loc 1 2037 0
 2711 00ae FB68     		ldr	r3, [r7, #12]
2038:../FreeRTOS/Sources/tasks.c **** }
 2712              		.loc 1 2038 0
 2713 00b0 1846     		mov	r0, r3
 2714 00b2 07F11007 		add	r7, r7, #16
 2715 00b6 BD46     		mov	sp, r7
 2716 00b8 80BD     		pop	{r7, pc}
 2717              		.cfi_endproc
 2718              	.LFE23:
 2720 00ba 00BF     		.section	.text.vTaskMissedYield,"ax",%progbits
 2721              		.align	2
 2722              		.global	vTaskMissedYield
 2723              		.thumb
 2724              		.thumb_func
 2726              	vTaskMissedYield:
 2727              	.LFB24:
2039:../FreeRTOS/Sources/tasks.c **** /*-----------------------------------------------------------*/
2040:../FreeRTOS/Sources/tasks.c **** 
2041:../FreeRTOS/Sources/tasks.c **** void vTaskMissedYield( void )
2042:../FreeRTOS/Sources/tasks.c **** {
 2728              		.loc 1 2042 0
 2729              		.cfi_startproc
 2730              		@ args = 0, pretend = 0, frame = 0
 2731              		@ frame_needed = 1, uses_anonymous_args = 0
 2732              		@ link register save eliminated.
 2733 0000 80B4     		push	{r7}
 2734              	.LCFI69:
 2735              		.cfi_def_cfa_offset 4
 2736              		.cfi_offset 7, -4
 2737 0002 00AF     		add	r7, sp, #0
 2738              	.LCFI70:
 2739              		.cfi_def_cfa_register 7
2043:../FreeRTOS/Sources/tasks.c **** 	xMissedYield = pdTRUE;
 2740              		.loc 1 2043 0
 2741 0004 40F20003 		movw	r3, #:lower16:xMissedYield
 2742 0008 C0F20003 		movt	r3, #:upper16:xMissedYield
 2743 000c 4FF00102 		mov	r2, #1
 2744 0010 1A60     		str	r2, [r3, #0]
2044:../FreeRTOS/Sources/tasks.c **** }
 2745              		.loc 1 2044 0
 2746 0012 BD46     		mov	sp, r7
 2747 0014 80BC     		pop	{r7}
 2748 0016 7047     		bx	lr
 2749              		.cfi_endproc
 2750              	.LFE24:
 2752              		.section	.text.prvIdleTask,"ax",%progbits
 2753              		.align	2
 2754              		.thumb
 2755              		.thumb_func
 2757              	prvIdleTask:
 2758              	.LFB25:
2045:../FreeRTOS/Sources/tasks.c **** /*-----------------------------------------------------------*/
2046:../FreeRTOS/Sources/tasks.c **** 
2047:../FreeRTOS/Sources/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2048:../FreeRTOS/Sources/tasks.c **** 
2049:../FreeRTOS/Sources/tasks.c **** 	unsigned portBASE_TYPE uxTaskGetTaskNumber( xTaskHandle xTask )
2050:../FreeRTOS/Sources/tasks.c **** 	{
2051:../FreeRTOS/Sources/tasks.c **** 	unsigned portBASE_TYPE uxReturn;
2052:../FreeRTOS/Sources/tasks.c **** 	tskTCB *pxTCB;
2053:../FreeRTOS/Sources/tasks.c **** 
2054:../FreeRTOS/Sources/tasks.c **** 		if( xTask != NULL )
2055:../FreeRTOS/Sources/tasks.c **** 		{
2056:../FreeRTOS/Sources/tasks.c **** 			pxTCB = ( tskTCB * ) xTask;
2057:../FreeRTOS/Sources/tasks.c **** 			uxReturn = pxTCB->uxTaskNumber;
2058:../FreeRTOS/Sources/tasks.c **** 		}
2059:../FreeRTOS/Sources/tasks.c **** 		else
2060:../FreeRTOS/Sources/tasks.c **** 		{
2061:../FreeRTOS/Sources/tasks.c **** 			uxReturn = 0U;
2062:../FreeRTOS/Sources/tasks.c **** 		}
2063:../FreeRTOS/Sources/tasks.c **** 
2064:../FreeRTOS/Sources/tasks.c **** 		return uxReturn;
2065:../FreeRTOS/Sources/tasks.c **** 	}
2066:../FreeRTOS/Sources/tasks.c **** 
2067:../FreeRTOS/Sources/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
2068:../FreeRTOS/Sources/tasks.c **** /*-----------------------------------------------------------*/
2069:../FreeRTOS/Sources/tasks.c **** 
2070:../FreeRTOS/Sources/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2071:../FreeRTOS/Sources/tasks.c **** 
2072:../FreeRTOS/Sources/tasks.c **** 	void vTaskSetTaskNumber( xTaskHandle xTask, unsigned portBASE_TYPE uxHandle )
2073:../FreeRTOS/Sources/tasks.c **** 	{
2074:../FreeRTOS/Sources/tasks.c **** 	tskTCB *pxTCB;
2075:../FreeRTOS/Sources/tasks.c **** 
2076:../FreeRTOS/Sources/tasks.c **** 		if( xTask != NULL )
2077:../FreeRTOS/Sources/tasks.c **** 		{
2078:../FreeRTOS/Sources/tasks.c **** 			pxTCB = ( tskTCB * ) xTask;
2079:../FreeRTOS/Sources/tasks.c **** 			pxTCB->uxTaskNumber = uxHandle;
2080:../FreeRTOS/Sources/tasks.c **** 		}
2081:../FreeRTOS/Sources/tasks.c **** 	}
2082:../FreeRTOS/Sources/tasks.c **** 
2083:../FreeRTOS/Sources/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
2084:../FreeRTOS/Sources/tasks.c **** 
2085:../FreeRTOS/Sources/tasks.c **** /*
2086:../FreeRTOS/Sources/tasks.c ****  * -----------------------------------------------------------
2087:../FreeRTOS/Sources/tasks.c ****  * The Idle task.
2088:../FreeRTOS/Sources/tasks.c ****  * ----------------------------------------------------------
2089:../FreeRTOS/Sources/tasks.c ****  *
2090:../FreeRTOS/Sources/tasks.c ****  * The portTASK_FUNCTION() macro is used to allow port/compiler specific
2091:../FreeRTOS/Sources/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
2092:../FreeRTOS/Sources/tasks.c ****  *
2093:../FreeRTOS/Sources/tasks.c ****  * void prvIdleTask( void *pvParameters );
2094:../FreeRTOS/Sources/tasks.c ****  *
2095:../FreeRTOS/Sources/tasks.c ****  */
2096:../FreeRTOS/Sources/tasks.c **** static portTASK_FUNCTION( prvIdleTask, pvParameters )
2097:../FreeRTOS/Sources/tasks.c **** {
 2759              		.loc 1 2097 0
 2760              		.cfi_startproc
 2761              		@ args = 0, pretend = 0, frame = 8
 2762              		@ frame_needed = 1, uses_anonymous_args = 0
 2763 0000 80B5     		push	{r7, lr}
 2764              	.LCFI71:
 2765              		.cfi_def_cfa_offset 8
 2766              		.cfi_offset 7, -8
 2767              		.cfi_offset 14, -4
 2768 0002 82B0     		sub	sp, sp, #8
 2769              	.LCFI72:
 2770              		.cfi_def_cfa_offset 16
 2771 0004 00AF     		add	r7, sp, #0
 2772              	.LCFI73:
 2773              		.cfi_def_cfa_register 7
 2774 0006 7860     		str	r0, [r7, #4]
 2775              	.L162:
2098:../FreeRTOS/Sources/tasks.c **** 	/* Stop warnings. */
2099:../FreeRTOS/Sources/tasks.c **** 	( void ) pvParameters;
2100:../FreeRTOS/Sources/tasks.c **** 
2101:../FreeRTOS/Sources/tasks.c **** 	for( ;; )
2102:../FreeRTOS/Sources/tasks.c **** 	{
2103:../FreeRTOS/Sources/tasks.c **** 		/* See if any tasks have been deleted. */
2104:../FreeRTOS/Sources/tasks.c **** 		prvCheckTasksWaitingTermination();
 2776              		.loc 1 2104 0
 2777 0008 FFF7FEFF 		bl	prvCheckTasksWaitingTermination
2105:../FreeRTOS/Sources/tasks.c **** 
2106:../FreeRTOS/Sources/tasks.c **** 		#if ( configUSE_PREEMPTION == 0 )
2107:../FreeRTOS/Sources/tasks.c **** 		{
2108:../FreeRTOS/Sources/tasks.c **** 			/* If we are not using preemption we keep forcing a task switch to
2109:../FreeRTOS/Sources/tasks.c **** 			see if any other task has become available.  If we are using
2110:../FreeRTOS/Sources/tasks.c **** 			preemption we don't need to do this as any task becoming available
2111:../FreeRTOS/Sources/tasks.c **** 			will automatically get the processor anyway. */
2112:../FreeRTOS/Sources/tasks.c **** 			taskYIELD();
2113:../FreeRTOS/Sources/tasks.c **** 		}
2114:../FreeRTOS/Sources/tasks.c **** 		#endif /* configUSE_PREEMPTION */
2115:../FreeRTOS/Sources/tasks.c **** 
2116:../FreeRTOS/Sources/tasks.c **** 		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
2117:../FreeRTOS/Sources/tasks.c **** 		{
2118:../FreeRTOS/Sources/tasks.c **** 			/* When using preemption tasks of equal priority will be
2119:../FreeRTOS/Sources/tasks.c **** 			timesliced.  If a task that is sharing the idle priority is ready
2120:../FreeRTOS/Sources/tasks.c **** 			to run then the idle task should yield before the end of the
2121:../FreeRTOS/Sources/tasks.c **** 			timeslice.
2122:../FreeRTOS/Sources/tasks.c **** 
2123:../FreeRTOS/Sources/tasks.c **** 			A critical region is not required here as we are just reading from
2124:../FreeRTOS/Sources/tasks.c **** 			the list, and an occasional incorrect value will not matter.  If
2125:../FreeRTOS/Sources/tasks.c **** 			the ready list at the idle priority contains more than one task
2126:../FreeRTOS/Sources/tasks.c **** 			then a task other than the idle task is ready to execute. */
2127:../FreeRTOS/Sources/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_
 2778              		.loc 1 2127 0
 2779 000c 40F20003 		movw	r3, #:lower16:pxReadyTasksLists
 2780 0010 C0F20003 		movt	r3, #:upper16:pxReadyTasksLists
 2781 0014 1B68     		ldr	r3, [r3, #0]
 2782 0016 012B     		cmp	r3, #1
 2783 0018 01D9     		bls	.L161
2128:../FreeRTOS/Sources/tasks.c **** 			{
2129:../FreeRTOS/Sources/tasks.c **** 				taskYIELD();
 2784              		.loc 1 2129 0
 2785 001a FFF7FEFF 		bl	vPortYieldFromISR
 2786              	.L161:
 2787              	.LBB8:
2130:../FreeRTOS/Sources/tasks.c **** 			}
2131:../FreeRTOS/Sources/tasks.c **** 		}
2132:../FreeRTOS/Sources/tasks.c **** 		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) ) */
2133:../FreeRTOS/Sources/tasks.c **** 
2134:../FreeRTOS/Sources/tasks.c **** 		#if ( configUSE_IDLE_HOOK == 1 )
2135:../FreeRTOS/Sources/tasks.c **** 		{
2136:../FreeRTOS/Sources/tasks.c **** 			extern void vApplicationIdleHook( void );
2137:../FreeRTOS/Sources/tasks.c **** 
2138:../FreeRTOS/Sources/tasks.c **** 			/* Call the user defined function from within the idle task.  This
2139:../FreeRTOS/Sources/tasks.c **** 			allows the application designer to add background functionality
2140:../FreeRTOS/Sources/tasks.c **** 			without the overhead of a separate task.
2141:../FreeRTOS/Sources/tasks.c **** 			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
2142:../FreeRTOS/Sources/tasks.c **** 			CALL A FUNCTION THAT MIGHT BLOCK. */
2143:../FreeRTOS/Sources/tasks.c **** 			vApplicationIdleHook();
 2788              		.loc 1 2143 0
 2789 001e FFF7FEFF 		bl	vApplicationIdleHook
 2790              	.LBE8:
2144:../FreeRTOS/Sources/tasks.c **** 		}
2145:../FreeRTOS/Sources/tasks.c **** 		#endif /* configUSE_IDLE_HOOK */
2146:../FreeRTOS/Sources/tasks.c **** 
2147:../FreeRTOS/Sources/tasks.c **** 		/* This conditional compilation should use inequality to 0, not equality
2148:../FreeRTOS/Sources/tasks.c **** 		to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when
2149:../FreeRTOS/Sources/tasks.c **** 		user defined low power mode	implementations require
2150:../FreeRTOS/Sources/tasks.c **** 		configUSE_TICKLESS_IDLE to be set to a value other than 1. */
2151:../FreeRTOS/Sources/tasks.c **** 		#if ( configUSE_TICKLESS_IDLE != 0 )
2152:../FreeRTOS/Sources/tasks.c **** 		{
2153:../FreeRTOS/Sources/tasks.c **** 		portTickType xExpectedIdleTime;
2154:../FreeRTOS/Sources/tasks.c **** 			/* It is not desirable to suspend then resume the scheduler on
2155:../FreeRTOS/Sources/tasks.c **** 			each iteration of the idle task.  Therefore, a preliminary
2156:../FreeRTOS/Sources/tasks.c **** 			test of the expected idle time is performed without the
2157:../FreeRTOS/Sources/tasks.c **** 			scheduler suspended.  The result here is not necessarily
2158:../FreeRTOS/Sources/tasks.c **** 			valid. */
2159:../FreeRTOS/Sources/tasks.c **** 			xExpectedIdleTime = prvGetExpectedIdleTime();
2160:../FreeRTOS/Sources/tasks.c **** 
2161:../FreeRTOS/Sources/tasks.c **** 			if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
2162:../FreeRTOS/Sources/tasks.c **** 			{
2163:../FreeRTOS/Sources/tasks.c **** 				vTaskSuspendAll();
2164:../FreeRTOS/Sources/tasks.c **** 				{
2165:../FreeRTOS/Sources/tasks.c **** 					/* Now the scheduler is suspended, the expected idle
2166:../FreeRTOS/Sources/tasks.c **** 					time can be sampled again, and this time its value can
2167:../FreeRTOS/Sources/tasks.c **** 					be used. */
2168:../FreeRTOS/Sources/tasks.c **** 					configASSERT( xNextTaskUnblockTime >= xTickCount );
2169:../FreeRTOS/Sources/tasks.c **** 					xExpectedIdleTime = prvGetExpectedIdleTime();
2170:../FreeRTOS/Sources/tasks.c **** 
2171:../FreeRTOS/Sources/tasks.c **** 					if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
2172:../FreeRTOS/Sources/tasks.c **** 					{
2173:../FreeRTOS/Sources/tasks.c **** 						portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
2174:../FreeRTOS/Sources/tasks.c **** 					}
2175:../FreeRTOS/Sources/tasks.c **** 				}
2176:../FreeRTOS/Sources/tasks.c **** 				xTaskResumeAll();
2177:../FreeRTOS/Sources/tasks.c **** 			}
2178:../FreeRTOS/Sources/tasks.c **** 		}
2179:../FreeRTOS/Sources/tasks.c **** 		#endif /* configUSE_TICKLESS_IDLE */
2180:../FreeRTOS/Sources/tasks.c **** 	}
 2791              		.loc 1 2180 0
 2792 0022 F1E7     		b	.L162
 2793              		.cfi_endproc
 2794              	.LFE25:
 2796              		.section	.text.prvInitialiseTCBVariables,"ax",%progbits
 2797              		.align	2
 2798              		.thumb
 2799              		.thumb_func
 2801              	prvInitialiseTCBVariables:
 2802              	.LFB26:
2181:../FreeRTOS/Sources/tasks.c **** } /*lint !e715 pvParameters is not accessed but all task functions require the same prototype. */
2182:../FreeRTOS/Sources/tasks.c **** /*-----------------------------------------------------------*/
2183:../FreeRTOS/Sources/tasks.c **** 
2184:../FreeRTOS/Sources/tasks.c **** #if configUSE_TICKLESS_IDLE != 0
2185:../FreeRTOS/Sources/tasks.c **** 
2186:../FreeRTOS/Sources/tasks.c **** 	eSleepModeStatus eTaskConfirmSleepModeStatus( void )
2187:../FreeRTOS/Sources/tasks.c **** 	{
2188:../FreeRTOS/Sources/tasks.c **** 	eSleepModeStatus eReturn = eStandardSleep;
2189:../FreeRTOS/Sources/tasks.c **** 
2190:../FreeRTOS/Sources/tasks.c **** 		if( listCURRENT_LIST_LENGTH( &xPendingReadyList ) != 0 )
2191:../FreeRTOS/Sources/tasks.c **** 		{
2192:../FreeRTOS/Sources/tasks.c **** 			/* A task was made ready while the scheduler was suspended. */
2193:../FreeRTOS/Sources/tasks.c **** 			eReturn = eAbortSleep;
2194:../FreeRTOS/Sources/tasks.c **** 		}
2195:../FreeRTOS/Sources/tasks.c **** 		else if( xMissedYield != pdFALSE )
2196:../FreeRTOS/Sources/tasks.c **** 		{
2197:../FreeRTOS/Sources/tasks.c **** 			/* A yield was pended while the scheduler was suspended. */
2198:../FreeRTOS/Sources/tasks.c **** 			eReturn = eAbortSleep;
2199:../FreeRTOS/Sources/tasks.c **** 		}
2200:../FreeRTOS/Sources/tasks.c **** 		else
2201:../FreeRTOS/Sources/tasks.c **** 		{
2202:../FreeRTOS/Sources/tasks.c **** 			#if configUSE_TIMERS == 0
2203:../FreeRTOS/Sources/tasks.c **** 			{
2204:../FreeRTOS/Sources/tasks.c **** 				/* The idle task exists in addition to the application tasks. */
2205:../FreeRTOS/Sources/tasks.c **** 				const unsigned portBASE_TYPE uxNonApplicationTasks = 1;
2206:../FreeRTOS/Sources/tasks.c **** 
2207:../FreeRTOS/Sources/tasks.c **** 				/* If timers are not being used and all the tasks are in the
2208:../FreeRTOS/Sources/tasks.c **** 				suspended list (which might mean they have an infinite block
2209:../FreeRTOS/Sources/tasks.c **** 				time rather than actually being suspended) then it is safe to
2210:../FreeRTOS/Sources/tasks.c **** 				turn all clocks off and just wait for external interrupts. */
2211:../FreeRTOS/Sources/tasks.c **** 				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == ( uxCurrentNumberOfTasks - uxNonApplicati
2212:../FreeRTOS/Sources/tasks.c **** 				{
2213:../FreeRTOS/Sources/tasks.c **** 					eReturn = eNoTasksWaitingTimeout;
2214:../FreeRTOS/Sources/tasks.c **** 				}
2215:../FreeRTOS/Sources/tasks.c **** 			}
2216:../FreeRTOS/Sources/tasks.c **** 			#endif /* configUSE_TIMERS */
2217:../FreeRTOS/Sources/tasks.c **** 		}
2218:../FreeRTOS/Sources/tasks.c **** 
2219:../FreeRTOS/Sources/tasks.c **** 		return eReturn;
2220:../FreeRTOS/Sources/tasks.c **** 	}
2221:../FreeRTOS/Sources/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
2222:../FreeRTOS/Sources/tasks.c **** /*-----------------------------------------------------------*/
2223:../FreeRTOS/Sources/tasks.c **** 
2224:../FreeRTOS/Sources/tasks.c **** static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned po
2225:../FreeRTOS/Sources/tasks.c **** {
 2803              		.loc 1 2225 0
 2804              		.cfi_startproc
 2805              		@ args = 4, pretend = 0, frame = 16
 2806              		@ frame_needed = 1, uses_anonymous_args = 0
 2807 0000 80B5     		push	{r7, lr}
 2808              	.LCFI74:
 2809              		.cfi_def_cfa_offset 8
 2810              		.cfi_offset 7, -8
 2811              		.cfi_offset 14, -4
 2812 0002 84B0     		sub	sp, sp, #16
 2813              	.LCFI75:
 2814              		.cfi_def_cfa_offset 24
 2815 0004 00AF     		add	r7, sp, #0
 2816              	.LCFI76:
 2817              		.cfi_def_cfa_register 7
 2818 0006 F860     		str	r0, [r7, #12]
 2819 0008 B960     		str	r1, [r7, #8]
 2820 000a 7A60     		str	r2, [r7, #4]
 2821 000c 3B60     		str	r3, [r7, #0]
2226:../FreeRTOS/Sources/tasks.c **** 	/* Store the function name in the TCB. */
2227:../FreeRTOS/Sources/tasks.c **** 	#if configMAX_TASK_NAME_LEN > 1
2228:../FreeRTOS/Sources/tasks.c **** 	{
2229:../FreeRTOS/Sources/tasks.c **** 		/* Don't bring strncpy into the build unnecessarily. */
2230:../FreeRTOS/Sources/tasks.c **** 		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK
 2822              		.loc 1 2230 0
 2823 000e FB68     		ldr	r3, [r7, #12]
 2824 0010 03F13403 		add	r3, r3, #52
 2825 0014 1846     		mov	r0, r3
 2826 0016 B968     		ldr	r1, [r7, #8]
 2827 0018 4FF00A02 		mov	r2, #10
 2828 001c FFF7FEFF 		bl	strncpy
2231:../FreeRTOS/Sources/tasks.c **** 	}
2232:../FreeRTOS/Sources/tasks.c **** 	#endif /* configMAX_TASK_NAME_LEN */
2233:../FreeRTOS/Sources/tasks.c **** 	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed 
 2829              		.loc 1 2233 0
 2830 0020 FB68     		ldr	r3, [r7, #12]
 2831 0022 4FF00002 		mov	r2, #0
 2832 0026 83F83D20 		strb	r2, [r3, #61]
2234:../FreeRTOS/Sources/tasks.c **** 
2235:../FreeRTOS/Sources/tasks.c **** 	/* This is used as an array index so must ensure it's not too large.  First
2236:../FreeRTOS/Sources/tasks.c **** 	remove the privilege bit if one is present. */
2237:../FreeRTOS/Sources/tasks.c **** 	if( uxPriority >= configMAX_PRIORITIES )
 2833              		.loc 1 2237 0
 2834 002a 7B68     		ldr	r3, [r7, #4]
 2835 002c 042B     		cmp	r3, #4
 2836 002e 02D9     		bls	.L164
2238:../FreeRTOS/Sources/tasks.c **** 	{
2239:../FreeRTOS/Sources/tasks.c **** 		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
 2837              		.loc 1 2239 0
 2838 0030 4FF00403 		mov	r3, #4
 2839 0034 7B60     		str	r3, [r7, #4]
 2840              	.L164:
2240:../FreeRTOS/Sources/tasks.c **** 	}
2241:../FreeRTOS/Sources/tasks.c **** 
2242:../FreeRTOS/Sources/tasks.c **** 	pxTCB->uxPriority = uxPriority;
 2841              		.loc 1 2242 0
 2842 0036 FB68     		ldr	r3, [r7, #12]
 2843 0038 7A68     		ldr	r2, [r7, #4]
 2844 003a DA62     		str	r2, [r3, #44]
2243:../FreeRTOS/Sources/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
2244:../FreeRTOS/Sources/tasks.c **** 	{
2245:../FreeRTOS/Sources/tasks.c **** 		pxTCB->uxBasePriority = uxPriority;
 2845              		.loc 1 2245 0
 2846 003c FB68     		ldr	r3, [r7, #12]
 2847 003e 7A68     		ldr	r2, [r7, #4]
 2848 0040 1A64     		str	r2, [r3, #64]
2246:../FreeRTOS/Sources/tasks.c **** 	}
2247:../FreeRTOS/Sources/tasks.c **** 	#endif /* configUSE_MUTEXES */
2248:../FreeRTOS/Sources/tasks.c **** 
2249:../FreeRTOS/Sources/tasks.c **** 	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 2849              		.loc 1 2249 0
 2850 0042 FB68     		ldr	r3, [r7, #12]
 2851 0044 03F10403 		add	r3, r3, #4
 2852 0048 1846     		mov	r0, r3
 2853 004a FFF7FEFF 		bl	vListInitialiseItem
2250:../FreeRTOS/Sources/tasks.c **** 	vListInitialiseItem( &( pxTCB->xEventListItem ) );
 2854              		.loc 1 2250 0
 2855 004e FB68     		ldr	r3, [r7, #12]
 2856 0050 03F11803 		add	r3, r3, #24
 2857 0054 1846     		mov	r0, r3
 2858 0056 FFF7FEFF 		bl	vListInitialiseItem
2251:../FreeRTOS/Sources/tasks.c **** 
2252:../FreeRTOS/Sources/tasks.c **** 	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
2253:../FreeRTOS/Sources/tasks.c **** 	back to	the containing TCB from a generic item in a list. */
2254:../FreeRTOS/Sources/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
 2859              		.loc 1 2254 0
 2860 005a FB68     		ldr	r3, [r7, #12]
 2861 005c FA68     		ldr	r2, [r7, #12]
 2862 005e 1A61     		str	r2, [r3, #16]
2255:../FreeRTOS/Sources/tasks.c **** 
2256:../FreeRTOS/Sources/tasks.c **** 	/* Event lists are always in priority order. */
2257:../FreeRTOS/Sources/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPri
 2863              		.loc 1 2257 0
 2864 0060 7B68     		ldr	r3, [r7, #4]
 2865 0062 C3F10502 		rsb	r2, r3, #5
 2866 0066 FB68     		ldr	r3, [r7, #12]
 2867 0068 9A61     		str	r2, [r3, #24]
2258:../FreeRTOS/Sources/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
 2868              		.loc 1 2258 0
 2869 006a FB68     		ldr	r3, [r7, #12]
 2870 006c FA68     		ldr	r2, [r7, #12]
 2871 006e 5A62     		str	r2, [r3, #36]
2259:../FreeRTOS/Sources/tasks.c **** 
2260:../FreeRTOS/Sources/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
2261:../FreeRTOS/Sources/tasks.c **** 	{
2262:../FreeRTOS/Sources/tasks.c **** 		pxTCB->uxCriticalNesting = ( unsigned portBASE_TYPE ) 0U;
2263:../FreeRTOS/Sources/tasks.c **** 	}
2264:../FreeRTOS/Sources/tasks.c **** 	#endif /* portCRITICAL_NESTING_IN_TCB */
2265:../FreeRTOS/Sources/tasks.c **** 
2266:../FreeRTOS/Sources/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
2267:../FreeRTOS/Sources/tasks.c **** 	{
2268:../FreeRTOS/Sources/tasks.c **** 		pxTCB->pxTaskTag = NULL;
2269:../FreeRTOS/Sources/tasks.c **** 	}
2270:../FreeRTOS/Sources/tasks.c **** 	#endif /* configUSE_APPLICATION_TASK_TAG */
2271:../FreeRTOS/Sources/tasks.c **** 
2272:../FreeRTOS/Sources/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
2273:../FreeRTOS/Sources/tasks.c **** 	{
2274:../FreeRTOS/Sources/tasks.c **** 		pxTCB->ulRunTimeCounter = 0UL;
2275:../FreeRTOS/Sources/tasks.c **** 	}
2276:../FreeRTOS/Sources/tasks.c **** 	#endif /* configGENERATE_RUN_TIME_STATS */
2277:../FreeRTOS/Sources/tasks.c **** 
2278:../FreeRTOS/Sources/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
2279:../FreeRTOS/Sources/tasks.c **** 	{
2280:../FreeRTOS/Sources/tasks.c **** 		vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, pxTCB->pxStack, usStackDepth );
2281:../FreeRTOS/Sources/tasks.c **** 	}
2282:../FreeRTOS/Sources/tasks.c **** 	#else /* portUSING_MPU_WRAPPERS */
2283:../FreeRTOS/Sources/tasks.c **** 	{
2284:../FreeRTOS/Sources/tasks.c **** 		( void ) xRegions;
2285:../FreeRTOS/Sources/tasks.c **** 		( void ) usStackDepth;
2286:../FreeRTOS/Sources/tasks.c **** 	}
2287:../FreeRTOS/Sources/tasks.c **** 	#endif /* portUSING_MPU_WRAPPERS */
2288:../FreeRTOS/Sources/tasks.c **** }
 2872              		.loc 1 2288 0
 2873 0070 07F11007 		add	r7, r7, #16
 2874 0074 BD46     		mov	sp, r7
 2875 0076 80BD     		pop	{r7, pc}
 2876              		.cfi_endproc
 2877              	.LFE26:
 2879              		.section	.text.prvInitialiseTaskLists,"ax",%progbits
 2880              		.align	2
 2881              		.thumb
 2882              		.thumb_func
 2884              	prvInitialiseTaskLists:
 2885              	.LFB27:
2289:../FreeRTOS/Sources/tasks.c **** /*-----------------------------------------------------------*/
2290:../FreeRTOS/Sources/tasks.c **** 
2291:../FreeRTOS/Sources/tasks.c **** #if ( portUSING_MPU_WRAPPERS == 1 )
2292:../FreeRTOS/Sources/tasks.c **** 
2293:../FreeRTOS/Sources/tasks.c **** 	void vTaskAllocateMPURegions( xTaskHandle xTaskToModify, const xMemoryRegion * const xRegions )
2294:../FreeRTOS/Sources/tasks.c **** 	{
2295:../FreeRTOS/Sources/tasks.c **** 	tskTCB *pxTCB;
2296:../FreeRTOS/Sources/tasks.c **** 
2297:../FreeRTOS/Sources/tasks.c **** 		if( xTaskToModify == pxCurrentTCB )
2298:../FreeRTOS/Sources/tasks.c **** 		{
2299:../FreeRTOS/Sources/tasks.c **** 			xTaskToModify = NULL;
2300:../FreeRTOS/Sources/tasks.c **** 		}
2301:../FreeRTOS/Sources/tasks.c **** 
2302:../FreeRTOS/Sources/tasks.c **** 		/* If null is passed in here then we are deleting ourselves. */
2303:../FreeRTOS/Sources/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTaskToModify );
2304:../FreeRTOS/Sources/tasks.c **** 
2305:../FreeRTOS/Sources/tasks.c ****         vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
2306:../FreeRTOS/Sources/tasks.c **** 	}
2307:../FreeRTOS/Sources/tasks.c **** 
2308:../FreeRTOS/Sources/tasks.c **** #endif /* portUSING_MPU_WRAPPERS */
2309:../FreeRTOS/Sources/tasks.c **** /*-----------------------------------------------------------*/
2310:../FreeRTOS/Sources/tasks.c **** 
2311:../FreeRTOS/Sources/tasks.c **** static void prvInitialiseTaskLists( void )
2312:../FreeRTOS/Sources/tasks.c **** {
 2886              		.loc 1 2312 0
 2887              		.cfi_startproc
 2888              		@ args = 0, pretend = 0, frame = 8
 2889              		@ frame_needed = 1, uses_anonymous_args = 0
 2890 0000 80B5     		push	{r7, lr}
 2891              	.LCFI77:
 2892              		.cfi_def_cfa_offset 8
 2893              		.cfi_offset 7, -8
 2894              		.cfi_offset 14, -4
 2895 0002 82B0     		sub	sp, sp, #8
 2896              	.LCFI78:
 2897              		.cfi_def_cfa_offset 16
 2898 0004 00AF     		add	r7, sp, #0
 2899              	.LCFI79:
 2900              		.cfi_def_cfa_register 7
2313:../FreeRTOS/Sources/tasks.c **** unsigned portBASE_TYPE uxPriority;
2314:../FreeRTOS/Sources/tasks.c **** 
2315:../FreeRTOS/Sources/tasks.c **** 	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
 2901              		.loc 1 2315 0
 2902 0006 4FF00003 		mov	r3, #0
 2903 000a 7B60     		str	r3, [r7, #4]
 2904 000c 12E0     		b	.L166
 2905              	.L167:
2316:../FreeRTOS/Sources/tasks.c **** 	{
2317:../FreeRTOS/Sources/tasks.c **** 		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
 2906              		.loc 1 2317 0 discriminator 2
 2907 000e 7A68     		ldr	r2, [r7, #4]
 2908 0010 1346     		mov	r3, r2
 2909 0012 4FEA8303 		lsl	r3, r3, #2
 2910 0016 9B18     		adds	r3, r3, r2
 2911 0018 4FEA8303 		lsl	r3, r3, #2
 2912 001c 40F20002 		movw	r2, #:lower16:pxReadyTasksLists
 2913 0020 C0F20002 		movt	r2, #:upper16:pxReadyTasksLists
 2914 0024 9B18     		adds	r3, r3, r2
 2915 0026 1846     		mov	r0, r3
 2916 0028 FFF7FEFF 		bl	vListInitialise
2315:../FreeRTOS/Sources/tasks.c **** 	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
 2917              		.loc 1 2315 0 discriminator 2
 2918 002c 7B68     		ldr	r3, [r7, #4]
 2919 002e 03F10103 		add	r3, r3, #1
 2920 0032 7B60     		str	r3, [r7, #4]
 2921              	.L166:
2315:../FreeRTOS/Sources/tasks.c **** 	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
 2922              		.loc 1 2315 0 is_stmt 0 discriminator 1
 2923 0034 7B68     		ldr	r3, [r7, #4]
 2924 0036 042B     		cmp	r3, #4
 2925 0038 E9D9     		bls	.L167
2318:../FreeRTOS/Sources/tasks.c **** 	}
2319:../FreeRTOS/Sources/tasks.c **** 
2320:../FreeRTOS/Sources/tasks.c **** 	vListInitialise( ( xList * ) &xDelayedTaskList1 );
 2926              		.loc 1 2320 0 is_stmt 1
 2927 003a 40F20000 		movw	r0, #:lower16:xDelayedTaskList1
 2928 003e C0F20000 		movt	r0, #:upper16:xDelayedTaskList1
 2929 0042 FFF7FEFF 		bl	vListInitialise
2321:../FreeRTOS/Sources/tasks.c **** 	vListInitialise( ( xList * ) &xDelayedTaskList2 );
 2930              		.loc 1 2321 0
 2931 0046 40F20000 		movw	r0, #:lower16:xDelayedTaskList2
 2932 004a C0F20000 		movt	r0, #:upper16:xDelayedTaskList2
 2933 004e FFF7FEFF 		bl	vListInitialise
2322:../FreeRTOS/Sources/tasks.c **** 	vListInitialise( ( xList * ) &xPendingReadyList );
 2934              		.loc 1 2322 0
 2935 0052 40F20000 		movw	r0, #:lower16:xPendingReadyList
 2936 0056 C0F20000 		movt	r0, #:upper16:xPendingReadyList
 2937 005a FFF7FEFF 		bl	vListInitialise
2323:../FreeRTOS/Sources/tasks.c **** 
2324:../FreeRTOS/Sources/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
2325:../FreeRTOS/Sources/tasks.c **** 	{
2326:../FreeRTOS/Sources/tasks.c **** 		vListInitialise( ( xList * ) &xTasksWaitingTermination );
 2938              		.loc 1 2326 0
 2939 005e 40F20000 		movw	r0, #:lower16:xTasksWaitingTermination
 2940 0062 C0F20000 		movt	r0, #:upper16:xTasksWaitingTermination
 2941 0066 FFF7FEFF 		bl	vListInitialise
2327:../FreeRTOS/Sources/tasks.c **** 	}
2328:../FreeRTOS/Sources/tasks.c **** 	#endif /* INCLUDE_vTaskDelete */
2329:../FreeRTOS/Sources/tasks.c **** 
2330:../FreeRTOS/Sources/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
2331:../FreeRTOS/Sources/tasks.c **** 	{
2332:../FreeRTOS/Sources/tasks.c **** 		vListInitialise( ( xList * ) &xSuspendedTaskList );
 2942              		.loc 1 2332 0
 2943 006a 40F20000 		movw	r0, #:lower16:xSuspendedTaskList
 2944 006e C0F20000 		movt	r0, #:upper16:xSuspendedTaskList
 2945 0072 FFF7FEFF 		bl	vListInitialise
2333:../FreeRTOS/Sources/tasks.c **** 	}
2334:../FreeRTOS/Sources/tasks.c **** 	#endif /* INCLUDE_vTaskSuspend */
2335:../FreeRTOS/Sources/tasks.c **** 
2336:../FreeRTOS/Sources/tasks.c **** 	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
2337:../FreeRTOS/Sources/tasks.c **** 	using list2. */
2338:../FreeRTOS/Sources/tasks.c **** 	pxDelayedTaskList = &xDelayedTaskList1;
 2946              		.loc 1 2338 0
 2947 0076 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 2948 007a C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 2949 007e 40F20002 		movw	r2, #:lower16:xDelayedTaskList1
 2950 0082 C0F20002 		movt	r2, #:upper16:xDelayedTaskList1
 2951 0086 1A60     		str	r2, [r3, #0]
2339:../FreeRTOS/Sources/tasks.c **** 	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 2952              		.loc 1 2339 0
 2953 0088 40F20003 		movw	r3, #:lower16:pxOverflowDelayedTaskList
 2954 008c C0F20003 		movt	r3, #:upper16:pxOverflowDelayedTaskList
 2955 0090 40F20002 		movw	r2, #:lower16:xDelayedTaskList2
 2956 0094 C0F20002 		movt	r2, #:upper16:xDelayedTaskList2
 2957 0098 1A60     		str	r2, [r3, #0]
2340:../FreeRTOS/Sources/tasks.c **** }
 2958              		.loc 1 2340 0
 2959 009a 07F10807 		add	r7, r7, #8
 2960 009e BD46     		mov	sp, r7
 2961 00a0 80BD     		pop	{r7, pc}
 2962              		.cfi_endproc
 2963              	.LFE27:
 2965 00a2 00BF     		.section	.text.prvCheckTasksWaitingTermination,"ax",%progbits
 2966              		.align	2
 2967              		.thumb
 2968              		.thumb_func
 2970              	prvCheckTasksWaitingTermination:
 2971              	.LFB28:
2341:../FreeRTOS/Sources/tasks.c **** /*-----------------------------------------------------------*/
2342:../FreeRTOS/Sources/tasks.c **** 
2343:../FreeRTOS/Sources/tasks.c **** static void prvCheckTasksWaitingTermination( void )
2344:../FreeRTOS/Sources/tasks.c **** {
 2972              		.loc 1 2344 0
 2973              		.cfi_startproc
 2974              		@ args = 0, pretend = 0, frame = 8
 2975              		@ frame_needed = 1, uses_anonymous_args = 0
 2976 0000 80B5     		push	{r7, lr}
 2977              	.LCFI80:
 2978              		.cfi_def_cfa_offset 8
 2979              		.cfi_offset 7, -8
 2980              		.cfi_offset 14, -4
 2981 0002 82B0     		sub	sp, sp, #8
 2982              	.LCFI81:
 2983              		.cfi_def_cfa_offset 16
 2984 0004 00AF     		add	r7, sp, #0
 2985              	.LCFI82:
 2986              		.cfi_def_cfa_register 7
 2987              	.LBB9:
2345:../FreeRTOS/Sources/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
2346:../FreeRTOS/Sources/tasks.c **** 	{
2347:../FreeRTOS/Sources/tasks.c **** 		portBASE_TYPE xListIsEmpty;
2348:../FreeRTOS/Sources/tasks.c **** 
2349:../FreeRTOS/Sources/tasks.c **** 		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
2350:../FreeRTOS/Sources/tasks.c **** 		too often in the idle task. */
2351:../FreeRTOS/Sources/tasks.c **** 		while( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
 2988              		.loc 1 2351 0
 2989 0006 3DE0     		b	.L169
 2990              	.L170:
2352:../FreeRTOS/Sources/tasks.c **** 		{
2353:../FreeRTOS/Sources/tasks.c **** 			vTaskSuspendAll();
 2991              		.loc 1 2353 0
 2992 0008 FFF7FEFF 		bl	vTaskSuspendAll
2354:../FreeRTOS/Sources/tasks.c **** 				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 2993              		.loc 1 2354 0
 2994 000c 40F20003 		movw	r3, #:lower16:xTasksWaitingTermination
 2995 0010 C0F20003 		movt	r3, #:upper16:xTasksWaitingTermination
 2996 0014 1B68     		ldr	r3, [r3, #0]
 2997 0016 002B     		cmp	r3, #0
 2998 0018 14BF     		ite	ne
 2999 001a 0023     		movne	r3, #0
 3000 001c 0123     		moveq	r3, #1
 3001 001e DBB2     		uxtb	r3, r3
 3002 0020 7B60     		str	r3, [r7, #4]
2355:../FreeRTOS/Sources/tasks.c **** 			xTaskResumeAll();
 3003              		.loc 1 2355 0
 3004 0022 FFF7FEFF 		bl	xTaskResumeAll
2356:../FreeRTOS/Sources/tasks.c **** 
2357:../FreeRTOS/Sources/tasks.c **** 			if( xListIsEmpty == pdFALSE )
 3005              		.loc 1 2357 0
 3006 0026 7B68     		ldr	r3, [r7, #4]
 3007 0028 002B     		cmp	r3, #0
 3008 002a 2BD1     		bne	.L169
 3009              	.LBB10:
2358:../FreeRTOS/Sources/tasks.c **** 			{
2359:../FreeRTOS/Sources/tasks.c **** 				tskTCB *pxTCB;
2360:../FreeRTOS/Sources/tasks.c **** 
2361:../FreeRTOS/Sources/tasks.c **** 				taskENTER_CRITICAL();
 3010              		.loc 1 2361 0
 3011 002c FFF7FEFF 		bl	vPortEnterCritical
2362:../FreeRTOS/Sources/tasks.c **** 				{
2363:../FreeRTOS/Sources/tasks.c **** 					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
 3012              		.loc 1 2363 0
 3013 0030 40F20003 		movw	r3, #:lower16:xTasksWaitingTermination
 3014 0034 C0F20003 		movt	r3, #:upper16:xTasksWaitingTermination
 3015 0038 DB68     		ldr	r3, [r3, #12]
 3016 003a DB68     		ldr	r3, [r3, #12]
 3017 003c 3B60     		str	r3, [r7, #0]
2364:../FreeRTOS/Sources/tasks.c **** 					uxListRemove( &( pxTCB->xGenericListItem ) );
 3018              		.loc 1 2364 0
 3019 003e 3B68     		ldr	r3, [r7, #0]
 3020 0040 03F10403 		add	r3, r3, #4
 3021 0044 1846     		mov	r0, r3
 3022 0046 FFF7FEFF 		bl	uxListRemove
2365:../FreeRTOS/Sources/tasks.c **** 					--uxCurrentNumberOfTasks;
 3023              		.loc 1 2365 0
 3024 004a 40F20003 		movw	r3, #:lower16:uxCurrentNumberOfTasks
 3025 004e C0F20003 		movt	r3, #:upper16:uxCurrentNumberOfTasks
 3026 0052 1B68     		ldr	r3, [r3, #0]
 3027 0054 03F1FF32 		add	r2, r3, #-1
 3028 0058 40F20003 		movw	r3, #:lower16:uxCurrentNumberOfTasks
 3029 005c C0F20003 		movt	r3, #:upper16:uxCurrentNumberOfTasks
 3030 0060 1A60     		str	r2, [r3, #0]
2366:../FreeRTOS/Sources/tasks.c **** 					--uxTasksDeleted;
 3031              		.loc 1 2366 0
 3032 0062 40F20003 		movw	r3, #:lower16:uxTasksDeleted
 3033 0066 C0F20003 		movt	r3, #:upper16:uxTasksDeleted
 3034 006a 1B68     		ldr	r3, [r3, #0]
 3035 006c 03F1FF32 		add	r2, r3, #-1
 3036 0070 40F20003 		movw	r3, #:lower16:uxTasksDeleted
 3037 0074 C0F20003 		movt	r3, #:upper16:uxTasksDeleted
 3038 0078 1A60     		str	r2, [r3, #0]
2367:../FreeRTOS/Sources/tasks.c **** 				}
2368:../FreeRTOS/Sources/tasks.c **** 				taskEXIT_CRITICAL();
 3039              		.loc 1 2368 0
 3040 007a FFF7FEFF 		bl	vPortExitCritical
2369:../FreeRTOS/Sources/tasks.c **** 
2370:../FreeRTOS/Sources/tasks.c **** 				prvDeleteTCB( pxTCB );
 3041              		.loc 1 2370 0
 3042 007e 3868     		ldr	r0, [r7, #0]
 3043 0080 FFF7FEFF 		bl	prvDeleteTCB
 3044              	.L169:
 3045              	.LBE10:
2351:../FreeRTOS/Sources/tasks.c **** 		while( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
 3046              		.loc 1 2351 0 discriminator 1
 3047 0084 40F20003 		movw	r3, #:lower16:uxTasksDeleted
 3048 0088 C0F20003 		movt	r3, #:upper16:uxTasksDeleted
 3049 008c 1B68     		ldr	r3, [r3, #0]
 3050 008e 002B     		cmp	r3, #0
 3051 0090 BAD1     		bne	.L170
 3052              	.LBE9:
2371:../FreeRTOS/Sources/tasks.c **** 			}
2372:../FreeRTOS/Sources/tasks.c **** 		}
2373:../FreeRTOS/Sources/tasks.c **** 	}
2374:../FreeRTOS/Sources/tasks.c **** 	#endif /* vTaskDelete */
2375:../FreeRTOS/Sources/tasks.c **** }
 3053              		.loc 1 2375 0
 3054 0092 07F10807 		add	r7, r7, #8
 3055 0096 BD46     		mov	sp, r7
 3056 0098 80BD     		pop	{r7, pc}
 3057              		.cfi_endproc
 3058              	.LFE28:
 3060 009a 00BF     		.section	.text.prvAddCurrentTaskToDelayedList,"ax",%progbits
 3061              		.align	2
 3062              		.thumb
 3063              		.thumb_func
 3065              	prvAddCurrentTaskToDelayedList:
 3066              	.LFB29:
2376:../FreeRTOS/Sources/tasks.c **** /*-----------------------------------------------------------*/
2377:../FreeRTOS/Sources/tasks.c **** 
2378:../FreeRTOS/Sources/tasks.c **** static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
2379:../FreeRTOS/Sources/tasks.c **** {
 3067              		.loc 1 2379 0
 3068              		.cfi_startproc
 3069              		@ args = 0, pretend = 0, frame = 8
 3070              		@ frame_needed = 1, uses_anonymous_args = 0
 3071 0000 80B5     		push	{r7, lr}
 3072              	.LCFI83:
 3073              		.cfi_def_cfa_offset 8
 3074              		.cfi_offset 7, -8
 3075              		.cfi_offset 14, -4
 3076 0002 82B0     		sub	sp, sp, #8
 3077              	.LCFI84:
 3078              		.cfi_def_cfa_offset 16
 3079 0004 00AF     		add	r7, sp, #0
 3080              	.LCFI85:
 3081              		.cfi_def_cfa_register 7
 3082 0006 7860     		str	r0, [r7, #4]
2380:../FreeRTOS/Sources/tasks.c **** 	/* The list item will be inserted in wake time order. */
2381:../FreeRTOS/Sources/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 3083              		.loc 1 2381 0
 3084 0008 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 3085 000c C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 3086 0010 1B68     		ldr	r3, [r3, #0]
 3087 0012 7A68     		ldr	r2, [r7, #4]
 3088 0014 5A60     		str	r2, [r3, #4]
2382:../FreeRTOS/Sources/tasks.c **** 
2383:../FreeRTOS/Sources/tasks.c **** 	if( xTimeToWake < xTickCount )
 3089              		.loc 1 2383 0
 3090 0016 40F20003 		movw	r3, #:lower16:xTickCount
 3091 001a C0F20003 		movt	r3, #:upper16:xTickCount
 3092 001e 1B68     		ldr	r3, [r3, #0]
 3093 0020 7A68     		ldr	r2, [r7, #4]
 3094 0022 9A42     		cmp	r2, r3
 3095 0024 10D2     		bcs	.L172
2384:../FreeRTOS/Sources/tasks.c **** 	{
2385:../FreeRTOS/Sources/tasks.c **** 		/* Wake time has overflowed.  Place this item in the overflow list. */
2386:../FreeRTOS/Sources/tasks.c **** 		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericList
 3096              		.loc 1 2386 0
 3097 0026 40F20003 		movw	r3, #:lower16:pxOverflowDelayedTaskList
 3098 002a C0F20003 		movt	r3, #:upper16:pxOverflowDelayedTaskList
 3099 002e 1A68     		ldr	r2, [r3, #0]
 3100 0030 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 3101 0034 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 3102 0038 1B68     		ldr	r3, [r3, #0]
 3103 003a 03F10403 		add	r3, r3, #4
 3104 003e 1046     		mov	r0, r2
 3105 0040 1946     		mov	r1, r3
 3106 0042 FFF7FEFF 		bl	vListInsert
 3107 0046 1DE0     		b	.L171
 3108              	.L172:
2387:../FreeRTOS/Sources/tasks.c **** 	}
2388:../FreeRTOS/Sources/tasks.c **** 	else
2389:../FreeRTOS/Sources/tasks.c **** 	{
2390:../FreeRTOS/Sources/tasks.c **** 		/* The wake time has not overflowed, so we can use the current block list. */
2391:../FreeRTOS/Sources/tasks.c **** 		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) )
 3109              		.loc 1 2391 0
 3110 0048 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 3111 004c C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 3112 0050 1A68     		ldr	r2, [r3, #0]
 3113 0052 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 3114 0056 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 3115 005a 1B68     		ldr	r3, [r3, #0]
 3116 005c 03F10403 		add	r3, r3, #4
 3117 0060 1046     		mov	r0, r2
 3118 0062 1946     		mov	r1, r3
 3119 0064 FFF7FEFF 		bl	vListInsert
2392:../FreeRTOS/Sources/tasks.c **** 
2393:../FreeRTOS/Sources/tasks.c **** 		/* If the task entering the blocked state was placed at the head of the
2394:../FreeRTOS/Sources/tasks.c **** 		list of blocked tasks then xNextTaskUnblockTime needs to be updated
2395:../FreeRTOS/Sources/tasks.c **** 		too. */
2396:../FreeRTOS/Sources/tasks.c **** 		if( xTimeToWake < xNextTaskUnblockTime )
 3120              		.loc 1 2396 0
 3121 0068 40F20003 		movw	r3, #:lower16:xNextTaskUnblockTime
 3122 006c C0F20003 		movt	r3, #:upper16:xNextTaskUnblockTime
 3123 0070 1B68     		ldr	r3, [r3, #0]
 3124 0072 7A68     		ldr	r2, [r7, #4]
 3125 0074 9A42     		cmp	r2, r3
 3126 0076 05D2     		bcs	.L171
2397:../FreeRTOS/Sources/tasks.c **** 		{
2398:../FreeRTOS/Sources/tasks.c **** 			xNextTaskUnblockTime = xTimeToWake;
 3127              		.loc 1 2398 0
 3128 0078 40F20003 		movw	r3, #:lower16:xNextTaskUnblockTime
 3129 007c C0F20003 		movt	r3, #:upper16:xNextTaskUnblockTime
 3130 0080 7A68     		ldr	r2, [r7, #4]
 3131 0082 1A60     		str	r2, [r3, #0]
 3132              	.L171:
2399:../FreeRTOS/Sources/tasks.c **** 		}
2400:../FreeRTOS/Sources/tasks.c **** 	}
2401:../FreeRTOS/Sources/tasks.c **** }
 3133              		.loc 1 2401 0
 3134 0084 07F10807 		add	r7, r7, #8
 3135 0088 BD46     		mov	sp, r7
 3136 008a 80BD     		pop	{r7, pc}
 3137              		.cfi_endproc
 3138              	.LFE29:
 3140              		.section	.text.prvAllocateTCBAndStack,"ax",%progbits
 3141              		.align	2
 3142              		.thumb
 3143              		.thumb_func
 3145              	prvAllocateTCBAndStack:
 3146              	.LFB30:
2402:../FreeRTOS/Sources/tasks.c **** /*-----------------------------------------------------------*/
2403:../FreeRTOS/Sources/tasks.c **** 
2404:../FreeRTOS/Sources/tasks.c **** static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer 
2405:../FreeRTOS/Sources/tasks.c **** {
 3147              		.loc 1 2405 0
 3148              		.cfi_startproc
 3149              		@ args = 0, pretend = 0, frame = 16
 3150              		@ frame_needed = 1, uses_anonymous_args = 0
 3151 0000 80B5     		push	{r7, lr}
 3152              	.LCFI86:
 3153              		.cfi_def_cfa_offset 8
 3154              		.cfi_offset 7, -8
 3155              		.cfi_offset 14, -4
 3156 0002 84B0     		sub	sp, sp, #16
 3157              	.LCFI87:
 3158              		.cfi_def_cfa_offset 24
 3159 0004 00AF     		add	r7, sp, #0
 3160              	.LCFI88:
 3161              		.cfi_def_cfa_register 7
 3162 0006 0346     		mov	r3, r0
 3163 0008 3960     		str	r1, [r7, #0]
 3164 000a FB80     		strh	r3, [r7, #6]	@ movhi
2406:../FreeRTOS/Sources/tasks.c **** tskTCB *pxNewTCB;
2407:../FreeRTOS/Sources/tasks.c **** 
2408:../FreeRTOS/Sources/tasks.c **** 	/* Allocate space for the TCB.  Where the memory comes from depends on
2409:../FreeRTOS/Sources/tasks.c **** 	the implementation of the port malloc function. */
2410:../FreeRTOS/Sources/tasks.c **** 	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
 3165              		.loc 1 2410 0
 3166 000c 4FF04400 		mov	r0, #68
 3167 0010 FFF7FEFF 		bl	pvPortMalloc
 3168 0014 F860     		str	r0, [r7, #12]
2411:../FreeRTOS/Sources/tasks.c **** 
2412:../FreeRTOS/Sources/tasks.c **** 	if( pxNewTCB != NULL )
 3169              		.loc 1 2412 0
 3170 0016 FB68     		ldr	r3, [r7, #12]
 3171 0018 002B     		cmp	r3, #0
 3172 001a 23D0     		beq	.L175
2413:../FreeRTOS/Sources/tasks.c **** 	{
2414:../FreeRTOS/Sources/tasks.c **** 		/* Allocate space for the stack used by the task being created.
2415:../FreeRTOS/Sources/tasks.c **** 		The base of the stack memory stored in the TCB so the task can
2416:../FreeRTOS/Sources/tasks.c **** 		be deleted later if required. */
2417:../FreeRTOS/Sources/tasks.c **** 		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * size
 3173              		.loc 1 2417 0
 3174 001c 3B68     		ldr	r3, [r7, #0]
 3175 001e 002B     		cmp	r3, #0
 3176 0020 07D1     		bne	.L176
 3177              		.loc 1 2417 0 is_stmt 0 discriminator 1
 3178 0022 FB88     		ldrh	r3, [r7, #6]
 3179 0024 4FEA8303 		lsl	r3, r3, #2
 3180 0028 1846     		mov	r0, r3
 3181 002a FFF7FEFF 		bl	pvPortMalloc
 3182 002e 0346     		mov	r3, r0
 3183 0030 00E0     		b	.L177
 3184              	.L176:
 3185              		.loc 1 2417 0 discriminator 2
 3186 0032 3B68     		ldr	r3, [r7, #0]
 3187              	.L177:
 3188              		.loc 1 2417 0 discriminator 3
 3189 0034 FA68     		ldr	r2, [r7, #12]
 3190 0036 1363     		str	r3, [r2, #48]
2418:../FreeRTOS/Sources/tasks.c **** 
2419:../FreeRTOS/Sources/tasks.c **** 		if( pxNewTCB->pxStack == NULL )
 3191              		.loc 1 2419 0 is_stmt 1 discriminator 3
 3192 0038 FB68     		ldr	r3, [r7, #12]
 3193 003a 1B6B     		ldr	r3, [r3, #48]
 3194 003c 002B     		cmp	r3, #0
 3195 003e 06D1     		bne	.L178
2420:../FreeRTOS/Sources/tasks.c **** 		{
2421:../FreeRTOS/Sources/tasks.c **** 			/* Could not allocate the stack.  Delete the allocated TCB. */
2422:../FreeRTOS/Sources/tasks.c **** 			vPortFree( pxNewTCB );
 3196              		.loc 1 2422 0
 3197 0040 F868     		ldr	r0, [r7, #12]
 3198 0042 FFF7FEFF 		bl	vPortFree
2423:../FreeRTOS/Sources/tasks.c **** 			pxNewTCB = NULL;
 3199              		.loc 1 2423 0
 3200 0046 4FF00003 		mov	r3, #0
 3201 004a FB60     		str	r3, [r7, #12]
 3202 004c 0AE0     		b	.L175
 3203              	.L178:
2424:../FreeRTOS/Sources/tasks.c **** 		}
2425:../FreeRTOS/Sources/tasks.c **** 		else
2426:../FreeRTOS/Sources/tasks.c **** 		{
2427:../FreeRTOS/Sources/tasks.c **** 			/* Just to help debugging. */
2428:../FreeRTOS/Sources/tasks.c **** 			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTA
 3204              		.loc 1 2428 0
 3205 004e FB68     		ldr	r3, [r7, #12]
 3206 0050 1A6B     		ldr	r2, [r3, #48]
 3207 0052 FB88     		ldrh	r3, [r7, #6]
 3208 0054 4FEA8303 		lsl	r3, r3, #2
 3209 0058 1046     		mov	r0, r2
 3210 005a 4FF0A501 		mov	r1, #165
 3211 005e 1A46     		mov	r2, r3
 3212 0060 FFF7FEFF 		bl	memset
 3213              	.L175:
2429:../FreeRTOS/Sources/tasks.c **** 		}
2430:../FreeRTOS/Sources/tasks.c **** 	}
2431:../FreeRTOS/Sources/tasks.c **** 
2432:../FreeRTOS/Sources/tasks.c **** 	return pxNewTCB;
 3214              		.loc 1 2432 0
 3215 0064 FB68     		ldr	r3, [r7, #12]
2433:../FreeRTOS/Sources/tasks.c **** }
 3216              		.loc 1 2433 0
 3217 0066 1846     		mov	r0, r3
 3218 0068 07F11007 		add	r7, r7, #16
 3219 006c BD46     		mov	sp, r7
 3220 006e 80BD     		pop	{r7, pc}
 3221              		.cfi_endproc
 3222              	.LFE30:
 3224              		.section	.text.prvDeleteTCB,"ax",%progbits
 3225              		.align	2
 3226              		.thumb
 3227              		.thumb_func
 3229              	prvDeleteTCB:
 3230              	.LFB31:
2434:../FreeRTOS/Sources/tasks.c **** /*-----------------------------------------------------------*/
2435:../FreeRTOS/Sources/tasks.c **** 
2436:../FreeRTOS/Sources/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2437:../FreeRTOS/Sources/tasks.c **** 
2438:../FreeRTOS/Sources/tasks.c **** 	static void prvListTaskWithinSingleList( const signed char *pcWriteBuffer, xList *pxList, signed c
2439:../FreeRTOS/Sources/tasks.c **** 	{
2440:../FreeRTOS/Sources/tasks.c **** 	volatile tskTCB *pxNextTCB, *pxFirstTCB;
2441:../FreeRTOS/Sources/tasks.c **** 	unsigned short usStackRemaining;
2442:../FreeRTOS/Sources/tasks.c **** 	PRIVILEGED_DATA static char pcStatusString[ configMAX_TASK_NAME_LEN + 30 ];
2443:../FreeRTOS/Sources/tasks.c **** 
2444:../FreeRTOS/Sources/tasks.c **** 		/* Write the details of all the TCB's in pxList into the buffer. */
2445:../FreeRTOS/Sources/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
2446:../FreeRTOS/Sources/tasks.c **** 		do
2447:../FreeRTOS/Sources/tasks.c **** 		{
2448:../FreeRTOS/Sources/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
2449:../FreeRTOS/Sources/tasks.c **** 			#if ( portSTACK_GROWTH > 0 )
2450:../FreeRTOS/Sources/tasks.c **** 			{
2451:../FreeRTOS/Sources/tasks.c **** 				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxEndOfStack );
2452:../FreeRTOS/Sources/tasks.c **** 			}
2453:../FreeRTOS/Sources/tasks.c **** 			#else
2454:../FreeRTOS/Sources/tasks.c **** 			{
2455:../FreeRTOS/Sources/tasks.c **** 				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxStack );
2456:../FreeRTOS/Sources/tasks.c **** 			}
2457:../FreeRTOS/Sources/tasks.c **** 			#endif
2458:../FreeRTOS/Sources/tasks.c **** 
2459:../FreeRTOS/Sources/tasks.c **** 			sprintf( pcStatusString, ( char * ) "%s\t\t%c\t%u\t%u\t%u\r\n", pxNextTCB->pcTaskName, cStatus, 
2460:../FreeRTOS/Sources/tasks.c **** 			strcat( ( char * ) pcWriteBuffer, ( char * ) pcStatusString );
2461:../FreeRTOS/Sources/tasks.c **** 
2462:../FreeRTOS/Sources/tasks.c **** 		} while( pxNextTCB != pxFirstTCB );
2463:../FreeRTOS/Sources/tasks.c **** 	}
2464:../FreeRTOS/Sources/tasks.c **** 
2465:../FreeRTOS/Sources/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
2466:../FreeRTOS/Sources/tasks.c **** /*-----------------------------------------------------------*/
2467:../FreeRTOS/Sources/tasks.c **** 
2468:../FreeRTOS/Sources/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
2469:../FreeRTOS/Sources/tasks.c **** 
2470:../FreeRTOS/Sources/tasks.c **** 	static void prvGenerateRunTimeStatsForTasksInList( const signed char *pcWriteBuffer, xList *pxList
2471:../FreeRTOS/Sources/tasks.c **** 	{
2472:../FreeRTOS/Sources/tasks.c **** 	volatile tskTCB *pxNextTCB, *pxFirstTCB;
2473:../FreeRTOS/Sources/tasks.c **** 	unsigned long ulStatsAsPercentage;
2474:../FreeRTOS/Sources/tasks.c **** 
2475:../FreeRTOS/Sources/tasks.c **** 		/* Write the run time stats of all the TCB's in pxList into the buffer. */
2476:../FreeRTOS/Sources/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
2477:../FreeRTOS/Sources/tasks.c **** 		do
2478:../FreeRTOS/Sources/tasks.c **** 		{
2479:../FreeRTOS/Sources/tasks.c **** 			/* Get next TCB in from the list. */
2480:../FreeRTOS/Sources/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
2481:../FreeRTOS/Sources/tasks.c **** 
2482:../FreeRTOS/Sources/tasks.c **** 			/* Divide by zero check. */
2483:../FreeRTOS/Sources/tasks.c **** 			if( ulTotalRunTimeDiv100 > 0UL )
2484:../FreeRTOS/Sources/tasks.c **** 			{
2485:../FreeRTOS/Sources/tasks.c **** 				/* Has the task run at all? */
2486:../FreeRTOS/Sources/tasks.c **** 				if( pxNextTCB->ulRunTimeCounter == 0UL )
2487:../FreeRTOS/Sources/tasks.c **** 				{
2488:../FreeRTOS/Sources/tasks.c **** 					/* The task has used no CPU time at all. */
2489:../FreeRTOS/Sources/tasks.c **** 					sprintf( pcStatsString, ( char * ) "%s\t\t0\t\t0%%\r\n", pxNextTCB->pcTaskName );
2490:../FreeRTOS/Sources/tasks.c **** 				}
2491:../FreeRTOS/Sources/tasks.c **** 				else
2492:../FreeRTOS/Sources/tasks.c **** 				{
2493:../FreeRTOS/Sources/tasks.c **** 					/* What percentage of the total run time has the task used?
2494:../FreeRTOS/Sources/tasks.c **** 					This will always be rounded down to the nearest integer.
2495:../FreeRTOS/Sources/tasks.c **** 					ulTotalRunTimeDiv100 has already been divided by 100. */
2496:../FreeRTOS/Sources/tasks.c **** 					ulStatsAsPercentage = pxNextTCB->ulRunTimeCounter / ulTotalRunTimeDiv100;
2497:../FreeRTOS/Sources/tasks.c **** 
2498:../FreeRTOS/Sources/tasks.c **** 					if( ulStatsAsPercentage > 0UL )
2499:../FreeRTOS/Sources/tasks.c **** 					{
2500:../FreeRTOS/Sources/tasks.c **** 						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
2501:../FreeRTOS/Sources/tasks.c **** 						{
2502:../FreeRTOS/Sources/tasks.c **** 							sprintf( pcStatsString, ( char * ) "%s\t\t%lu\t\t%lu%%\r\n", pxNextTCB->pcTaskName, pxNextTC
2503:../FreeRTOS/Sources/tasks.c **** 						}
2504:../FreeRTOS/Sources/tasks.c **** 						#else
2505:../FreeRTOS/Sources/tasks.c **** 						{
2506:../FreeRTOS/Sources/tasks.c **** 							/* sizeof( int ) == sizeof( long ) so a smaller
2507:../FreeRTOS/Sources/tasks.c **** 							printf() library can be used. */
2508:../FreeRTOS/Sources/tasks.c **** 							sprintf( pcStatsString, ( char * ) "%s\t\t%u\t\t%u%%\r\n", pxNextTCB->pcTaskName, ( unsigned
2509:../FreeRTOS/Sources/tasks.c **** 						}
2510:../FreeRTOS/Sources/tasks.c **** 						#endif
2511:../FreeRTOS/Sources/tasks.c **** 					}
2512:../FreeRTOS/Sources/tasks.c **** 					else
2513:../FreeRTOS/Sources/tasks.c **** 					{
2514:../FreeRTOS/Sources/tasks.c **** 						/* If the percentage is zero here then the task has
2515:../FreeRTOS/Sources/tasks.c **** 						consumed less than 1% of the total run time. */
2516:../FreeRTOS/Sources/tasks.c **** 						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
2517:../FreeRTOS/Sources/tasks.c **** 						{
2518:../FreeRTOS/Sources/tasks.c **** 							sprintf( pcStatsString, ( char * ) "%s\t\t%lu\t\t<1%%\r\n", pxNextTCB->pcTaskName, pxNextTCB
2519:../FreeRTOS/Sources/tasks.c **** 						}
2520:../FreeRTOS/Sources/tasks.c **** 						#else
2521:../FreeRTOS/Sources/tasks.c **** 						{
2522:../FreeRTOS/Sources/tasks.c **** 							/* sizeof( int ) == sizeof( long ) so a smaller
2523:../FreeRTOS/Sources/tasks.c **** 							printf() library can be used. */
2524:../FreeRTOS/Sources/tasks.c **** 							sprintf( pcStatsString, ( char * ) "%s\t\t%u\t\t<1%%\r\n", pxNextTCB->pcTaskName, ( unsigned
2525:../FreeRTOS/Sources/tasks.c **** 						}
2526:../FreeRTOS/Sources/tasks.c **** 						#endif
2527:../FreeRTOS/Sources/tasks.c **** 					}
2528:../FreeRTOS/Sources/tasks.c **** 				}
2529:../FreeRTOS/Sources/tasks.c **** 
2530:../FreeRTOS/Sources/tasks.c **** 				strcat( ( char * ) pcWriteBuffer, ( char * ) pcStatsString );
2531:../FreeRTOS/Sources/tasks.c **** 			}
2532:../FreeRTOS/Sources/tasks.c **** 
2533:../FreeRTOS/Sources/tasks.c **** 		} while( pxNextTCB != pxFirstTCB );
2534:../FreeRTOS/Sources/tasks.c **** 	}
2535:../FreeRTOS/Sources/tasks.c **** 
2536:../FreeRTOS/Sources/tasks.c **** #endif /* configGENERATE_RUN_TIME_STATS */
2537:../FreeRTOS/Sources/tasks.c **** /*-----------------------------------------------------------*/
2538:../FreeRTOS/Sources/tasks.c **** 
2539:../FreeRTOS/Sources/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
2540:../FreeRTOS/Sources/tasks.c **** 
2541:../FreeRTOS/Sources/tasks.c **** 	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
2542:../FreeRTOS/Sources/tasks.c **** 	{
2543:../FreeRTOS/Sources/tasks.c **** 	register unsigned short usCount = 0U;
2544:../FreeRTOS/Sources/tasks.c **** 
2545:../FreeRTOS/Sources/tasks.c **** 		while( *pucStackByte == tskSTACK_FILL_BYTE )
2546:../FreeRTOS/Sources/tasks.c **** 		{
2547:../FreeRTOS/Sources/tasks.c **** 			pucStackByte -= portSTACK_GROWTH;
2548:../FreeRTOS/Sources/tasks.c **** 			usCount++;
2549:../FreeRTOS/Sources/tasks.c **** 		}
2550:../FreeRTOS/Sources/tasks.c **** 
2551:../FreeRTOS/Sources/tasks.c **** 		usCount /= sizeof( portSTACK_TYPE );
2552:../FreeRTOS/Sources/tasks.c **** 
2553:../FreeRTOS/Sources/tasks.c **** 		return usCount;
2554:../FreeRTOS/Sources/tasks.c **** 	}
2555:../FreeRTOS/Sources/tasks.c **** 
2556:../FreeRTOS/Sources/tasks.c **** #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) */
2557:../FreeRTOS/Sources/tasks.c **** /*-----------------------------------------------------------*/
2558:../FreeRTOS/Sources/tasks.c **** 
2559:../FreeRTOS/Sources/tasks.c **** #if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
2560:../FreeRTOS/Sources/tasks.c **** 
2561:../FreeRTOS/Sources/tasks.c **** 	unsigned portBASE_TYPE uxTaskGetStackHighWaterMark( xTaskHandle xTask )
2562:../FreeRTOS/Sources/tasks.c **** 	{
2563:../FreeRTOS/Sources/tasks.c **** 	tskTCB *pxTCB;
2564:../FreeRTOS/Sources/tasks.c **** 	unsigned char *pcEndOfStack;
2565:../FreeRTOS/Sources/tasks.c **** 	unsigned portBASE_TYPE uxReturn;
2566:../FreeRTOS/Sources/tasks.c **** 
2567:../FreeRTOS/Sources/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
2568:../FreeRTOS/Sources/tasks.c **** 
2569:../FreeRTOS/Sources/tasks.c **** 		#if portSTACK_GROWTH < 0
2570:../FreeRTOS/Sources/tasks.c **** 		{
2571:../FreeRTOS/Sources/tasks.c **** 			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
2572:../FreeRTOS/Sources/tasks.c **** 		}
2573:../FreeRTOS/Sources/tasks.c **** 		#else
2574:../FreeRTOS/Sources/tasks.c **** 		{
2575:../FreeRTOS/Sources/tasks.c **** 			pcEndOfStack = ( unsigned char * ) pxTCB->pxEndOfStack;
2576:../FreeRTOS/Sources/tasks.c **** 		}
2577:../FreeRTOS/Sources/tasks.c **** 		#endif
2578:../FreeRTOS/Sources/tasks.c **** 
2579:../FreeRTOS/Sources/tasks.c **** 		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );
2580:../FreeRTOS/Sources/tasks.c **** 
2581:../FreeRTOS/Sources/tasks.c **** 		return uxReturn;
2582:../FreeRTOS/Sources/tasks.c **** 	}
2583:../FreeRTOS/Sources/tasks.c **** 
2584:../FreeRTOS/Sources/tasks.c **** #endif /* INCLUDE_uxTaskGetStackHighWaterMark */
2585:../FreeRTOS/Sources/tasks.c **** /*-----------------------------------------------------------*/
2586:../FreeRTOS/Sources/tasks.c **** 
2587:../FreeRTOS/Sources/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
2588:../FreeRTOS/Sources/tasks.c **** 
2589:../FreeRTOS/Sources/tasks.c **** 	static void prvDeleteTCB( tskTCB *pxTCB )
2590:../FreeRTOS/Sources/tasks.c **** 	{
 3231              		.loc 1 2590 0
 3232              		.cfi_startproc
 3233              		@ args = 0, pretend = 0, frame = 8
 3234              		@ frame_needed = 1, uses_anonymous_args = 0
 3235 0000 80B5     		push	{r7, lr}
 3236              	.LCFI89:
 3237              		.cfi_def_cfa_offset 8
 3238              		.cfi_offset 7, -8
 3239              		.cfi_offset 14, -4
 3240 0002 82B0     		sub	sp, sp, #8
 3241              	.LCFI90:
 3242              		.cfi_def_cfa_offset 16
 3243 0004 00AF     		add	r7, sp, #0
 3244              	.LCFI91:
 3245              		.cfi_def_cfa_register 7
 3246 0006 7860     		str	r0, [r7, #4]
2591:../FreeRTOS/Sources/tasks.c **** 		/* This call is required specifically for the TriCore port.  It must be
2592:../FreeRTOS/Sources/tasks.c **** 		above the vPortFree() calls.  The call is also used by ports/demos that
2593:../FreeRTOS/Sources/tasks.c **** 		want to allocate and clean RAM statically. */
2594:../FreeRTOS/Sources/tasks.c **** 		portCLEAN_UP_TCB( pxTCB );
2595:../FreeRTOS/Sources/tasks.c **** 
2596:../FreeRTOS/Sources/tasks.c **** 		/* Free up the memory allocated by the scheduler for the task.  It is up to
2597:../FreeRTOS/Sources/tasks.c **** 		the task to free any memory allocated at the application level. */
2598:../FreeRTOS/Sources/tasks.c **** 		vPortFreeAligned( pxTCB->pxStack );
 3247              		.loc 1 2598 0
 3248 0008 7B68     		ldr	r3, [r7, #4]
 3249 000a 1B6B     		ldr	r3, [r3, #48]
 3250 000c 1846     		mov	r0, r3
 3251 000e FFF7FEFF 		bl	vPortFree
2599:../FreeRTOS/Sources/tasks.c **** 		vPortFree( pxTCB );
 3252              		.loc 1 2599 0
 3253 0012 7868     		ldr	r0, [r7, #4]
 3254 0014 FFF7FEFF 		bl	vPortFree
2600:../FreeRTOS/Sources/tasks.c **** 	}
 3255              		.loc 1 2600 0
 3256 0018 07F10807 		add	r7, r7, #8
 3257 001c BD46     		mov	sp, r7
 3258 001e 80BD     		pop	{r7, pc}
 3259              		.cfi_endproc
 3260              	.LFE31:
 3262              		.section	.text.xTaskGetCurrentTaskHandle,"ax",%progbits
 3263              		.align	2
 3264              		.global	xTaskGetCurrentTaskHandle
 3265              		.thumb
 3266              		.thumb_func
 3268              	xTaskGetCurrentTaskHandle:
 3269              	.LFB32:
2601:../FreeRTOS/Sources/tasks.c **** 
2602:../FreeRTOS/Sources/tasks.c **** #endif /* INCLUDE_vTaskDelete */
2603:../FreeRTOS/Sources/tasks.c **** /*-----------------------------------------------------------*/
2604:../FreeRTOS/Sources/tasks.c **** 
2605:../FreeRTOS/Sources/tasks.c **** #if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )
2606:../FreeRTOS/Sources/tasks.c **** 
2607:../FreeRTOS/Sources/tasks.c **** 	xTaskHandle xTaskGetCurrentTaskHandle( void )
2608:../FreeRTOS/Sources/tasks.c **** 	{
 3270              		.loc 1 2608 0
 3271              		.cfi_startproc
 3272              		@ args = 0, pretend = 0, frame = 8
 3273              		@ frame_needed = 1, uses_anonymous_args = 0
 3274              		@ link register save eliminated.
 3275 0000 80B4     		push	{r7}
 3276              	.LCFI92:
 3277              		.cfi_def_cfa_offset 4
 3278              		.cfi_offset 7, -4
 3279 0002 83B0     		sub	sp, sp, #12
 3280              	.LCFI93:
 3281              		.cfi_def_cfa_offset 16
 3282 0004 00AF     		add	r7, sp, #0
 3283              	.LCFI94:
 3284              		.cfi_def_cfa_register 7
2609:../FreeRTOS/Sources/tasks.c **** 	xTaskHandle xReturn;
2610:../FreeRTOS/Sources/tasks.c **** 
2611:../FreeRTOS/Sources/tasks.c **** 		/* A critical section is not required as this is not called from
2612:../FreeRTOS/Sources/tasks.c **** 		an interrupt and the current TCB will always be the same for any
2613:../FreeRTOS/Sources/tasks.c **** 		individual execution thread. */
2614:../FreeRTOS/Sources/tasks.c **** 		xReturn = pxCurrentTCB;
 3285              		.loc 1 2614 0
 3286 0006 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 3287 000a C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 3288 000e 1B68     		ldr	r3, [r3, #0]
 3289 0010 7B60     		str	r3, [r7, #4]
2615:../FreeRTOS/Sources/tasks.c **** 
2616:../FreeRTOS/Sources/tasks.c **** 		return xReturn;
 3290              		.loc 1 2616 0
 3291 0012 7B68     		ldr	r3, [r7, #4]
2617:../FreeRTOS/Sources/tasks.c **** 	}
 3292              		.loc 1 2617 0
 3293 0014 1846     		mov	r0, r3
 3294 0016 07F10C07 		add	r7, r7, #12
 3295 001a BD46     		mov	sp, r7
 3296 001c 80BC     		pop	{r7}
 3297 001e 7047     		bx	lr
 3298              		.cfi_endproc
 3299              	.LFE32:
 3301              		.section	.text.xTaskGetSchedulerState,"ax",%progbits
 3302              		.align	2
 3303              		.global	xTaskGetSchedulerState
 3304              		.thumb
 3305              		.thumb_func
 3307              	xTaskGetSchedulerState:
 3308              	.LFB33:
2618:../FreeRTOS/Sources/tasks.c **** 
2619:../FreeRTOS/Sources/tasks.c **** #endif /* ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) ) */
2620:../FreeRTOS/Sources/tasks.c **** /*-----------------------------------------------------------*/
2621:../FreeRTOS/Sources/tasks.c **** 
2622:../FreeRTOS/Sources/tasks.c **** #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
2623:../FreeRTOS/Sources/tasks.c **** 
2624:../FreeRTOS/Sources/tasks.c **** 	portBASE_TYPE xTaskGetSchedulerState( void )
2625:../FreeRTOS/Sources/tasks.c **** 	{
 3309              		.loc 1 2625 0
 3310              		.cfi_startproc
 3311              		@ args = 0, pretend = 0, frame = 8
 3312              		@ frame_needed = 1, uses_anonymous_args = 0
 3313              		@ link register save eliminated.
 3314 0000 80B4     		push	{r7}
 3315              	.LCFI95:
 3316              		.cfi_def_cfa_offset 4
 3317              		.cfi_offset 7, -4
 3318 0002 83B0     		sub	sp, sp, #12
 3319              	.LCFI96:
 3320              		.cfi_def_cfa_offset 16
 3321 0004 00AF     		add	r7, sp, #0
 3322              	.LCFI97:
 3323              		.cfi_def_cfa_register 7
2626:../FreeRTOS/Sources/tasks.c **** 	portBASE_TYPE xReturn;
2627:../FreeRTOS/Sources/tasks.c **** 
2628:../FreeRTOS/Sources/tasks.c **** 		if( xSchedulerRunning == pdFALSE )
 3324              		.loc 1 2628 0
 3325 0006 40F20003 		movw	r3, #:lower16:xSchedulerRunning
 3326 000a C0F20003 		movt	r3, #:upper16:xSchedulerRunning
 3327 000e 1B68     		ldr	r3, [r3, #0]
 3328 0010 002B     		cmp	r3, #0
 3329 0012 03D1     		bne	.L184
2629:../FreeRTOS/Sources/tasks.c **** 		{
2630:../FreeRTOS/Sources/tasks.c **** 			xReturn = taskSCHEDULER_NOT_STARTED;
 3330              		.loc 1 2630 0
 3331 0014 4FF00003 		mov	r3, #0
 3332 0018 7B60     		str	r3, [r7, #4]
 3333 001a 0DE0     		b	.L185
 3334              	.L184:
2631:../FreeRTOS/Sources/tasks.c **** 		}
2632:../FreeRTOS/Sources/tasks.c **** 		else
2633:../FreeRTOS/Sources/tasks.c **** 		{
2634:../FreeRTOS/Sources/tasks.c **** 			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 3335              		.loc 1 2634 0
 3336 001c 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 3337 0020 C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 3338 0024 1B68     		ldr	r3, [r3, #0]
 3339 0026 002B     		cmp	r3, #0
 3340 0028 03D1     		bne	.L186
2635:../FreeRTOS/Sources/tasks.c **** 			{
2636:../FreeRTOS/Sources/tasks.c **** 				xReturn = taskSCHEDULER_RUNNING;
 3341              		.loc 1 2636 0
 3342 002a 4FF00103 		mov	r3, #1
 3343 002e 7B60     		str	r3, [r7, #4]
 3344 0030 02E0     		b	.L185
 3345              	.L186:
2637:../FreeRTOS/Sources/tasks.c **** 			}
2638:../FreeRTOS/Sources/tasks.c **** 			else
2639:../FreeRTOS/Sources/tasks.c **** 			{
2640:../FreeRTOS/Sources/tasks.c **** 				xReturn = taskSCHEDULER_SUSPENDED;
 3346              		.loc 1 2640 0
 3347 0032 4FF00203 		mov	r3, #2
 3348 0036 7B60     		str	r3, [r7, #4]
 3349              	.L185:
2641:../FreeRTOS/Sources/tasks.c **** 			}
2642:../FreeRTOS/Sources/tasks.c **** 		}
2643:../FreeRTOS/Sources/tasks.c **** 
2644:../FreeRTOS/Sources/tasks.c **** 		return xReturn;
 3350              		.loc 1 2644 0
 3351 0038 7B68     		ldr	r3, [r7, #4]
2645:../FreeRTOS/Sources/tasks.c **** 	}
 3352              		.loc 1 2645 0
 3353 003a 1846     		mov	r0, r3
 3354 003c 07F10C07 		add	r7, r7, #12
 3355 0040 BD46     		mov	sp, r7
 3356 0042 80BC     		pop	{r7}
 3357 0044 7047     		bx	lr
 3358              		.cfi_endproc
 3359              	.LFE33:
 3361 0046 00BF     		.section	.text.vTaskPriorityInherit,"ax",%progbits
 3362              		.align	2
 3363              		.global	vTaskPriorityInherit
 3364              		.thumb
 3365              		.thumb_func
 3367              	vTaskPriorityInherit:
 3368              	.LFB34:
2646:../FreeRTOS/Sources/tasks.c **** 
2647:../FreeRTOS/Sources/tasks.c **** #endif /* ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) ) */
2648:../FreeRTOS/Sources/tasks.c **** /*-----------------------------------------------------------*/
2649:../FreeRTOS/Sources/tasks.c **** 
2650:../FreeRTOS/Sources/tasks.c **** #if ( configUSE_MUTEXES == 1 )
2651:../FreeRTOS/Sources/tasks.c **** 
2652:../FreeRTOS/Sources/tasks.c **** 	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
2653:../FreeRTOS/Sources/tasks.c **** 	{
 3369              		.loc 1 2653 0
 3370              		.cfi_startproc
 3371              		@ args = 0, pretend = 0, frame = 16
 3372              		@ frame_needed = 1, uses_anonymous_args = 0
 3373 0000 80B5     		push	{r7, lr}
 3374              	.LCFI98:
 3375              		.cfi_def_cfa_offset 8
 3376              		.cfi_offset 7, -8
 3377              		.cfi_offset 14, -4
 3378 0002 84B0     		sub	sp, sp, #16
 3379              	.LCFI99:
 3380              		.cfi_def_cfa_offset 24
 3381 0004 00AF     		add	r7, sp, #0
 3382              	.LCFI100:
 3383              		.cfi_def_cfa_register 7
 3384 0006 7860     		str	r0, [r7, #4]
2654:../FreeRTOS/Sources/tasks.c **** 	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
 3385              		.loc 1 2654 0
 3386 0008 7B68     		ldr	r3, [r7, #4]
 3387 000a FB60     		str	r3, [r7, #12]
2655:../FreeRTOS/Sources/tasks.c **** 
2656:../FreeRTOS/Sources/tasks.c **** 		/* If the mutex was given back by an interrupt while the queue was
2657:../FreeRTOS/Sources/tasks.c **** 		locked then the mutex holder might now be NULL. */
2658:../FreeRTOS/Sources/tasks.c **** 		if( pxMutexHolder != NULL )
 3388              		.loc 1 2658 0
 3389 000c 7B68     		ldr	r3, [r7, #4]
 3390 000e 002B     		cmp	r3, #0
 3391 0010 5FD0     		beq	.L188
2659:../FreeRTOS/Sources/tasks.c **** 		{
2660:../FreeRTOS/Sources/tasks.c **** 			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
 3392              		.loc 1 2660 0
 3393 0012 FB68     		ldr	r3, [r7, #12]
 3394 0014 DA6A     		ldr	r2, [r3, #44]
 3395 0016 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 3396 001a C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 3397 001e 1B68     		ldr	r3, [r3, #0]
 3398 0020 DB6A     		ldr	r3, [r3, #44]
 3399 0022 9A42     		cmp	r2, r3
 3400 0024 55D2     		bcs	.L188
2661:../FreeRTOS/Sources/tasks.c **** 			{
2662:../FreeRTOS/Sources/tasks.c **** 				/* Adjust the mutex holder state to account for its new priority. */
2663:../FreeRTOS/Sources/tasks.c **** 				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) px
 3401              		.loc 1 2663 0
 3402 0026 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 3403 002a C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 3404 002e 1B68     		ldr	r3, [r3, #0]
 3405 0030 DB6A     		ldr	r3, [r3, #44]
 3406 0032 C3F10502 		rsb	r2, r3, #5
 3407 0036 FB68     		ldr	r3, [r7, #12]
 3408 0038 9A61     		str	r2, [r3, #24]
2664:../FreeRTOS/Sources/tasks.c **** 
2665:../FreeRTOS/Sources/tasks.c **** 				/* If the task being modified is in the ready state it will need to
2666:../FreeRTOS/Sources/tasks.c **** 				be moved into a new list. */
2667:../FreeRTOS/Sources/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericLis
 3409              		.loc 1 2667 0
 3410 003a FB68     		ldr	r3, [r7, #12]
 3411 003c 5969     		ldr	r1, [r3, #20]
 3412 003e FB68     		ldr	r3, [r7, #12]
 3413 0040 DA6A     		ldr	r2, [r3, #44]
 3414 0042 1346     		mov	r3, r2
 3415 0044 4FEA8303 		lsl	r3, r3, #2
 3416 0048 9B18     		adds	r3, r3, r2
 3417 004a 4FEA8303 		lsl	r3, r3, #2
 3418 004e 40F20002 		movw	r2, #:lower16:pxReadyTasksLists
 3419 0052 C0F20002 		movt	r2, #:upper16:pxReadyTasksLists
 3420 0056 9B18     		adds	r3, r3, r2
 3421 0058 9942     		cmp	r1, r3
 3422 005a 32D1     		bne	.L190
2668:../FreeRTOS/Sources/tasks.c **** 				{
2669:../FreeRTOS/Sources/tasks.c **** 					if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
 3423              		.loc 1 2669 0
 3424 005c FB68     		ldr	r3, [r7, #12]
 3425 005e 03F10403 		add	r3, r3, #4
 3426 0062 1846     		mov	r0, r3
 3427 0064 FFF7FEFF 		bl	uxListRemove
2670:../FreeRTOS/Sources/tasks.c **** 					{
2671:../FreeRTOS/Sources/tasks.c **** 						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
2672:../FreeRTOS/Sources/tasks.c **** 					}
2673:../FreeRTOS/Sources/tasks.c **** 
2674:../FreeRTOS/Sources/tasks.c **** 					/* Inherit the priority before being moved into the new list. */
2675:../FreeRTOS/Sources/tasks.c **** 					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 3428              		.loc 1 2675 0
 3429 0068 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 3430 006c C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 3431 0070 1B68     		ldr	r3, [r3, #0]
 3432 0072 DA6A     		ldr	r2, [r3, #44]
 3433 0074 FB68     		ldr	r3, [r7, #12]
 3434 0076 DA62     		str	r2, [r3, #44]
2676:../FreeRTOS/Sources/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 3435              		.loc 1 2676 0
 3436 0078 FB68     		ldr	r3, [r7, #12]
 3437 007a DA6A     		ldr	r2, [r3, #44]
 3438 007c 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 3439 0080 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 3440 0084 1B68     		ldr	r3, [r3, #0]
 3441 0086 9A42     		cmp	r2, r3
 3442 0088 06D9     		bls	.L191
 3443              		.loc 1 2676 0 is_stmt 0 discriminator 1
 3444 008a FB68     		ldr	r3, [r7, #12]
 3445 008c DA6A     		ldr	r2, [r3, #44]
 3446 008e 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 3447 0092 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 3448 0096 1A60     		str	r2, [r3, #0]
 3449              	.L191:
 3450              		.loc 1 2676 0 discriminator 2
 3451 0098 FB68     		ldr	r3, [r7, #12]
 3452 009a DA6A     		ldr	r2, [r3, #44]
 3453 009c 1346     		mov	r3, r2
 3454 009e 4FEA8303 		lsl	r3, r3, #2
 3455 00a2 9B18     		adds	r3, r3, r2
 3456 00a4 4FEA8303 		lsl	r3, r3, #2
 3457 00a8 40F20002 		movw	r2, #:lower16:pxReadyTasksLists
 3458 00ac C0F20002 		movt	r2, #:upper16:pxReadyTasksLists
 3459 00b0 9A18     		adds	r2, r3, r2
 3460 00b2 FB68     		ldr	r3, [r7, #12]
 3461 00b4 03F10403 		add	r3, r3, #4
 3462 00b8 1046     		mov	r0, r2
 3463 00ba 1946     		mov	r1, r3
 3464 00bc FFF7FEFF 		bl	vListInsertEnd
 3465 00c0 07E0     		b	.L188
 3466              	.L190:
2677:../FreeRTOS/Sources/tasks.c **** 				}
2678:../FreeRTOS/Sources/tasks.c **** 				else
2679:../FreeRTOS/Sources/tasks.c **** 				{
2680:../FreeRTOS/Sources/tasks.c **** 					/* Just inherit the priority. */
2681:../FreeRTOS/Sources/tasks.c **** 					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 3467              		.loc 1 2681 0 is_stmt 1
 3468 00c2 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 3469 00c6 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 3470 00ca 1B68     		ldr	r3, [r3, #0]
 3471 00cc DA6A     		ldr	r2, [r3, #44]
 3472 00ce FB68     		ldr	r3, [r7, #12]
 3473 00d0 DA62     		str	r2, [r3, #44]
 3474              	.L188:
2682:../FreeRTOS/Sources/tasks.c **** 				}
2683:../FreeRTOS/Sources/tasks.c **** 
2684:../FreeRTOS/Sources/tasks.c **** 				traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
2685:../FreeRTOS/Sources/tasks.c **** 			}
2686:../FreeRTOS/Sources/tasks.c **** 		}
2687:../FreeRTOS/Sources/tasks.c **** 	}
 3475              		.loc 1 2687 0
 3476 00d2 07F11007 		add	r7, r7, #16
 3477 00d6 BD46     		mov	sp, r7
 3478 00d8 80BD     		pop	{r7, pc}
 3479              		.cfi_endproc
 3480              	.LFE34:
 3482 00da 00BF     		.section	.text.vTaskPriorityDisinherit,"ax",%progbits
 3483              		.align	2
 3484              		.global	vTaskPriorityDisinherit
 3485              		.thumb
 3486              		.thumb_func
 3488              	vTaskPriorityDisinherit:
 3489              	.LFB35:
2688:../FreeRTOS/Sources/tasks.c **** 
2689:../FreeRTOS/Sources/tasks.c **** #endif /* configUSE_MUTEXES */
2690:../FreeRTOS/Sources/tasks.c **** /*-----------------------------------------------------------*/
2691:../FreeRTOS/Sources/tasks.c **** 
2692:../FreeRTOS/Sources/tasks.c **** #if ( configUSE_MUTEXES == 1 )
2693:../FreeRTOS/Sources/tasks.c **** 
2694:../FreeRTOS/Sources/tasks.c **** 	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
2695:../FreeRTOS/Sources/tasks.c **** 	{
 3490              		.loc 1 2695 0
 3491              		.cfi_startproc
 3492              		@ args = 0, pretend = 0, frame = 16
 3493              		@ frame_needed = 1, uses_anonymous_args = 0
 3494 0000 80B5     		push	{r7, lr}
 3495              	.LCFI101:
 3496              		.cfi_def_cfa_offset 8
 3497              		.cfi_offset 7, -8
 3498              		.cfi_offset 14, -4
 3499 0002 84B0     		sub	sp, sp, #16
 3500              	.LCFI102:
 3501              		.cfi_def_cfa_offset 24
 3502 0004 00AF     		add	r7, sp, #0
 3503              	.LCFI103:
 3504              		.cfi_def_cfa_register 7
 3505 0006 7860     		str	r0, [r7, #4]
2696:../FreeRTOS/Sources/tasks.c **** 	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
 3506              		.loc 1 2696 0
 3507 0008 7B68     		ldr	r3, [r7, #4]
 3508 000a FB60     		str	r3, [r7, #12]
2697:../FreeRTOS/Sources/tasks.c **** 
2698:../FreeRTOS/Sources/tasks.c **** 		if( pxMutexHolder != NULL )
 3509              		.loc 1 2698 0
 3510 000c 7B68     		ldr	r3, [r7, #4]
 3511 000e 002B     		cmp	r3, #0
 3512 0010 39D0     		beq	.L192
2699:../FreeRTOS/Sources/tasks.c **** 		{
2700:../FreeRTOS/Sources/tasks.c **** 			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 3513              		.loc 1 2700 0
 3514 0012 FB68     		ldr	r3, [r7, #12]
 3515 0014 DA6A     		ldr	r2, [r3, #44]
 3516 0016 FB68     		ldr	r3, [r7, #12]
 3517 0018 1B6C     		ldr	r3, [r3, #64]
 3518 001a 9A42     		cmp	r2, r3
 3519 001c 33D0     		beq	.L192
2701:../FreeRTOS/Sources/tasks.c **** 			{
2702:../FreeRTOS/Sources/tasks.c **** 				/* We must be the running task to be able to give the mutex back.
2703:../FreeRTOS/Sources/tasks.c **** 				Remove ourselves from the ready list we currently appear in. */
2704:../FreeRTOS/Sources/tasks.c **** 				if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
 3520              		.loc 1 2704 0
 3521 001e FB68     		ldr	r3, [r7, #12]
 3522 0020 03F10403 		add	r3, r3, #4
 3523 0024 1846     		mov	r0, r3
 3524 0026 FFF7FEFF 		bl	uxListRemove
2705:../FreeRTOS/Sources/tasks.c **** 				{
2706:../FreeRTOS/Sources/tasks.c **** 					taskRESET_READY_PRIORITY( pxTCB->uxPriority );
2707:../FreeRTOS/Sources/tasks.c **** 				}
2708:../FreeRTOS/Sources/tasks.c **** 
2709:../FreeRTOS/Sources/tasks.c **** 				/* Disinherit the priority before adding the task into the new
2710:../FreeRTOS/Sources/tasks.c **** 				ready list. */
2711:../FreeRTOS/Sources/tasks.c **** 				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
2712:../FreeRTOS/Sources/tasks.c **** 				pxTCB->uxPriority = pxTCB->uxBasePriority;
 3525              		.loc 1 2712 0
 3526 002a FB68     		ldr	r3, [r7, #12]
 3527 002c 1A6C     		ldr	r2, [r3, #64]
 3528 002e FB68     		ldr	r3, [r7, #12]
 3529 0030 DA62     		str	r2, [r3, #44]
2713:../FreeRTOS/Sources/tasks.c **** 				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) px
 3530              		.loc 1 2713 0
 3531 0032 FB68     		ldr	r3, [r7, #12]
 3532 0034 DB6A     		ldr	r3, [r3, #44]
 3533 0036 C3F10502 		rsb	r2, r3, #5
 3534 003a FB68     		ldr	r3, [r7, #12]
 3535 003c 9A61     		str	r2, [r3, #24]
2714:../FreeRTOS/Sources/tasks.c **** 				prvAddTaskToReadyQueue( pxTCB );
 3536              		.loc 1 2714 0
 3537 003e FB68     		ldr	r3, [r7, #12]
 3538 0040 DA6A     		ldr	r2, [r3, #44]
 3539 0042 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 3540 0046 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 3541 004a 1B68     		ldr	r3, [r3, #0]
 3542 004c 9A42     		cmp	r2, r3
 3543 004e 06D9     		bls	.L194
 3544              		.loc 1 2714 0 is_stmt 0 discriminator 1
 3545 0050 FB68     		ldr	r3, [r7, #12]
 3546 0052 DA6A     		ldr	r2, [r3, #44]
 3547 0054 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 3548 0058 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 3549 005c 1A60     		str	r2, [r3, #0]
 3550              	.L194:
 3551              		.loc 1 2714 0 discriminator 2
 3552 005e FB68     		ldr	r3, [r7, #12]
 3553 0060 DA6A     		ldr	r2, [r3, #44]
 3554 0062 1346     		mov	r3, r2
 3555 0064 4FEA8303 		lsl	r3, r3, #2
 3556 0068 9B18     		adds	r3, r3, r2
 3557 006a 4FEA8303 		lsl	r3, r3, #2
 3558 006e 40F20002 		movw	r2, #:lower16:pxReadyTasksLists
 3559 0072 C0F20002 		movt	r2, #:upper16:pxReadyTasksLists
 3560 0076 9A18     		adds	r2, r3, r2
 3561 0078 FB68     		ldr	r3, [r7, #12]
 3562 007a 03F10403 		add	r3, r3, #4
 3563 007e 1046     		mov	r0, r2
 3564 0080 1946     		mov	r1, r3
 3565 0082 FFF7FEFF 		bl	vListInsertEnd
 3566              	.L192:
2715:../FreeRTOS/Sources/tasks.c **** 			}
2716:../FreeRTOS/Sources/tasks.c **** 		}
2717:../FreeRTOS/Sources/tasks.c **** 	}
 3567              		.loc 1 2717 0 is_stmt 1
 3568 0086 07F11007 		add	r7, r7, #16
 3569 008a BD46     		mov	sp, r7
 3570 008c 80BD     		pop	{r7, pc}
 3571              		.cfi_endproc
 3572              	.LFE35:
 3574 008e 00BF     		.section	.rodata.ucExpectedStackBytes.5898,"a",%progbits
 3575              		.align	2
 3578              	ucExpectedStackBytes.5898:
 3579 0000 A5       		.byte	-91
 3580 0001 A5       		.byte	-91
 3581 0002 A5       		.byte	-91
 3582 0003 A5       		.byte	-91
 3583 0004 A5       		.byte	-91
 3584 0005 A5       		.byte	-91
 3585 0006 A5       		.byte	-91
 3586 0007 A5       		.byte	-91
 3587 0008 A5       		.byte	-91
 3588 0009 A5       		.byte	-91
 3589 000a A5       		.byte	-91
 3590 000b A5       		.byte	-91
 3591 000c A5       		.byte	-91
 3592 000d A5       		.byte	-91
 3593 000e A5       		.byte	-91
 3594 000f A5       		.byte	-91
 3595 0010 A5       		.byte	-91
 3596 0011 A5       		.byte	-91
 3597 0012 A5       		.byte	-91
 3598 0013 A5       		.byte	-91
 3599              		.text
 3600              	.Letext0:
 3601              		.file 2 "/home/frolls/ARM/gcc-arm-none-eabi-4_7-2012q4/bin/../lib/gcc/arm-none-eabi/4.7.3/include/
 3602              		.file 3 "/home/frolls/git/STM32_FreeRTOS_freeModBus/stm32vld_template/FreeRTOS/Headers/projdefs.h"
 3603              		.file 4 "/home/frolls/git/STM32_FreeRTOS_freeModBus/stm32vld_template/FreeRTOS/Headers/portmacro.h
 3604              		.file 5 "/home/frolls/git/STM32_FreeRTOS_freeModBus/stm32vld_template/FreeRTOS/Headers/list.h"
 3605              		.file 6 "/home/frolls/git/STM32_FreeRTOS_freeModBus/stm32vld_template/FreeRTOS/Headers/task.h"
DEFINED SYMBOLS
                            *ABS*:00000000 tasks.c
     /tmp/ccAwnema.s:23     .bss.pxCurrentTCB:00000000 pxCurrentTCB
     /tmp/ccAwnema.s:20     .bss.pxCurrentTCB:00000000 $d
     /tmp/ccAwnema.s:26     .bss.pxReadyTasksLists:00000000 $d
     /tmp/ccAwnema.s:29     .bss.pxReadyTasksLists:00000000 pxReadyTasksLists
     /tmp/ccAwnema.s:32     .bss.xDelayedTaskList1:00000000 $d
     /tmp/ccAwnema.s:35     .bss.xDelayedTaskList1:00000000 xDelayedTaskList1
     /tmp/ccAwnema.s:38     .bss.xDelayedTaskList2:00000000 $d
     /tmp/ccAwnema.s:41     .bss.xDelayedTaskList2:00000000 xDelayedTaskList2
     /tmp/ccAwnema.s:44     .bss.pxDelayedTaskList:00000000 $d
     /tmp/ccAwnema.s:47     .bss.pxDelayedTaskList:00000000 pxDelayedTaskList
     /tmp/ccAwnema.s:50     .bss.pxOverflowDelayedTaskList:00000000 $d
     /tmp/ccAwnema.s:53     .bss.pxOverflowDelayedTaskList:00000000 pxOverflowDelayedTaskList
     /tmp/ccAwnema.s:56     .bss.xPendingReadyList:00000000 $d
     /tmp/ccAwnema.s:59     .bss.xPendingReadyList:00000000 xPendingReadyList
     /tmp/ccAwnema.s:62     .bss.xTasksWaitingTermination:00000000 $d
     /tmp/ccAwnema.s:65     .bss.xTasksWaitingTermination:00000000 xTasksWaitingTermination
     /tmp/ccAwnema.s:68     .bss.uxTasksDeleted:00000000 $d
     /tmp/ccAwnema.s:71     .bss.uxTasksDeleted:00000000 uxTasksDeleted
     /tmp/ccAwnema.s:74     .bss.xSuspendedTaskList:00000000 $d
     /tmp/ccAwnema.s:77     .bss.xSuspendedTaskList:00000000 xSuspendedTaskList
     /tmp/ccAwnema.s:80     .bss.uxCurrentNumberOfTasks:00000000 $d
     /tmp/ccAwnema.s:83     .bss.uxCurrentNumberOfTasks:00000000 uxCurrentNumberOfTasks
     /tmp/ccAwnema.s:86     .bss.xTickCount:00000000 $d
     /tmp/ccAwnema.s:89     .bss.xTickCount:00000000 xTickCount
     /tmp/ccAwnema.s:92     .bss.uxTopUsedPriority:00000000 $d
     /tmp/ccAwnema.s:95     .bss.uxTopUsedPriority:00000000 uxTopUsedPriority
     /tmp/ccAwnema.s:98     .bss.uxTopReadyPriority:00000000 $d
     /tmp/ccAwnema.s:101    .bss.uxTopReadyPriority:00000000 uxTopReadyPriority
     /tmp/ccAwnema.s:104    .bss.xSchedulerRunning:00000000 $d
     /tmp/ccAwnema.s:107    .bss.xSchedulerRunning:00000000 xSchedulerRunning
     /tmp/ccAwnema.s:110    .bss.uxSchedulerSuspended:00000000 $d
     /tmp/ccAwnema.s:113    .bss.uxSchedulerSuspended:00000000 uxSchedulerSuspended
     /tmp/ccAwnema.s:116    .bss.uxMissedTicks:00000000 $d
     /tmp/ccAwnema.s:119    .bss.uxMissedTicks:00000000 uxMissedTicks
     /tmp/ccAwnema.s:122    .bss.xMissedYield:00000000 $d
     /tmp/ccAwnema.s:125    .bss.xMissedYield:00000000 xMissedYield
     /tmp/ccAwnema.s:128    .bss.xNumOfOverflows:00000000 $d
     /tmp/ccAwnema.s:131    .bss.xNumOfOverflows:00000000 xNumOfOverflows
     /tmp/ccAwnema.s:134    .bss.uxTaskNumber:00000000 $d
     /tmp/ccAwnema.s:137    .bss.uxTaskNumber:00000000 uxTaskNumber
     /tmp/ccAwnema.s:140    .data.xNextTaskUnblockTime:00000000 $d
     /tmp/ccAwnema.s:143    .data.xNextTaskUnblockTime:00000000 xNextTaskUnblockTime
     /tmp/ccAwnema.s:146    .text.xTaskGenericCreate:00000000 $t
     /tmp/ccAwnema.s:151    .text.xTaskGenericCreate:00000000 xTaskGenericCreate
     /tmp/ccAwnema.s:3145   .text.prvAllocateTCBAndStack:00000000 prvAllocateTCBAndStack
     /tmp/ccAwnema.s:2801   .text.prvInitialiseTCBVariables:00000000 prvInitialiseTCBVariables
     /tmp/ccAwnema.s:2884   .text.prvInitialiseTaskLists:00000000 prvInitialiseTaskLists
     /tmp/ccAwnema.s:413    .text.vTaskDelete:00000000 $t
     /tmp/ccAwnema.s:418    .text.vTaskDelete:00000000 vTaskDelete
     /tmp/ccAwnema.s:526    .text.vTaskDelayUntil:00000000 $t
     /tmp/ccAwnema.s:531    .text.vTaskDelayUntil:00000000 vTaskDelayUntil
     /tmp/ccAwnema.s:1539   .text.vTaskSuspendAll:00000000 vTaskSuspendAll
     /tmp/ccAwnema.s:3065   .text.prvAddCurrentTaskToDelayedList:00000000 prvAddCurrentTaskToDelayedList
     /tmp/ccAwnema.s:1574   .text.xTaskResumeAll:00000000 xTaskResumeAll
     /tmp/ccAwnema.s:662    .text.vTaskDelay:00000000 $t
     /tmp/ccAwnema.s:667    .text.vTaskDelay:00000000 vTaskDelay
     /tmp/ccAwnema.s:730    .text.uxTaskPriorityGet:00000000 $t
     /tmp/ccAwnema.s:735    .text.uxTaskPriorityGet:00000000 uxTaskPriorityGet
     /tmp/ccAwnema.s:787    .text.vTaskPrioritySet:00000000 $t
     /tmp/ccAwnema.s:792    .text.vTaskPrioritySet:00000000 vTaskPrioritySet
     /tmp/ccAwnema.s:982    .text.vTaskSuspend:00000000 $t
     /tmp/ccAwnema.s:987    .text.vTaskSuspend:00000000 vTaskSuspend
     /tmp/ccAwnema.s:2105   .text.vTaskSwitchContext:00000000 vTaskSwitchContext
     /tmp/ccAwnema.s:1099   .text.xTaskIsTaskSuspended:00000000 $t
     /tmp/ccAwnema.s:1104   .text.xTaskIsTaskSuspended:00000000 xTaskIsTaskSuspended
     /tmp/ccAwnema.s:1172   .text.vTaskResume:00000000 $t
     /tmp/ccAwnema.s:1177   .text.vTaskResume:00000000 vTaskResume
     /tmp/ccAwnema.s:1285   .text.xTaskResumeFromISR:00000000 $t
     /tmp/ccAwnema.s:1290   .text.xTaskResumeFromISR:00000000 xTaskResumeFromISR
     /tmp/ccAwnema.s:1411   .rodata:00000000 $d
     /tmp/ccAwnema.s:1412   .rodata:00000000 .LC0
     /tmp/ccAwnema.s:1415   .text.vTaskStartScheduler:00000000 $t
     /tmp/ccAwnema.s:1420   .text.vTaskStartScheduler:00000000 vTaskStartScheduler
     /tmp/ccAwnema.s:2757   .text.prvIdleTask:00000000 prvIdleTask
     /tmp/ccAwnema.s:1500   .text.vTaskEndScheduler:00000000 $t
     /tmp/ccAwnema.s:1505   .text.vTaskEndScheduler:00000000 vTaskEndScheduler
     /tmp/ccAwnema.s:1534   .text.vTaskSuspendAll:00000000 $t
     /tmp/ccAwnema.s:1569   .text.xTaskResumeAll:00000000 $t
     /tmp/ccAwnema.s:1882   .text.vTaskIncrementTick:00000000 vTaskIncrementTick
     /tmp/ccAwnema.s:1759   .text.xTaskGetTickCount:00000000 $t
     /tmp/ccAwnema.s:1764   .text.xTaskGetTickCount:00000000 xTaskGetTickCount
     /tmp/ccAwnema.s:1801   .text.xTaskGetTickCountFromISR:00000000 $t
     /tmp/ccAwnema.s:1806   .text.xTaskGetTickCountFromISR:00000000 xTaskGetTickCountFromISR
     /tmp/ccAwnema.s:1845   .text.uxTaskGetNumberOfTasks:00000000 $t
     /tmp/ccAwnema.s:1850   .text.uxTaskGetNumberOfTasks:00000000 uxTaskGetNumberOfTasks
     /tmp/ccAwnema.s:1877   .text.vTaskIncrementTick:00000000 $t
     /tmp/ccAwnema.s:2100   .text.vTaskSwitchContext:00000000 $t
     /tmp/ccAwnema.s:3578   .rodata.ucExpectedStackBytes.5898:00000000 ucExpectedStackBytes.5898
     /tmp/ccAwnema.s:2270   .text.vTaskPlaceOnEventList:00000000 $t
     /tmp/ccAwnema.s:2275   .text.vTaskPlaceOnEventList:00000000 vTaskPlaceOnEventList
     /tmp/ccAwnema.s:2353   .text.vTaskPlaceOnEventListRestricted:00000000 $t
     /tmp/ccAwnema.s:2358   .text.vTaskPlaceOnEventListRestricted:00000000 vTaskPlaceOnEventListRestricted
     /tmp/ccAwnema.s:2420   .text.xTaskRemoveFromEventList:00000000 $t
     /tmp/ccAwnema.s:2425   .text.xTaskRemoveFromEventList:00000000 xTaskRemoveFromEventList
     /tmp/ccAwnema.s:2543   .text.vTaskSetTimeOutState:00000000 $t
     /tmp/ccAwnema.s:2548   .text.vTaskSetTimeOutState:00000000 vTaskSetTimeOutState
     /tmp/ccAwnema.s:2596   .text.xTaskCheckForTimeOut:00000000 $t
     /tmp/ccAwnema.s:2601   .text.xTaskCheckForTimeOut:00000000 xTaskCheckForTimeOut
     /tmp/ccAwnema.s:2721   .text.vTaskMissedYield:00000000 $t
     /tmp/ccAwnema.s:2726   .text.vTaskMissedYield:00000000 vTaskMissedYield
     /tmp/ccAwnema.s:2753   .text.prvIdleTask:00000000 $t
     /tmp/ccAwnema.s:2970   .text.prvCheckTasksWaitingTermination:00000000 prvCheckTasksWaitingTermination
     /tmp/ccAwnema.s:2797   .text.prvInitialiseTCBVariables:00000000 $t
     /tmp/ccAwnema.s:2880   .text.prvInitialiseTaskLists:00000000 $t
     /tmp/ccAwnema.s:2966   .text.prvCheckTasksWaitingTermination:00000000 $t
     /tmp/ccAwnema.s:3229   .text.prvDeleteTCB:00000000 prvDeleteTCB
     /tmp/ccAwnema.s:3061   .text.prvAddCurrentTaskToDelayedList:00000000 $t
     /tmp/ccAwnema.s:3141   .text.prvAllocateTCBAndStack:00000000 $t
     /tmp/ccAwnema.s:3225   .text.prvDeleteTCB:00000000 $t
     /tmp/ccAwnema.s:3263   .text.xTaskGetCurrentTaskHandle:00000000 $t
     /tmp/ccAwnema.s:3268   .text.xTaskGetCurrentTaskHandle:00000000 xTaskGetCurrentTaskHandle
     /tmp/ccAwnema.s:3302   .text.xTaskGetSchedulerState:00000000 $t
     /tmp/ccAwnema.s:3307   .text.xTaskGetSchedulerState:00000000 xTaskGetSchedulerState
     /tmp/ccAwnema.s:3362   .text.vTaskPriorityInherit:00000000 $t
     /tmp/ccAwnema.s:3367   .text.vTaskPriorityInherit:00000000 vTaskPriorityInherit
     /tmp/ccAwnema.s:3483   .text.vTaskPriorityDisinherit:00000000 $t
     /tmp/ccAwnema.s:3488   .text.vTaskPriorityDisinherit:00000000 vTaskPriorityDisinherit
     /tmp/ccAwnema.s:3575   .rodata.ucExpectedStackBytes.5898:00000000 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
ulPortSetInterruptMask
pxPortInitialiseStack
vPortEnterCritical
vListInsertEnd
vPortExitCritical
vPortYieldFromISR
uxListRemove
vPortClearInterruptMask
xTimerCreateTimerTask
xPortStartScheduler
vPortEndScheduler
vApplicationStackOverflowHook
memcmp
vListInsert
vApplicationIdleHook
strncpy
vListInitialiseItem
vListInitialise
pvPortMalloc
vPortFree
memset
