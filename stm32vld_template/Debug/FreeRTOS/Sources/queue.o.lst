   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"queue.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.section	.text.xQueueGenericReset,"ax",%progbits
  19              		.align	2
  20              		.global	xQueueGenericReset
  21              		.thumb
  22              		.thumb_func
  24              	xQueueGenericReset:
  25              	.LFB0:
  26              		.file 1 "../FreeRTOS/Sources/queue.c"
   1:../FreeRTOS/Sources/queue.c **** /*
   2:../FreeRTOS/Sources/queue.c ****     FreeRTOS V7.4.0 - Copyright (C) 2013 Real Time Engineers Ltd.
   3:../FreeRTOS/Sources/queue.c **** 
   4:../FreeRTOS/Sources/queue.c ****     FEATURES AND PORTS ARE ADDED TO FREERTOS ALL THE TIME.  PLEASE VISIT
   5:../FreeRTOS/Sources/queue.c ****     http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
   6:../FreeRTOS/Sources/queue.c **** 
   7:../FreeRTOS/Sources/queue.c ****     ***************************************************************************
   8:../FreeRTOS/Sources/queue.c ****      *                                                                       *
   9:../FreeRTOS/Sources/queue.c ****      *    FreeRTOS tutorial books are available in pdf and paperback.        *
  10:../FreeRTOS/Sources/queue.c ****      *    Complete, revised, and edited pdf reference manuals are also       *
  11:../FreeRTOS/Sources/queue.c ****      *    available.                                                         *
  12:../FreeRTOS/Sources/queue.c ****      *                                                                       *
  13:../FreeRTOS/Sources/queue.c ****      *    Purchasing FreeRTOS documentation will not only help you, by       *
  14:../FreeRTOS/Sources/queue.c ****      *    ensuring you get running as quickly as possible and with an        *
  15:../FreeRTOS/Sources/queue.c ****      *    in-depth knowledge of how to use FreeRTOS, it will also help       *
  16:../FreeRTOS/Sources/queue.c ****      *    the FreeRTOS project to continue with its mission of providing     *
  17:../FreeRTOS/Sources/queue.c ****      *    professional grade, cross platform, de facto standard solutions    *
  18:../FreeRTOS/Sources/queue.c ****      *    for microcontrollers - completely free of charge!                  *
  19:../FreeRTOS/Sources/queue.c ****      *                                                                       *
  20:../FreeRTOS/Sources/queue.c ****      *    >>> See http://www.FreeRTOS.org/Documentation for details. <<<     *
  21:../FreeRTOS/Sources/queue.c ****      *                                                                       *
  22:../FreeRTOS/Sources/queue.c ****      *    Thank you for using FreeRTOS, and thank you for your support!      *
  23:../FreeRTOS/Sources/queue.c ****      *                                                                       *
  24:../FreeRTOS/Sources/queue.c ****     ***************************************************************************
  25:../FreeRTOS/Sources/queue.c **** 
  26:../FreeRTOS/Sources/queue.c **** 
  27:../FreeRTOS/Sources/queue.c ****     This file is part of the FreeRTOS distribution.
  28:../FreeRTOS/Sources/queue.c **** 
  29:../FreeRTOS/Sources/queue.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  30:../FreeRTOS/Sources/queue.c ****     the terms of the GNU General Public License (version 2) as published by the
  31:../FreeRTOS/Sources/queue.c ****     Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
  32:../FreeRTOS/Sources/queue.c **** 
  33:../FreeRTOS/Sources/queue.c ****     >>>>>>NOTE<<<<<< The modification to the GPL is included to allow you to
  34:../FreeRTOS/Sources/queue.c ****     distribute a combined work that includes FreeRTOS without being obliged to
  35:../FreeRTOS/Sources/queue.c ****     provide the source code for proprietary components outside of the FreeRTOS
  36:../FreeRTOS/Sources/queue.c ****     kernel.
  37:../FreeRTOS/Sources/queue.c **** 
  38:../FreeRTOS/Sources/queue.c ****     FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
  39:../FreeRTOS/Sources/queue.c ****     WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
  40:../FreeRTOS/Sources/queue.c ****     FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
  41:../FreeRTOS/Sources/queue.c ****     details. You should have received a copy of the GNU General Public License
  42:../FreeRTOS/Sources/queue.c ****     and the FreeRTOS license exception along with FreeRTOS; if not itcan be
  43:../FreeRTOS/Sources/queue.c ****     viewed here: http://www.freertos.org/a00114.html and also obtained by
  44:../FreeRTOS/Sources/queue.c ****     writing to Real Time Engineers Ltd., contact details for whom are available
  45:../FreeRTOS/Sources/queue.c ****     on the FreeRTOS WEB site.
  46:../FreeRTOS/Sources/queue.c **** 
  47:../FreeRTOS/Sources/queue.c ****     1 tab == 4 spaces!
  48:../FreeRTOS/Sources/queue.c **** 
  49:../FreeRTOS/Sources/queue.c ****     ***************************************************************************
  50:../FreeRTOS/Sources/queue.c ****      *                                                                       *
  51:../FreeRTOS/Sources/queue.c ****      *    Having a problem?  Start by reading the FAQ "My application does   *
  52:../FreeRTOS/Sources/queue.c ****      *    not run, what could be wrong?"                                     *
  53:../FreeRTOS/Sources/queue.c ****      *                                                                       *
  54:../FreeRTOS/Sources/queue.c ****      *    http://www.FreeRTOS.org/FAQHelp.html                               *
  55:../FreeRTOS/Sources/queue.c ****      *                                                                       *
  56:../FreeRTOS/Sources/queue.c ****     ***************************************************************************
  57:../FreeRTOS/Sources/queue.c **** 
  58:../FreeRTOS/Sources/queue.c **** 
  59:../FreeRTOS/Sources/queue.c ****     http://www.FreeRTOS.org - Documentation, books, training, latest versions, 
  60:../FreeRTOS/Sources/queue.c ****     license and Real Time Engineers Ltd. contact details.
  61:../FreeRTOS/Sources/queue.c **** 
  62:../FreeRTOS/Sources/queue.c ****     http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
  63:../FreeRTOS/Sources/queue.c ****     including FreeRTOS+Trace - an indispensable productivity tool, and our new
  64:../FreeRTOS/Sources/queue.c ****     fully thread aware and reentrant UDP/IP stack.
  65:../FreeRTOS/Sources/queue.c **** 
  66:../FreeRTOS/Sources/queue.c ****     http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High 
  67:../FreeRTOS/Sources/queue.c ****     Integrity Systems, who sell the code with commercial support, 
  68:../FreeRTOS/Sources/queue.c ****     indemnification and middleware, under the OpenRTOS brand.
  69:../FreeRTOS/Sources/queue.c ****     
  70:../FreeRTOS/Sources/queue.c ****     http://www.SafeRTOS.com - High Integrity Systems also provide a safety 
  71:../FreeRTOS/Sources/queue.c ****     engineered and independently SIL3 certified version for use in safety and 
  72:../FreeRTOS/Sources/queue.c ****     mission critical applications that require provable dependability.
  73:../FreeRTOS/Sources/queue.c **** */
  74:../FreeRTOS/Sources/queue.c **** 
  75:../FreeRTOS/Sources/queue.c **** #include <stdlib.h>
  76:../FreeRTOS/Sources/queue.c **** #include <string.h>
  77:../FreeRTOS/Sources/queue.c **** 
  78:../FreeRTOS/Sources/queue.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  79:../FreeRTOS/Sources/queue.c **** all the API functions to use the MPU wrappers.  That should only be done when
  80:../FreeRTOS/Sources/queue.c **** task.h is included from an application file. */
  81:../FreeRTOS/Sources/queue.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  82:../FreeRTOS/Sources/queue.c **** 
  83:../FreeRTOS/Sources/queue.c **** #include "FreeRTOS.h"
  84:../FreeRTOS/Sources/queue.c **** #include "task.h"
  85:../FreeRTOS/Sources/queue.c **** #include "queue.h"
  86:../FreeRTOS/Sources/queue.c **** 
  87:../FreeRTOS/Sources/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
  88:../FreeRTOS/Sources/queue.c **** 	#include "croutine.h"
  89:../FreeRTOS/Sources/queue.c **** #endif
  90:../FreeRTOS/Sources/queue.c **** 
  91:../FreeRTOS/Sources/queue.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  92:../FreeRTOS/Sources/queue.c **** 
  93:../FreeRTOS/Sources/queue.c **** /* Constants used with the cRxLock and xTxLock structure members. */
  94:../FreeRTOS/Sources/queue.c **** #define queueUNLOCKED					( ( signed portBASE_TYPE ) -1 )
  95:../FreeRTOS/Sources/queue.c **** #define queueLOCKED_UNMODIFIED			( ( signed portBASE_TYPE ) 0 )
  96:../FreeRTOS/Sources/queue.c **** 
  97:../FreeRTOS/Sources/queue.c **** #define queueERRONEOUS_UNBLOCK			( -1 )
  98:../FreeRTOS/Sources/queue.c **** 
  99:../FreeRTOS/Sources/queue.c **** /* Effectively make a union out of the xQUEUE structure. */
 100:../FreeRTOS/Sources/queue.c **** #define pxMutexHolder					pcTail
 101:../FreeRTOS/Sources/queue.c **** #define uxQueueType						pcHead
 102:../FreeRTOS/Sources/queue.c **** #define uxRecursiveCallCount			pcReadFrom
 103:../FreeRTOS/Sources/queue.c **** #define queueQUEUE_IS_MUTEX				NULL
 104:../FreeRTOS/Sources/queue.c **** 
 105:../FreeRTOS/Sources/queue.c **** /* Semaphores do not actually store or copy data, so have an items size of
 106:../FreeRTOS/Sources/queue.c **** zero. */
 107:../FreeRTOS/Sources/queue.c **** #define queueSEMAPHORE_QUEUE_ITEM_LENGTH ( ( unsigned portBASE_TYPE ) 0 )
 108:../FreeRTOS/Sources/queue.c **** #define queueDONT_BLOCK					 ( ( portTickType ) 0U )
 109:../FreeRTOS/Sources/queue.c **** #define queueMUTEX_GIVE_BLOCK_TIME		 ( ( portTickType ) 0U )
 110:../FreeRTOS/Sources/queue.c **** 
 111:../FreeRTOS/Sources/queue.c **** 
 112:../FreeRTOS/Sources/queue.c **** /*
 113:../FreeRTOS/Sources/queue.c ****  * Definition of the queue used by the scheduler.
 114:../FreeRTOS/Sources/queue.c ****  * Items are queued by copy, not reference.
 115:../FreeRTOS/Sources/queue.c ****  */
 116:../FreeRTOS/Sources/queue.c **** typedef struct QueueDefinition
 117:../FreeRTOS/Sources/queue.c **** {
 118:../FreeRTOS/Sources/queue.c **** 	signed char *pcHead;					/*< Points to the beginning of the queue storage area. */
 119:../FreeRTOS/Sources/queue.c **** 	signed char *pcTail;					/*< Points to the byte at the end of the queue storage area.  Once more b
 120:../FreeRTOS/Sources/queue.c **** 
 121:../FreeRTOS/Sources/queue.c **** 	signed char *pcWriteTo;					/*< Points to the free next place in the storage area. */
 122:../FreeRTOS/Sources/queue.c **** 	signed char *pcReadFrom;				/*< Points to the last place that a queued item was read from. */
 123:../FreeRTOS/Sources/queue.c **** 
 124:../FreeRTOS/Sources/queue.c **** 	xList xTasksWaitingToSend;				/*< List of tasks that are blocked waiting to post onto this queue. 
 125:../FreeRTOS/Sources/queue.c **** 	xList xTasksWaitingToReceive;			/*< List of tasks that are blocked waiting to read from this queue
 126:../FreeRTOS/Sources/queue.c **** 
 127:../FreeRTOS/Sources/queue.c **** 	volatile unsigned portBASE_TYPE uxMessagesWaiting;/*< The number of items currently in the queue. 
 128:../FreeRTOS/Sources/queue.c **** 	unsigned portBASE_TYPE uxLength;		/*< The length of the queue defined as the number of items it wi
 129:../FreeRTOS/Sources/queue.c **** 	unsigned portBASE_TYPE uxItemSize;		/*< The size of each items that the queue will hold. */
 130:../FreeRTOS/Sources/queue.c **** 
 131:../FreeRTOS/Sources/queue.c **** 	volatile signed portBASE_TYPE xRxLock;	/*< Stores the number of items received from the queue (rem
 132:../FreeRTOS/Sources/queue.c **** 	volatile signed portBASE_TYPE xTxLock;	/*< Stores the number of items transmitted to the queue (ad
 133:../FreeRTOS/Sources/queue.c **** 
 134:../FreeRTOS/Sources/queue.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 135:../FreeRTOS/Sources/queue.c **** 		unsigned char ucQueueNumber;
 136:../FreeRTOS/Sources/queue.c **** 		unsigned char ucQueueType;
 137:../FreeRTOS/Sources/queue.c **** 	#endif
 138:../FreeRTOS/Sources/queue.c **** 
 139:../FreeRTOS/Sources/queue.c **** 	#if ( configUSE_QUEUE_SETS == 1 )
 140:../FreeRTOS/Sources/queue.c **** 		struct QueueDefinition *pxQueueSetContainer;
 141:../FreeRTOS/Sources/queue.c **** 	#endif
 142:../FreeRTOS/Sources/queue.c **** 
 143:../FreeRTOS/Sources/queue.c **** } xQUEUE;
 144:../FreeRTOS/Sources/queue.c **** /*-----------------------------------------------------------*/
 145:../FreeRTOS/Sources/queue.c **** 
 146:../FreeRTOS/Sources/queue.c **** /*
 147:../FreeRTOS/Sources/queue.c ****  * The queue registry is just a means for kernel aware debuggers to locate
 148:../FreeRTOS/Sources/queue.c ****  * queue structures.  It has no other purpose so is an optional component.
 149:../FreeRTOS/Sources/queue.c ****  */
 150:../FreeRTOS/Sources/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
 151:../FreeRTOS/Sources/queue.c **** 
 152:../FreeRTOS/Sources/queue.c **** 	/* The type stored within the queue registry array.  This allows a name
 153:../FreeRTOS/Sources/queue.c **** 	to be assigned to each queue making kernel aware debugging a little
 154:../FreeRTOS/Sources/queue.c **** 	more user friendly. */
 155:../FreeRTOS/Sources/queue.c **** 	typedef struct QUEUE_REGISTRY_ITEM
 156:../FreeRTOS/Sources/queue.c **** 	{
 157:../FreeRTOS/Sources/queue.c **** 		signed char *pcQueueName;
 158:../FreeRTOS/Sources/queue.c **** 		xQueueHandle xHandle;
 159:../FreeRTOS/Sources/queue.c **** 	} xQueueRegistryItem;
 160:../FreeRTOS/Sources/queue.c **** 
 161:../FreeRTOS/Sources/queue.c **** 	/* The queue registry is simply an array of xQueueRegistryItem structures.
 162:../FreeRTOS/Sources/queue.c **** 	The pcQueueName member of a structure being NULL is indicative of the
 163:../FreeRTOS/Sources/queue.c **** 	array position being vacant. */
 164:../FreeRTOS/Sources/queue.c **** 	xQueueRegistryItem xQueueRegistry[ configQUEUE_REGISTRY_SIZE ];
 165:../FreeRTOS/Sources/queue.c **** 
 166:../FreeRTOS/Sources/queue.c **** 	/* Removes a queue from the registry by simply setting the pcQueueName
 167:../FreeRTOS/Sources/queue.c **** 	member to NULL. */
 168:../FreeRTOS/Sources/queue.c **** 	static void prvQueueUnregisterQueue( xQueueHandle xQueue ) PRIVILEGED_FUNCTION;
 169:../FreeRTOS/Sources/queue.c **** 
 170:../FreeRTOS/Sources/queue.c **** #endif /* configQUEUE_REGISTRY_SIZE */
 171:../FreeRTOS/Sources/queue.c **** 
 172:../FreeRTOS/Sources/queue.c **** /*
 173:../FreeRTOS/Sources/queue.c ****  * Unlocks a queue locked by a call to prvLockQueue.  Locking a queue does not
 174:../FreeRTOS/Sources/queue.c ****  * prevent an ISR from adding or removing items to the queue, but does prevent
 175:../FreeRTOS/Sources/queue.c ****  * an ISR from removing tasks from the queue event lists.  If an ISR finds a
 176:../FreeRTOS/Sources/queue.c ****  * queue is locked it will instead increment the appropriate queue lock count
 177:../FreeRTOS/Sources/queue.c ****  * to indicate that a task may require unblocking.  When the queue in unlocked
 178:../FreeRTOS/Sources/queue.c ****  * these lock counts are inspected, and the appropriate action taken.
 179:../FreeRTOS/Sources/queue.c ****  */
 180:../FreeRTOS/Sources/queue.c **** static void prvUnlockQueue( xQUEUE *pxQueue ) PRIVILEGED_FUNCTION;
 181:../FreeRTOS/Sources/queue.c **** 
 182:../FreeRTOS/Sources/queue.c **** /*
 183:../FreeRTOS/Sources/queue.c ****  * Uses a critical section to determine if there is any data in a queue.
 184:../FreeRTOS/Sources/queue.c ****  *
 185:../FreeRTOS/Sources/queue.c ****  * @return pdTRUE if the queue contains no items, otherwise pdFALSE.
 186:../FreeRTOS/Sources/queue.c ****  */
 187:../FreeRTOS/Sources/queue.c **** static signed portBASE_TYPE prvIsQueueEmpty( const xQUEUE *pxQueue ) PRIVILEGED_FUNCTION;
 188:../FreeRTOS/Sources/queue.c **** 
 189:../FreeRTOS/Sources/queue.c **** /*
 190:../FreeRTOS/Sources/queue.c ****  * Uses a critical section to determine if there is any space in a queue.
 191:../FreeRTOS/Sources/queue.c ****  *
 192:../FreeRTOS/Sources/queue.c ****  * @return pdTRUE if there is no space, otherwise pdFALSE;
 193:../FreeRTOS/Sources/queue.c ****  */
 194:../FreeRTOS/Sources/queue.c **** static signed portBASE_TYPE prvIsQueueFull( const xQUEUE *pxQueue ) PRIVILEGED_FUNCTION;
 195:../FreeRTOS/Sources/queue.c **** 
 196:../FreeRTOS/Sources/queue.c **** /*
 197:../FreeRTOS/Sources/queue.c ****  * Copies an item into the queue, either at the front of the queue or the
 198:../FreeRTOS/Sources/queue.c ****  * back of the queue.
 199:../FreeRTOS/Sources/queue.c ****  */
 200:../FreeRTOS/Sources/queue.c **** static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition
 201:../FreeRTOS/Sources/queue.c **** 
 202:../FreeRTOS/Sources/queue.c **** /*
 203:../FreeRTOS/Sources/queue.c ****  * Copies an item out of a queue.
 204:../FreeRTOS/Sources/queue.c ****  */
 205:../FreeRTOS/Sources/queue.c **** static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer ) PRIVILEGED_FUNCTIO
 206:../FreeRTOS/Sources/queue.c **** 
 207:../FreeRTOS/Sources/queue.c **** #if ( configUSE_QUEUE_SETS == 1 )
 208:../FreeRTOS/Sources/queue.c **** 	/*
 209:../FreeRTOS/Sources/queue.c **** 	 * Checks to see if a queue is a member of a queue set, and if so, notifies
 210:../FreeRTOS/Sources/queue.c **** 	 * the queue set that the queue contains data.
 211:../FreeRTOS/Sources/queue.c **** 	 */
 212:../FreeRTOS/Sources/queue.c **** 	static portBASE_TYPE prvNotifyQueueSetContainer( xQUEUE *pxQueue, portBASE_TYPE xCopyPosition );
 213:../FreeRTOS/Sources/queue.c **** #endif
 214:../FreeRTOS/Sources/queue.c **** 
 215:../FreeRTOS/Sources/queue.c **** /*-----------------------------------------------------------*/
 216:../FreeRTOS/Sources/queue.c **** 
 217:../FreeRTOS/Sources/queue.c **** /*
 218:../FreeRTOS/Sources/queue.c ****  * Macro to mark a queue as locked.  Locking a queue prevents an ISR from
 219:../FreeRTOS/Sources/queue.c ****  * accessing the queue event lists.
 220:../FreeRTOS/Sources/queue.c ****  */
 221:../FreeRTOS/Sources/queue.c **** #define prvLockQueue( pxQueue )								\
 222:../FreeRTOS/Sources/queue.c **** 	taskENTER_CRITICAL();									\
 223:../FreeRTOS/Sources/queue.c **** 	{														\
 224:../FreeRTOS/Sources/queue.c **** 		if( ( pxQueue )->xRxLock == queueUNLOCKED )			\
 225:../FreeRTOS/Sources/queue.c **** 		{													\
 226:../FreeRTOS/Sources/queue.c **** 			( pxQueue )->xRxLock = queueLOCKED_UNMODIFIED;	\
 227:../FreeRTOS/Sources/queue.c **** 		}													\
 228:../FreeRTOS/Sources/queue.c **** 		if( ( pxQueue )->xTxLock == queueUNLOCKED )			\
 229:../FreeRTOS/Sources/queue.c **** 		{													\
 230:../FreeRTOS/Sources/queue.c **** 			( pxQueue )->xTxLock = queueLOCKED_UNMODIFIED;	\
 231:../FreeRTOS/Sources/queue.c **** 		}													\
 232:../FreeRTOS/Sources/queue.c **** 	}														\
 233:../FreeRTOS/Sources/queue.c **** 	taskEXIT_CRITICAL()
 234:../FreeRTOS/Sources/queue.c **** /*-----------------------------------------------------------*/
 235:../FreeRTOS/Sources/queue.c **** 
 236:../FreeRTOS/Sources/queue.c **** portBASE_TYPE xQueueGenericReset( xQueueHandle xQueue, portBASE_TYPE xNewQueue )
 237:../FreeRTOS/Sources/queue.c **** {
  27              		.loc 1 237 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 16
  30              		@ frame_needed = 1, uses_anonymous_args = 0
  31 0000 80B5     		push	{r7, lr}
  32              	.LCFI0:
  33              		.cfi_def_cfa_offset 8
  34              		.cfi_offset 7, -8
  35              		.cfi_offset 14, -4
  36 0002 84B0     		sub	sp, sp, #16
  37              	.LCFI1:
  38              		.cfi_def_cfa_offset 24
  39 0004 00AF     		add	r7, sp, #0
  40              	.LCFI2:
  41              		.cfi_def_cfa_register 7
  42 0006 7860     		str	r0, [r7, #4]
  43 0008 3960     		str	r1, [r7, #0]
 238:../FreeRTOS/Sources/queue.c **** xQUEUE *pxQueue;
 239:../FreeRTOS/Sources/queue.c **** 
 240:../FreeRTOS/Sources/queue.c **** 	pxQueue = ( xQUEUE * ) xQueue;
  44              		.loc 1 240 0
  45 000a 7B68     		ldr	r3, [r7, #4]
  46 000c FB60     		str	r3, [r7, #12]
 241:../FreeRTOS/Sources/queue.c **** 	configASSERT( pxQueue );
  47              		.loc 1 241 0
  48 000e FB68     		ldr	r3, [r7, #12]
  49 0010 002B     		cmp	r3, #0
  50 0012 02D1     		bne	.L2
  51              		.loc 1 241 0 is_stmt 0 discriminator 1
  52 0014 FFF7FEFF 		bl	ulPortSetInterruptMask
  53              	.L3:
  54              		.loc 1 241 0 discriminator 2
  55 0018 FEE7     		b	.L3
  56              	.L2:
 242:../FreeRTOS/Sources/queue.c **** 
 243:../FreeRTOS/Sources/queue.c **** 	taskENTER_CRITICAL();
  57              		.loc 1 243 0 is_stmt 1
  58 001a FFF7FEFF 		bl	vPortEnterCritical
 244:../FreeRTOS/Sources/queue.c **** 	{
 245:../FreeRTOS/Sources/queue.c **** 		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
  59              		.loc 1 245 0
  60 001e FB68     		ldr	r3, [r7, #12]
  61 0020 1A68     		ldr	r2, [r3, #0]
  62 0022 FB68     		ldr	r3, [r7, #12]
  63 0024 DB6B     		ldr	r3, [r3, #60]
  64 0026 F968     		ldr	r1, [r7, #12]
  65 0028 096C     		ldr	r1, [r1, #64]
  66 002a 01FB03F3 		mul	r3, r1, r3
  67 002e D218     		adds	r2, r2, r3
  68 0030 FB68     		ldr	r3, [r7, #12]
  69 0032 5A60     		str	r2, [r3, #4]
 246:../FreeRTOS/Sources/queue.c **** 		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
  70              		.loc 1 246 0
  71 0034 FB68     		ldr	r3, [r7, #12]
  72 0036 4FF00002 		mov	r2, #0
  73 003a 9A63     		str	r2, [r3, #56]
 247:../FreeRTOS/Sources/queue.c **** 		pxQueue->pcWriteTo = pxQueue->pcHead;
  74              		.loc 1 247 0
  75 003c FB68     		ldr	r3, [r7, #12]
  76 003e 1A68     		ldr	r2, [r3, #0]
  77 0040 FB68     		ldr	r3, [r7, #12]
  78 0042 9A60     		str	r2, [r3, #8]
 248:../FreeRTOS/Sources/queue.c **** 		pxQueue->pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( unsigned portBASE_TYPE ) 1U ) *
  79              		.loc 1 248 0
  80 0044 FB68     		ldr	r3, [r7, #12]
  81 0046 1A68     		ldr	r2, [r3, #0]
  82 0048 FB68     		ldr	r3, [r7, #12]
  83 004a DB6B     		ldr	r3, [r3, #60]
  84 004c 03F1FF33 		add	r3, r3, #-1
  85 0050 F968     		ldr	r1, [r7, #12]
  86 0052 096C     		ldr	r1, [r1, #64]
  87 0054 01FB03F3 		mul	r3, r1, r3
  88 0058 D218     		adds	r2, r2, r3
  89 005a FB68     		ldr	r3, [r7, #12]
  90 005c DA60     		str	r2, [r3, #12]
 249:../FreeRTOS/Sources/queue.c **** 		pxQueue->xRxLock = queueUNLOCKED;
  91              		.loc 1 249 0
  92 005e FB68     		ldr	r3, [r7, #12]
  93 0060 4FF0FF32 		mov	r2, #-1
  94 0064 5A64     		str	r2, [r3, #68]
 250:../FreeRTOS/Sources/queue.c **** 		pxQueue->xTxLock = queueUNLOCKED;
  95              		.loc 1 250 0
  96 0066 FB68     		ldr	r3, [r7, #12]
  97 0068 4FF0FF32 		mov	r2, #-1
  98 006c 9A64     		str	r2, [r3, #72]
 251:../FreeRTOS/Sources/queue.c **** 
 252:../FreeRTOS/Sources/queue.c **** 		if( xNewQueue == pdFALSE )
  99              		.loc 1 252 0
 100 006e 3B68     		ldr	r3, [r7, #0]
 101 0070 002B     		cmp	r3, #0
 102 0072 0FD1     		bne	.L4
 253:../FreeRTOS/Sources/queue.c **** 		{
 254:../FreeRTOS/Sources/queue.c **** 			/* If there are tasks blocked waiting to read from the queue, then
 255:../FreeRTOS/Sources/queue.c **** 			the tasks will remain blocked as after this function exits the queue
 256:../FreeRTOS/Sources/queue.c **** 			will still be empty.  If there are tasks blocked waiting to	write to
 257:../FreeRTOS/Sources/queue.c **** 			the queue, then one should be unblocked as after this function exits
 258:../FreeRTOS/Sources/queue.c **** 			it will be possible to write to it. */
 259:../FreeRTOS/Sources/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 103              		.loc 1 259 0
 104 0074 FB68     		ldr	r3, [r7, #12]
 105 0076 1B69     		ldr	r3, [r3, #16]
 106 0078 002B     		cmp	r3, #0
 107 007a 17D0     		beq	.L5
 260:../FreeRTOS/Sources/queue.c **** 			{
 261:../FreeRTOS/Sources/queue.c **** 				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 108              		.loc 1 261 0
 109 007c FB68     		ldr	r3, [r7, #12]
 110 007e 03F11003 		add	r3, r3, #16
 111 0082 1846     		mov	r0, r3
 112 0084 FFF7FEFF 		bl	xTaskRemoveFromEventList
 113 0088 0346     		mov	r3, r0
 114 008a 012B     		cmp	r3, #1
 115 008c 0ED1     		bne	.L5
 262:../FreeRTOS/Sources/queue.c **** 				{
 263:../FreeRTOS/Sources/queue.c **** 					portYIELD_WITHIN_API();
 116              		.loc 1 263 0
 117 008e FFF7FEFF 		bl	vPortYieldFromISR
 118 0092 0BE0     		b	.L5
 119              	.L4:
 264:../FreeRTOS/Sources/queue.c **** 				}
 265:../FreeRTOS/Sources/queue.c **** 			}
 266:../FreeRTOS/Sources/queue.c **** 		}
 267:../FreeRTOS/Sources/queue.c **** 		else
 268:../FreeRTOS/Sources/queue.c **** 		{
 269:../FreeRTOS/Sources/queue.c **** 			/* Ensure the event queues start in the correct state. */
 270:../FreeRTOS/Sources/queue.c **** 			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 120              		.loc 1 270 0
 121 0094 FB68     		ldr	r3, [r7, #12]
 122 0096 03F11003 		add	r3, r3, #16
 123 009a 1846     		mov	r0, r3
 124 009c FFF7FEFF 		bl	vListInitialise
 271:../FreeRTOS/Sources/queue.c **** 			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 125              		.loc 1 271 0
 126 00a0 FB68     		ldr	r3, [r7, #12]
 127 00a2 03F12403 		add	r3, r3, #36
 128 00a6 1846     		mov	r0, r3
 129 00a8 FFF7FEFF 		bl	vListInitialise
 130              	.L5:
 272:../FreeRTOS/Sources/queue.c **** 		}
 273:../FreeRTOS/Sources/queue.c **** 	}
 274:../FreeRTOS/Sources/queue.c **** 	taskEXIT_CRITICAL();
 131              		.loc 1 274 0
 132 00ac FFF7FEFF 		bl	vPortExitCritical
 275:../FreeRTOS/Sources/queue.c **** 
 276:../FreeRTOS/Sources/queue.c **** 	/* A value is returned for calling semantic consistency with previous
 277:../FreeRTOS/Sources/queue.c **** 	versions. */
 278:../FreeRTOS/Sources/queue.c **** 	return pdPASS;
 133              		.loc 1 278 0
 134 00b0 4FF00103 		mov	r3, #1
 279:../FreeRTOS/Sources/queue.c **** }
 135              		.loc 1 279 0
 136 00b4 1846     		mov	r0, r3
 137 00b6 07F11007 		add	r7, r7, #16
 138 00ba BD46     		mov	sp, r7
 139 00bc 80BD     		pop	{r7, pc}
 140              		.cfi_endproc
 141              	.LFE0:
 143 00be 00BF     		.section	.text.xQueueGenericCreate,"ax",%progbits
 144              		.align	2
 145              		.global	xQueueGenericCreate
 146              		.thumb
 147              		.thumb_func
 149              	xQueueGenericCreate:
 150              	.LFB1:
 280:../FreeRTOS/Sources/queue.c **** /*-----------------------------------------------------------*/
 281:../FreeRTOS/Sources/queue.c **** 
 282:../FreeRTOS/Sources/queue.c **** xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxIt
 283:../FreeRTOS/Sources/queue.c **** {
 151              		.loc 1 283 0
 152              		.cfi_startproc
 153              		@ args = 0, pretend = 0, frame = 32
 154              		@ frame_needed = 1, uses_anonymous_args = 0
 155 0000 80B5     		push	{r7, lr}
 156              	.LCFI3:
 157              		.cfi_def_cfa_offset 8
 158              		.cfi_offset 7, -8
 159              		.cfi_offset 14, -4
 160 0002 88B0     		sub	sp, sp, #32
 161              	.LCFI4:
 162              		.cfi_def_cfa_offset 40
 163 0004 00AF     		add	r7, sp, #0
 164              	.LCFI5:
 165              		.cfi_def_cfa_register 7
 166 0006 F860     		str	r0, [r7, #12]
 167 0008 B960     		str	r1, [r7, #8]
 168 000a 1346     		mov	r3, r2
 169 000c FB71     		strb	r3, [r7, #7]
 284:../FreeRTOS/Sources/queue.c **** xQUEUE *pxNewQueue;
 285:../FreeRTOS/Sources/queue.c **** size_t xQueueSizeInBytes;
 286:../FreeRTOS/Sources/queue.c **** xQueueHandle xReturn = NULL;
 170              		.loc 1 286 0
 171 000e 4FF00003 		mov	r3, #0
 172 0012 FB61     		str	r3, [r7, #28]
 287:../FreeRTOS/Sources/queue.c **** 
 288:../FreeRTOS/Sources/queue.c **** 	/* Remove compiler warnings about unused parameters should
 289:../FreeRTOS/Sources/queue.c **** 	configUSE_TRACE_FACILITY not be set to 1. */
 290:../FreeRTOS/Sources/queue.c **** 	( void ) ucQueueType;
 291:../FreeRTOS/Sources/queue.c **** 
 292:../FreeRTOS/Sources/queue.c **** 	/* Allocate the new queue structure. */
 293:../FreeRTOS/Sources/queue.c **** 	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
 173              		.loc 1 293 0
 174 0014 FB68     		ldr	r3, [r7, #12]
 175 0016 002B     		cmp	r3, #0
 176 0018 29D0     		beq	.L8
 294:../FreeRTOS/Sources/queue.c **** 	{
 295:../FreeRTOS/Sources/queue.c **** 		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
 177              		.loc 1 295 0
 178 001a 4FF04C00 		mov	r0, #76
 179 001e FFF7FEFF 		bl	pvPortMalloc
 180 0022 B861     		str	r0, [r7, #24]
 296:../FreeRTOS/Sources/queue.c **** 		if( pxNewQueue != NULL )
 181              		.loc 1 296 0
 182 0024 BB69     		ldr	r3, [r7, #24]
 183 0026 002B     		cmp	r3, #0
 184 0028 21D0     		beq	.L8
 297:../FreeRTOS/Sources/queue.c **** 		{
 298:../FreeRTOS/Sources/queue.c **** 			/* Create the list of pointers to queue items.  The queue is one byte
 299:../FreeRTOS/Sources/queue.c **** 			longer than asked for to make wrap checking easier/faster. */
 300:../FreeRTOS/Sources/queue.c **** 			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
 185              		.loc 1 300 0
 186 002a FB68     		ldr	r3, [r7, #12]
 187 002c BA68     		ldr	r2, [r7, #8]
 188 002e 02FB03F3 		mul	r3, r2, r3
 189 0032 03F10103 		add	r3, r3, #1
 190 0036 7B61     		str	r3, [r7, #20]
 301:../FreeRTOS/Sources/queue.c **** 
 302:../FreeRTOS/Sources/queue.c **** 			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
 191              		.loc 1 302 0
 192 0038 7869     		ldr	r0, [r7, #20]
 193 003a FFF7FEFF 		bl	pvPortMalloc
 194 003e 0246     		mov	r2, r0
 195 0040 BB69     		ldr	r3, [r7, #24]
 196 0042 1A60     		str	r2, [r3, #0]
 303:../FreeRTOS/Sources/queue.c **** 			if( pxNewQueue->pcHead != NULL )
 197              		.loc 1 303 0
 198 0044 BB69     		ldr	r3, [r7, #24]
 199 0046 1B68     		ldr	r3, [r3, #0]
 200 0048 002B     		cmp	r3, #0
 201 004a 0DD0     		beq	.L9
 304:../FreeRTOS/Sources/queue.c **** 			{
 305:../FreeRTOS/Sources/queue.c **** 				/* Initialise the queue members as described above where the
 306:../FreeRTOS/Sources/queue.c **** 				queue type is defined. */
 307:../FreeRTOS/Sources/queue.c **** 				pxNewQueue->uxLength = uxQueueLength;
 202              		.loc 1 307 0
 203 004c BB69     		ldr	r3, [r7, #24]
 204 004e FA68     		ldr	r2, [r7, #12]
 205 0050 DA63     		str	r2, [r3, #60]
 308:../FreeRTOS/Sources/queue.c **** 				pxNewQueue->uxItemSize = uxItemSize;
 206              		.loc 1 308 0
 207 0052 BB69     		ldr	r3, [r7, #24]
 208 0054 BA68     		ldr	r2, [r7, #8]
 209 0056 1A64     		str	r2, [r3, #64]
 309:../FreeRTOS/Sources/queue.c **** 				xQueueGenericReset( pxNewQueue, pdTRUE );
 210              		.loc 1 309 0
 211 0058 B869     		ldr	r0, [r7, #24]
 212 005a 4FF00101 		mov	r1, #1
 213 005e FFF7FEFF 		bl	xQueueGenericReset
 310:../FreeRTOS/Sources/queue.c **** 
 311:../FreeRTOS/Sources/queue.c **** 				#if ( configUSE_TRACE_FACILITY == 1 )
 312:../FreeRTOS/Sources/queue.c **** 				{
 313:../FreeRTOS/Sources/queue.c **** 					pxNewQueue->ucQueueType = ucQueueType;
 314:../FreeRTOS/Sources/queue.c **** 				}
 315:../FreeRTOS/Sources/queue.c **** 				#endif /* configUSE_TRACE_FACILITY */
 316:../FreeRTOS/Sources/queue.c **** 
 317:../FreeRTOS/Sources/queue.c **** 				#if( configUSE_QUEUE_SETS == 1 )
 318:../FreeRTOS/Sources/queue.c **** 				{
 319:../FreeRTOS/Sources/queue.c **** 					pxNewQueue->pxQueueSetContainer = NULL;
 320:../FreeRTOS/Sources/queue.c **** 				}
 321:../FreeRTOS/Sources/queue.c **** 				#endif /* configUSE_QUEUE_SETS */
 322:../FreeRTOS/Sources/queue.c **** 
 323:../FreeRTOS/Sources/queue.c **** 				traceQUEUE_CREATE( pxNewQueue );
 324:../FreeRTOS/Sources/queue.c **** 				xReturn = pxNewQueue;
 214              		.loc 1 324 0
 215 0062 BB69     		ldr	r3, [r7, #24]
 216 0064 FB61     		str	r3, [r7, #28]
 217 0066 02E0     		b	.L8
 218              	.L9:
 325:../FreeRTOS/Sources/queue.c **** 			}
 326:../FreeRTOS/Sources/queue.c **** 			else
 327:../FreeRTOS/Sources/queue.c **** 			{
 328:../FreeRTOS/Sources/queue.c **** 				traceQUEUE_CREATE_FAILED( ucQueueType );
 329:../FreeRTOS/Sources/queue.c **** 				vPortFree( pxNewQueue );
 219              		.loc 1 329 0
 220 0068 B869     		ldr	r0, [r7, #24]
 221 006a FFF7FEFF 		bl	vPortFree
 222              	.L8:
 330:../FreeRTOS/Sources/queue.c **** 			}
 331:../FreeRTOS/Sources/queue.c **** 		}
 332:../FreeRTOS/Sources/queue.c **** 	}
 333:../FreeRTOS/Sources/queue.c **** 
 334:../FreeRTOS/Sources/queue.c **** 	configASSERT( xReturn );
 223              		.loc 1 334 0
 224 006e FB69     		ldr	r3, [r7, #28]
 225 0070 002B     		cmp	r3, #0
 226 0072 02D1     		bne	.L10
 227              		.loc 1 334 0 is_stmt 0 discriminator 1
 228 0074 FFF7FEFF 		bl	ulPortSetInterruptMask
 229              	.L11:
 230              		.loc 1 334 0 discriminator 2
 231 0078 FEE7     		b	.L11
 232              	.L10:
 335:../FreeRTOS/Sources/queue.c **** 
 336:../FreeRTOS/Sources/queue.c **** 	return xReturn;
 233              		.loc 1 336 0 is_stmt 1
 234 007a FB69     		ldr	r3, [r7, #28]
 337:../FreeRTOS/Sources/queue.c **** }
 235              		.loc 1 337 0
 236 007c 1846     		mov	r0, r3
 237 007e 07F12007 		add	r7, r7, #32
 238 0082 BD46     		mov	sp, r7
 239 0084 80BD     		pop	{r7, pc}
 240              		.cfi_endproc
 241              	.LFE1:
 243 0086 00BF     		.section	.text.xQueueCreateMutex,"ax",%progbits
 244              		.align	2
 245              		.global	xQueueCreateMutex
 246              		.thumb
 247              		.thumb_func
 249              	xQueueCreateMutex:
 250              	.LFB2:
 338:../FreeRTOS/Sources/queue.c **** /*-----------------------------------------------------------*/
 339:../FreeRTOS/Sources/queue.c **** 
 340:../FreeRTOS/Sources/queue.c **** #if ( configUSE_MUTEXES == 1 )
 341:../FreeRTOS/Sources/queue.c **** 
 342:../FreeRTOS/Sources/queue.c **** 	xQueueHandle xQueueCreateMutex( unsigned char ucQueueType )
 343:../FreeRTOS/Sources/queue.c **** 	{
 251              		.loc 1 343 0
 252              		.cfi_startproc
 253              		@ args = 0, pretend = 0, frame = 16
 254              		@ frame_needed = 1, uses_anonymous_args = 0
 255 0000 80B5     		push	{r7, lr}
 256              	.LCFI6:
 257              		.cfi_def_cfa_offset 8
 258              		.cfi_offset 7, -8
 259              		.cfi_offset 14, -4
 260 0002 84B0     		sub	sp, sp, #16
 261              	.LCFI7:
 262              		.cfi_def_cfa_offset 24
 263 0004 00AF     		add	r7, sp, #0
 264              	.LCFI8:
 265              		.cfi_def_cfa_register 7
 266 0006 0346     		mov	r3, r0
 267 0008 FB71     		strb	r3, [r7, #7]
 344:../FreeRTOS/Sources/queue.c **** 	xQUEUE *pxNewQueue;
 345:../FreeRTOS/Sources/queue.c **** 
 346:../FreeRTOS/Sources/queue.c **** 		/* Prevent compiler warnings about unused parameters if
 347:../FreeRTOS/Sources/queue.c **** 		configUSE_TRACE_FACILITY does not equal 1. */
 348:../FreeRTOS/Sources/queue.c **** 		( void ) ucQueueType;
 349:../FreeRTOS/Sources/queue.c **** 
 350:../FreeRTOS/Sources/queue.c **** 		/* Allocate the new queue structure. */
 351:../FreeRTOS/Sources/queue.c **** 		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
 268              		.loc 1 351 0
 269 000a 4FF04C00 		mov	r0, #76
 270 000e FFF7FEFF 		bl	pvPortMalloc
 271 0012 F860     		str	r0, [r7, #12]
 352:../FreeRTOS/Sources/queue.c **** 		if( pxNewQueue != NULL )
 272              		.loc 1 352 0
 273 0014 FB68     		ldr	r3, [r7, #12]
 274 0016 002B     		cmp	r3, #0
 275 0018 38D0     		beq	.L14
 353:../FreeRTOS/Sources/queue.c **** 		{
 354:../FreeRTOS/Sources/queue.c **** 			/* Information required for priority inheritance. */
 355:../FreeRTOS/Sources/queue.c **** 			pxNewQueue->pxMutexHolder = NULL;
 276              		.loc 1 355 0
 277 001a FB68     		ldr	r3, [r7, #12]
 278 001c 4FF00002 		mov	r2, #0
 279 0020 5A60     		str	r2, [r3, #4]
 356:../FreeRTOS/Sources/queue.c **** 			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 280              		.loc 1 356 0
 281 0022 FB68     		ldr	r3, [r7, #12]
 282 0024 4FF00002 		mov	r2, #0
 283 0028 1A60     		str	r2, [r3, #0]
 357:../FreeRTOS/Sources/queue.c **** 
 358:../FreeRTOS/Sources/queue.c **** 			/* Queues used as a mutex no data is actually copied into or out
 359:../FreeRTOS/Sources/queue.c **** 			of the queue. */
 360:../FreeRTOS/Sources/queue.c **** 			pxNewQueue->pcWriteTo = NULL;
 284              		.loc 1 360 0
 285 002a FB68     		ldr	r3, [r7, #12]
 286 002c 4FF00002 		mov	r2, #0
 287 0030 9A60     		str	r2, [r3, #8]
 361:../FreeRTOS/Sources/queue.c **** 			pxNewQueue->pcReadFrom = NULL;
 288              		.loc 1 361 0
 289 0032 FB68     		ldr	r3, [r7, #12]
 290 0034 4FF00002 		mov	r2, #0
 291 0038 DA60     		str	r2, [r3, #12]
 362:../FreeRTOS/Sources/queue.c **** 
 363:../FreeRTOS/Sources/queue.c **** 			/* Each mutex has a length of 1 (like a binary semaphore) and
 364:../FreeRTOS/Sources/queue.c **** 			an item size of 0 as nothing is actually copied into or out
 365:../FreeRTOS/Sources/queue.c **** 			of the mutex. */
 366:../FreeRTOS/Sources/queue.c **** 			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
 292              		.loc 1 366 0
 293 003a FB68     		ldr	r3, [r7, #12]
 294 003c 4FF00002 		mov	r2, #0
 295 0040 9A63     		str	r2, [r3, #56]
 367:../FreeRTOS/Sources/queue.c **** 			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
 296              		.loc 1 367 0
 297 0042 FB68     		ldr	r3, [r7, #12]
 298 0044 4FF00102 		mov	r2, #1
 299 0048 DA63     		str	r2, [r3, #60]
 368:../FreeRTOS/Sources/queue.c **** 			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
 300              		.loc 1 368 0
 301 004a FB68     		ldr	r3, [r7, #12]
 302 004c 4FF00002 		mov	r2, #0
 303 0050 1A64     		str	r2, [r3, #64]
 369:../FreeRTOS/Sources/queue.c **** 			pxNewQueue->xRxLock = queueUNLOCKED;
 304              		.loc 1 369 0
 305 0052 FB68     		ldr	r3, [r7, #12]
 306 0054 4FF0FF32 		mov	r2, #-1
 307 0058 5A64     		str	r2, [r3, #68]
 370:../FreeRTOS/Sources/queue.c **** 			pxNewQueue->xTxLock = queueUNLOCKED;
 308              		.loc 1 370 0
 309 005a FB68     		ldr	r3, [r7, #12]
 310 005c 4FF0FF32 		mov	r2, #-1
 311 0060 9A64     		str	r2, [r3, #72]
 371:../FreeRTOS/Sources/queue.c **** 
 372:../FreeRTOS/Sources/queue.c **** 			#if ( configUSE_TRACE_FACILITY == 1 )
 373:../FreeRTOS/Sources/queue.c **** 			{
 374:../FreeRTOS/Sources/queue.c **** 				pxNewQueue->ucQueueType = ucQueueType;
 375:../FreeRTOS/Sources/queue.c **** 			}
 376:../FreeRTOS/Sources/queue.c **** 			#endif
 377:../FreeRTOS/Sources/queue.c **** 
 378:../FreeRTOS/Sources/queue.c **** 			#if ( configUSE_QUEUE_SETS == 1 )
 379:../FreeRTOS/Sources/queue.c **** 			{
 380:../FreeRTOS/Sources/queue.c **** 				pxNewQueue->pxQueueSetContainer = NULL;
 381:../FreeRTOS/Sources/queue.c **** 			}
 382:../FreeRTOS/Sources/queue.c **** 			#endif
 383:../FreeRTOS/Sources/queue.c **** 
 384:../FreeRTOS/Sources/queue.c **** 			/* Ensure the event queues start with the correct state. */
 385:../FreeRTOS/Sources/queue.c **** 			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
 312              		.loc 1 385 0
 313 0062 FB68     		ldr	r3, [r7, #12]
 314 0064 03F11003 		add	r3, r3, #16
 315 0068 1846     		mov	r0, r3
 316 006a FFF7FEFF 		bl	vListInitialise
 386:../FreeRTOS/Sources/queue.c **** 			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
 317              		.loc 1 386 0
 318 006e FB68     		ldr	r3, [r7, #12]
 319 0070 03F12403 		add	r3, r3, #36
 320 0074 1846     		mov	r0, r3
 321 0076 FFF7FEFF 		bl	vListInitialise
 387:../FreeRTOS/Sources/queue.c **** 
 388:../FreeRTOS/Sources/queue.c **** 			traceCREATE_MUTEX( pxNewQueue );
 389:../FreeRTOS/Sources/queue.c **** 
 390:../FreeRTOS/Sources/queue.c **** 			/* Start with the semaphore in the expected state. */
 391:../FreeRTOS/Sources/queue.c **** 			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
 322              		.loc 1 391 0
 323 007a F868     		ldr	r0, [r7, #12]
 324 007c 4FF00001 		mov	r1, #0
 325 0080 4FF00002 		mov	r2, #0
 326 0084 4FF00003 		mov	r3, #0
 327 0088 FFF7FEFF 		bl	xQueueGenericSend
 328              	.L14:
 392:../FreeRTOS/Sources/queue.c **** 		}
 393:../FreeRTOS/Sources/queue.c **** 		else
 394:../FreeRTOS/Sources/queue.c **** 		{
 395:../FreeRTOS/Sources/queue.c **** 			traceCREATE_MUTEX_FAILED();
 396:../FreeRTOS/Sources/queue.c **** 		}
 397:../FreeRTOS/Sources/queue.c **** 
 398:../FreeRTOS/Sources/queue.c **** 		configASSERT( pxNewQueue );
 329              		.loc 1 398 0
 330 008c FB68     		ldr	r3, [r7, #12]
 331 008e 002B     		cmp	r3, #0
 332 0090 02D1     		bne	.L15
 333              		.loc 1 398 0 is_stmt 0 discriminator 1
 334 0092 FFF7FEFF 		bl	ulPortSetInterruptMask
 335              	.L16:
 336              		.loc 1 398 0 discriminator 2
 337 0096 FEE7     		b	.L16
 338              	.L15:
 399:../FreeRTOS/Sources/queue.c **** 		return pxNewQueue;
 339              		.loc 1 399 0 is_stmt 1
 340 0098 FB68     		ldr	r3, [r7, #12]
 400:../FreeRTOS/Sources/queue.c **** 	}
 341              		.loc 1 400 0
 342 009a 1846     		mov	r0, r3
 343 009c 07F11007 		add	r7, r7, #16
 344 00a0 BD46     		mov	sp, r7
 345 00a2 80BD     		pop	{r7, pc}
 346              		.cfi_endproc
 347              	.LFE2:
 349              		.section	.text.xQueueGenericSend,"ax",%progbits
 350              		.align	2
 351              		.global	xQueueGenericSend
 352              		.thumb
 353              		.thumb_func
 355              	xQueueGenericSend:
 356              	.LFB3:
 401:../FreeRTOS/Sources/queue.c **** 
 402:../FreeRTOS/Sources/queue.c **** #endif /* configUSE_MUTEXES */
 403:../FreeRTOS/Sources/queue.c **** /*-----------------------------------------------------------*/
 404:../FreeRTOS/Sources/queue.c **** 
 405:../FreeRTOS/Sources/queue.c **** #if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )
 406:../FreeRTOS/Sources/queue.c **** 
 407:../FreeRTOS/Sources/queue.c **** 	void* xQueueGetMutexHolder( xQueueHandle xSemaphore )
 408:../FreeRTOS/Sources/queue.c **** 	{
 409:../FreeRTOS/Sources/queue.c **** 	void *pxReturn;
 410:../FreeRTOS/Sources/queue.c **** 
 411:../FreeRTOS/Sources/queue.c **** 		/* This function is called by xSemaphoreGetMutexHolder(), and should not
 412:../FreeRTOS/Sources/queue.c **** 		be called directly.  Note:  This is is a good way of determining if the
 413:../FreeRTOS/Sources/queue.c **** 		calling task is the mutex holder, but not a good way of determining the
 414:../FreeRTOS/Sources/queue.c **** 		identity of the mutex holder, as the holder may change between the
 415:../FreeRTOS/Sources/queue.c **** 		following critical section exiting and the function returning. */
 416:../FreeRTOS/Sources/queue.c **** 		taskENTER_CRITICAL();
 417:../FreeRTOS/Sources/queue.c **** 		{
 418:../FreeRTOS/Sources/queue.c **** 			if( ( ( xQUEUE * ) xSemaphore )->uxQueueType == queueQUEUE_IS_MUTEX )
 419:../FreeRTOS/Sources/queue.c **** 			{
 420:../FreeRTOS/Sources/queue.c **** 				pxReturn = ( void * ) ( ( xQUEUE * ) xSemaphore )->pxMutexHolder;
 421:../FreeRTOS/Sources/queue.c **** 			}
 422:../FreeRTOS/Sources/queue.c **** 			else
 423:../FreeRTOS/Sources/queue.c **** 			{
 424:../FreeRTOS/Sources/queue.c **** 				pxReturn = NULL;
 425:../FreeRTOS/Sources/queue.c **** 			}
 426:../FreeRTOS/Sources/queue.c **** 		}
 427:../FreeRTOS/Sources/queue.c **** 		taskEXIT_CRITICAL();
 428:../FreeRTOS/Sources/queue.c **** 
 429:../FreeRTOS/Sources/queue.c **** 		return pxReturn;
 430:../FreeRTOS/Sources/queue.c **** 	}
 431:../FreeRTOS/Sources/queue.c **** 
 432:../FreeRTOS/Sources/queue.c **** #endif
 433:../FreeRTOS/Sources/queue.c **** /*-----------------------------------------------------------*/
 434:../FreeRTOS/Sources/queue.c **** 
 435:../FreeRTOS/Sources/queue.c **** #if ( configUSE_RECURSIVE_MUTEXES == 1 )
 436:../FreeRTOS/Sources/queue.c **** 
 437:../FreeRTOS/Sources/queue.c **** 	portBASE_TYPE xQueueGiveMutexRecursive( xQueueHandle xMutex )
 438:../FreeRTOS/Sources/queue.c **** 	{
 439:../FreeRTOS/Sources/queue.c **** 	portBASE_TYPE xReturn;
 440:../FreeRTOS/Sources/queue.c **** 	xQUEUE *pxMutex;
 441:../FreeRTOS/Sources/queue.c **** 
 442:../FreeRTOS/Sources/queue.c **** 		pxMutex = ( xQUEUE * ) xMutex;
 443:../FreeRTOS/Sources/queue.c **** 		configASSERT( pxMutex );
 444:../FreeRTOS/Sources/queue.c **** 
 445:../FreeRTOS/Sources/queue.c **** 		/* If this is the task that holds the mutex then pxMutexHolder will not
 446:../FreeRTOS/Sources/queue.c **** 		change outside of this task.  If this task does not hold the mutex then
 447:../FreeRTOS/Sources/queue.c **** 		pxMutexHolder can never coincidentally equal the tasks handle, and as
 448:../FreeRTOS/Sources/queue.c **** 		this is the only condition we are interested in it does not matter if
 449:../FreeRTOS/Sources/queue.c **** 		pxMutexHolder is accessed simultaneously by another task.  Therefore no
 450:../FreeRTOS/Sources/queue.c **** 		mutual exclusion is required to test the pxMutexHolder variable. */
 451:../FreeRTOS/Sources/queue.c **** 		if( pxMutex->pxMutexHolder == xTaskGetCurrentTaskHandle() )
 452:../FreeRTOS/Sources/queue.c **** 		{
 453:../FreeRTOS/Sources/queue.c **** 			traceGIVE_MUTEX_RECURSIVE( pxMutex );
 454:../FreeRTOS/Sources/queue.c **** 
 455:../FreeRTOS/Sources/queue.c **** 			/* uxRecursiveCallCount cannot be zero if pxMutexHolder is equal to
 456:../FreeRTOS/Sources/queue.c **** 			the task handle, therefore no underflow check is required.  Also,
 457:../FreeRTOS/Sources/queue.c **** 			uxRecursiveCallCount is only modified by the mutex holder, and as
 458:../FreeRTOS/Sources/queue.c **** 			there can only be one, no mutual exclusion is required to modify the
 459:../FreeRTOS/Sources/queue.c **** 			uxRecursiveCallCount member. */
 460:../FreeRTOS/Sources/queue.c **** 			( pxMutex->uxRecursiveCallCount )--;
 461:../FreeRTOS/Sources/queue.c **** 
 462:../FreeRTOS/Sources/queue.c **** 			/* Have we unwound the call count? */
 463:../FreeRTOS/Sources/queue.c **** 			if( pxMutex->uxRecursiveCallCount == 0 )
 464:../FreeRTOS/Sources/queue.c **** 			{
 465:../FreeRTOS/Sources/queue.c **** 				/* Return the mutex.  This will automatically unblock any other
 466:../FreeRTOS/Sources/queue.c **** 				task that might be waiting to access the mutex. */
 467:../FreeRTOS/Sources/queue.c **** 				xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
 468:../FreeRTOS/Sources/queue.c **** 			}
 469:../FreeRTOS/Sources/queue.c **** 
 470:../FreeRTOS/Sources/queue.c **** 			xReturn = pdPASS;
 471:../FreeRTOS/Sources/queue.c **** 		}
 472:../FreeRTOS/Sources/queue.c **** 		else
 473:../FreeRTOS/Sources/queue.c **** 		{
 474:../FreeRTOS/Sources/queue.c **** 			/* We cannot give the mutex because we are not the holder. */
 475:../FreeRTOS/Sources/queue.c **** 			xReturn = pdFAIL;
 476:../FreeRTOS/Sources/queue.c **** 
 477:../FreeRTOS/Sources/queue.c **** 			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
 478:../FreeRTOS/Sources/queue.c **** 		}
 479:../FreeRTOS/Sources/queue.c **** 
 480:../FreeRTOS/Sources/queue.c **** 		return xReturn;
 481:../FreeRTOS/Sources/queue.c **** 	}
 482:../FreeRTOS/Sources/queue.c **** 
 483:../FreeRTOS/Sources/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 484:../FreeRTOS/Sources/queue.c **** /*-----------------------------------------------------------*/
 485:../FreeRTOS/Sources/queue.c **** 
 486:../FreeRTOS/Sources/queue.c **** #if ( configUSE_RECURSIVE_MUTEXES == 1 )
 487:../FreeRTOS/Sources/queue.c **** 
 488:../FreeRTOS/Sources/queue.c **** 	portBASE_TYPE xQueueTakeMutexRecursive( xQueueHandle xMutex, portTickType xBlockTime )
 489:../FreeRTOS/Sources/queue.c **** 	{
 490:../FreeRTOS/Sources/queue.c **** 	portBASE_TYPE xReturn;
 491:../FreeRTOS/Sources/queue.c **** 	xQUEUE *pxMutex;
 492:../FreeRTOS/Sources/queue.c **** 
 493:../FreeRTOS/Sources/queue.c **** 		pxMutex = ( xQUEUE * ) xMutex;
 494:../FreeRTOS/Sources/queue.c **** 		configASSERT( pxMutex );
 495:../FreeRTOS/Sources/queue.c **** 
 496:../FreeRTOS/Sources/queue.c **** 		/* Comments regarding mutual exclusion as per those within
 497:../FreeRTOS/Sources/queue.c **** 		xQueueGiveMutexRecursive(). */
 498:../FreeRTOS/Sources/queue.c **** 
 499:../FreeRTOS/Sources/queue.c **** 		traceTAKE_MUTEX_RECURSIVE( pxMutex );
 500:../FreeRTOS/Sources/queue.c **** 
 501:../FreeRTOS/Sources/queue.c **** 		if( pxMutex->pxMutexHolder == xTaskGetCurrentTaskHandle() )
 502:../FreeRTOS/Sources/queue.c **** 		{
 503:../FreeRTOS/Sources/queue.c **** 			( pxMutex->uxRecursiveCallCount )++;
 504:../FreeRTOS/Sources/queue.c **** 			xReturn = pdPASS;
 505:../FreeRTOS/Sources/queue.c **** 		}
 506:../FreeRTOS/Sources/queue.c **** 		else
 507:../FreeRTOS/Sources/queue.c **** 		{
 508:../FreeRTOS/Sources/queue.c **** 			xReturn = xQueueGenericReceive( pxMutex, NULL, xBlockTime, pdFALSE );
 509:../FreeRTOS/Sources/queue.c **** 
 510:../FreeRTOS/Sources/queue.c **** 			/* pdPASS will only be returned if we successfully obtained the mutex,
 511:../FreeRTOS/Sources/queue.c **** 			we may have blocked to reach here. */
 512:../FreeRTOS/Sources/queue.c **** 			if( xReturn == pdPASS )
 513:../FreeRTOS/Sources/queue.c **** 			{
 514:../FreeRTOS/Sources/queue.c **** 				( pxMutex->uxRecursiveCallCount )++;
 515:../FreeRTOS/Sources/queue.c **** 			}
 516:../FreeRTOS/Sources/queue.c **** 			else
 517:../FreeRTOS/Sources/queue.c **** 			{
 518:../FreeRTOS/Sources/queue.c **** 				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
 519:../FreeRTOS/Sources/queue.c **** 			}
 520:../FreeRTOS/Sources/queue.c **** 		}
 521:../FreeRTOS/Sources/queue.c **** 
 522:../FreeRTOS/Sources/queue.c **** 		return xReturn;
 523:../FreeRTOS/Sources/queue.c **** 	}
 524:../FreeRTOS/Sources/queue.c **** 
 525:../FreeRTOS/Sources/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 526:../FreeRTOS/Sources/queue.c **** /*-----------------------------------------------------------*/
 527:../FreeRTOS/Sources/queue.c **** 
 528:../FreeRTOS/Sources/queue.c **** #if ( configUSE_COUNTING_SEMAPHORES == 1 )
 529:../FreeRTOS/Sources/queue.c **** 
 530:../FreeRTOS/Sources/queue.c **** 	xQueueHandle xQueueCreateCountingSemaphore( unsigned portBASE_TYPE uxCountValue, unsigned portBASE
 531:../FreeRTOS/Sources/queue.c **** 	{
 532:../FreeRTOS/Sources/queue.c **** 	xQueueHandle xHandle;
 533:../FreeRTOS/Sources/queue.c **** 
 534:../FreeRTOS/Sources/queue.c **** 		xHandle = xQueueGenericCreate( ( unsigned portBASE_TYPE ) uxCountValue, queueSEMAPHORE_QUEUE_ITEM
 535:../FreeRTOS/Sources/queue.c **** 
 536:../FreeRTOS/Sources/queue.c **** 		if( xHandle != NULL )
 537:../FreeRTOS/Sources/queue.c **** 		{
 538:../FreeRTOS/Sources/queue.c **** 			( ( xQUEUE * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 539:../FreeRTOS/Sources/queue.c **** 
 540:../FreeRTOS/Sources/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE();
 541:../FreeRTOS/Sources/queue.c **** 		}
 542:../FreeRTOS/Sources/queue.c **** 		else
 543:../FreeRTOS/Sources/queue.c **** 		{
 544:../FreeRTOS/Sources/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE_FAILED();
 545:../FreeRTOS/Sources/queue.c **** 		}
 546:../FreeRTOS/Sources/queue.c **** 
 547:../FreeRTOS/Sources/queue.c **** 		configASSERT( xHandle );
 548:../FreeRTOS/Sources/queue.c **** 		return xHandle;
 549:../FreeRTOS/Sources/queue.c **** 	}
 550:../FreeRTOS/Sources/queue.c **** 
 551:../FreeRTOS/Sources/queue.c **** #endif /* configUSE_COUNTING_SEMAPHORES */
 552:../FreeRTOS/Sources/queue.c **** /*-----------------------------------------------------------*/
 553:../FreeRTOS/Sources/queue.c **** 
 554:../FreeRTOS/Sources/queue.c **** signed portBASE_TYPE xQueueGenericSend( xQueueHandle xQueue, const void * const pvItemToQueue, port
 555:../FreeRTOS/Sources/queue.c **** {
 357              		.loc 1 555 0
 358              		.cfi_startproc
 359              		@ args = 0, pretend = 0, frame = 32
 360              		@ frame_needed = 1, uses_anonymous_args = 0
 361 0000 80B5     		push	{r7, lr}
 362              	.LCFI9:
 363              		.cfi_def_cfa_offset 8
 364              		.cfi_offset 7, -8
 365              		.cfi_offset 14, -4
 366 0002 88B0     		sub	sp, sp, #32
 367              	.LCFI10:
 368              		.cfi_def_cfa_offset 40
 369 0004 00AF     		add	r7, sp, #0
 370              	.LCFI11:
 371              		.cfi_def_cfa_register 7
 372 0006 F860     		str	r0, [r7, #12]
 373 0008 B960     		str	r1, [r7, #8]
 374 000a 7A60     		str	r2, [r7, #4]
 375 000c 3B60     		str	r3, [r7, #0]
 556:../FreeRTOS/Sources/queue.c **** signed portBASE_TYPE xEntryTimeSet = pdFALSE;
 376              		.loc 1 556 0
 377 000e 4FF00003 		mov	r3, #0
 378 0012 FB61     		str	r3, [r7, #28]
 557:../FreeRTOS/Sources/queue.c **** xTimeOutType xTimeOut;
 558:../FreeRTOS/Sources/queue.c **** xQUEUE *pxQueue;
 559:../FreeRTOS/Sources/queue.c **** 
 560:../FreeRTOS/Sources/queue.c **** 	pxQueue = ( xQUEUE * ) xQueue;
 379              		.loc 1 560 0
 380 0014 FB68     		ldr	r3, [r7, #12]
 381 0016 BB61     		str	r3, [r7, #24]
 561:../FreeRTOS/Sources/queue.c **** 	configASSERT( pxQueue );
 382              		.loc 1 561 0
 383 0018 BB69     		ldr	r3, [r7, #24]
 384 001a 002B     		cmp	r3, #0
 385 001c 02D1     		bne	.L19
 386              		.loc 1 561 0 is_stmt 0 discriminator 1
 387 001e FFF7FEFF 		bl	ulPortSetInterruptMask
 388              	.L20:
 389              		.loc 1 561 0 discriminator 2
 390 0022 FEE7     		b	.L20
 391              	.L19:
 562:../FreeRTOS/Sources/queue.c **** 	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 
 392              		.loc 1 562 0 is_stmt 1
 393 0024 BB68     		ldr	r3, [r7, #8]
 394 0026 002B     		cmp	r3, #0
 395 0028 03D1     		bne	.L21
 396              		.loc 1 562 0 is_stmt 0 discriminator 2
 397 002a BB69     		ldr	r3, [r7, #24]
 398 002c 1B6C     		ldr	r3, [r3, #64]
 399 002e 002B     		cmp	r3, #0
 400 0030 02D1     		bne	.L22
 401              	.L21:
 402              		.loc 1 562 0 discriminator 1
 403 0032 4FF00103 		mov	r3, #1
 404 0036 01E0     		b	.L23
 405              	.L22:
 406              		.loc 1 562 0 discriminator 3
 407 0038 4FF00003 		mov	r3, #0
 408              	.L23:
 409              		.loc 1 562 0 discriminator 4
 410 003c 002B     		cmp	r3, #0
 411 003e 03D1     		bne	.L24
 412              		.loc 1 562 0 discriminator 5
 413 0040 FFF7FEFF 		bl	ulPortSetInterruptMask
 414              	.L25:
 415              		.loc 1 562 0 discriminator 6
 416 0044 FEE7     		b	.L25
 417              	.L37:
 563:../FreeRTOS/Sources/queue.c **** 
 564:../FreeRTOS/Sources/queue.c **** 	/* This function relaxes the coding standard somewhat to allow return
 565:../FreeRTOS/Sources/queue.c **** 	statements within the function itself.  This is done in the interest
 566:../FreeRTOS/Sources/queue.c **** 	of execution time efficiency. */
 567:../FreeRTOS/Sources/queue.c **** 	for( ;; )
 568:../FreeRTOS/Sources/queue.c **** 	{
 569:../FreeRTOS/Sources/queue.c **** 		taskENTER_CRITICAL();
 570:../FreeRTOS/Sources/queue.c **** 		{
 571:../FreeRTOS/Sources/queue.c **** 			/* Is there room on the queue now?  To be running we must be
 572:../FreeRTOS/Sources/queue.c **** 			the highest priority task wanting to access the queue. */
 573:../FreeRTOS/Sources/queue.c **** 			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 574:../FreeRTOS/Sources/queue.c **** 			{
 575:../FreeRTOS/Sources/queue.c **** 				traceQUEUE_SEND( pxQueue );
 576:../FreeRTOS/Sources/queue.c **** 				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 577:../FreeRTOS/Sources/queue.c **** 
 578:../FreeRTOS/Sources/queue.c **** 				#if ( configUSE_QUEUE_SETS == 1 )
 579:../FreeRTOS/Sources/queue.c **** 				{
 580:../FreeRTOS/Sources/queue.c **** 					if( pxQueue->pxQueueSetContainer != NULL )
 581:../FreeRTOS/Sources/queue.c **** 					{
 582:../FreeRTOS/Sources/queue.c **** 						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) == pdTRUE )
 583:../FreeRTOS/Sources/queue.c **** 						{
 584:../FreeRTOS/Sources/queue.c **** 							/* The queue is a member of a queue set, and posting
 585:../FreeRTOS/Sources/queue.c **** 							to the queue set caused a higher priority task to
 586:../FreeRTOS/Sources/queue.c **** 							unblock. A context switch is required. */
 587:../FreeRTOS/Sources/queue.c **** 							portYIELD_WITHIN_API();
 588:../FreeRTOS/Sources/queue.c **** 						}
 589:../FreeRTOS/Sources/queue.c **** 					}
 590:../FreeRTOS/Sources/queue.c **** 					else
 591:../FreeRTOS/Sources/queue.c **** 					{
 592:../FreeRTOS/Sources/queue.c **** 						/* If there was a task waiting for data to arrive on the
 593:../FreeRTOS/Sources/queue.c **** 						queue then unblock it now. */
 594:../FreeRTOS/Sources/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 595:../FreeRTOS/Sources/queue.c **** 						{
 596:../FreeRTOS/Sources/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
 597:../FreeRTOS/Sources/queue.c **** 							{
 598:../FreeRTOS/Sources/queue.c **** 								/* The unblocked task has a priority higher than
 599:../FreeRTOS/Sources/queue.c **** 								our own so yield immediately.  Yes it is ok to
 600:../FreeRTOS/Sources/queue.c **** 								do this from within the critical section - the
 601:../FreeRTOS/Sources/queue.c **** 								kernel takes care of that. */
 602:../FreeRTOS/Sources/queue.c **** 								portYIELD_WITHIN_API();
 603:../FreeRTOS/Sources/queue.c **** 							}
 604:../FreeRTOS/Sources/queue.c **** 						}
 605:../FreeRTOS/Sources/queue.c **** 					}
 606:../FreeRTOS/Sources/queue.c **** 				}
 607:../FreeRTOS/Sources/queue.c **** 				#else /* configUSE_QUEUE_SETS */
 608:../FreeRTOS/Sources/queue.c **** 				{
 609:../FreeRTOS/Sources/queue.c **** 					/* If there was a task waiting for data to arrive on the
 610:../FreeRTOS/Sources/queue.c **** 					queue then unblock it now. */
 611:../FreeRTOS/Sources/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 612:../FreeRTOS/Sources/queue.c **** 					{
 613:../FreeRTOS/Sources/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
 614:../FreeRTOS/Sources/queue.c **** 						{
 615:../FreeRTOS/Sources/queue.c **** 							/* The unblocked task has a priority higher than
 616:../FreeRTOS/Sources/queue.c **** 							our own so yield immediately.  Yes it is ok to do
 617:../FreeRTOS/Sources/queue.c **** 							this from within the critical section - the kernel
 618:../FreeRTOS/Sources/queue.c **** 							takes care of that. */
 619:../FreeRTOS/Sources/queue.c **** 							portYIELD_WITHIN_API();
 620:../FreeRTOS/Sources/queue.c **** 						}
 621:../FreeRTOS/Sources/queue.c **** 					}
 622:../FreeRTOS/Sources/queue.c **** 				}
 623:../FreeRTOS/Sources/queue.c **** 				#endif /* configUSE_QUEUE_SETS */
 624:../FreeRTOS/Sources/queue.c **** 
 625:../FreeRTOS/Sources/queue.c **** 				taskEXIT_CRITICAL();
 626:../FreeRTOS/Sources/queue.c **** 
 627:../FreeRTOS/Sources/queue.c **** 				/* Return to the original privilege level before exiting the
 628:../FreeRTOS/Sources/queue.c **** 				function. */
 629:../FreeRTOS/Sources/queue.c **** 				return pdPASS;
 630:../FreeRTOS/Sources/queue.c **** 			}
 631:../FreeRTOS/Sources/queue.c **** 			else
 632:../FreeRTOS/Sources/queue.c **** 			{
 633:../FreeRTOS/Sources/queue.c **** 				if( xTicksToWait == ( portTickType ) 0 )
 634:../FreeRTOS/Sources/queue.c **** 				{
 635:../FreeRTOS/Sources/queue.c **** 					/* The queue was full and no block time is specified (or
 636:../FreeRTOS/Sources/queue.c **** 					the block time has expired) so leave now. */
 637:../FreeRTOS/Sources/queue.c **** 					taskEXIT_CRITICAL();
 638:../FreeRTOS/Sources/queue.c **** 
 639:../FreeRTOS/Sources/queue.c **** 					/* Return to the original privilege level before exiting
 640:../FreeRTOS/Sources/queue.c **** 					the function. */
 641:../FreeRTOS/Sources/queue.c **** 					traceQUEUE_SEND_FAILED( pxQueue );
 642:../FreeRTOS/Sources/queue.c **** 					return errQUEUE_FULL;
 643:../FreeRTOS/Sources/queue.c **** 				}
 644:../FreeRTOS/Sources/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 645:../FreeRTOS/Sources/queue.c **** 				{
 646:../FreeRTOS/Sources/queue.c **** 					/* The queue was full and a block time was specified so
 647:../FreeRTOS/Sources/queue.c **** 					configure the timeout structure. */
 648:../FreeRTOS/Sources/queue.c **** 					vTaskSetTimeOutState( &xTimeOut );
 649:../FreeRTOS/Sources/queue.c **** 					xEntryTimeSet = pdTRUE;
 650:../FreeRTOS/Sources/queue.c **** 				}
 651:../FreeRTOS/Sources/queue.c **** 			}
 652:../FreeRTOS/Sources/queue.c **** 		}
 653:../FreeRTOS/Sources/queue.c **** 		taskEXIT_CRITICAL();
 654:../FreeRTOS/Sources/queue.c **** 
 655:../FreeRTOS/Sources/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
 656:../FreeRTOS/Sources/queue.c **** 		now the critical section has been exited. */
 657:../FreeRTOS/Sources/queue.c **** 
 658:../FreeRTOS/Sources/queue.c **** 		vTaskSuspendAll();
 659:../FreeRTOS/Sources/queue.c **** 		prvLockQueue( pxQueue );
 660:../FreeRTOS/Sources/queue.c **** 
 661:../FreeRTOS/Sources/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
 662:../FreeRTOS/Sources/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 663:../FreeRTOS/Sources/queue.c **** 		{
 664:../FreeRTOS/Sources/queue.c **** 			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 665:../FreeRTOS/Sources/queue.c **** 			{
 666:../FreeRTOS/Sources/queue.c **** 				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
 667:../FreeRTOS/Sources/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 668:../FreeRTOS/Sources/queue.c **** 
 669:../FreeRTOS/Sources/queue.c **** 				/* Unlocking the queue means queue events can effect the
 670:../FreeRTOS/Sources/queue.c **** 				event list.  It is possible	that interrupts occurring now
 671:../FreeRTOS/Sources/queue.c **** 				remove this task from the event	list again - but as the
 672:../FreeRTOS/Sources/queue.c **** 				scheduler is suspended the task will go onto the pending
 673:../FreeRTOS/Sources/queue.c **** 				ready last instead of the actual ready list. */
 674:../FreeRTOS/Sources/queue.c **** 				prvUnlockQueue( pxQueue );
 675:../FreeRTOS/Sources/queue.c **** 
 676:../FreeRTOS/Sources/queue.c **** 				/* Resuming the scheduler will move tasks from the pending
 677:../FreeRTOS/Sources/queue.c **** 				ready list into the ready list - so it is feasible that this
 678:../FreeRTOS/Sources/queue.c **** 				task is already in a ready list before it yields - in which
 679:../FreeRTOS/Sources/queue.c **** 				case the yield will not cause a context switch unless there
 680:../FreeRTOS/Sources/queue.c **** 				is also a higher priority task in the pending ready list. */
 681:../FreeRTOS/Sources/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 682:../FreeRTOS/Sources/queue.c **** 				{
 683:../FreeRTOS/Sources/queue.c **** 					portYIELD_WITHIN_API();
 684:../FreeRTOS/Sources/queue.c **** 				}
 685:../FreeRTOS/Sources/queue.c **** 			}
 686:../FreeRTOS/Sources/queue.c **** 			else
 687:../FreeRTOS/Sources/queue.c **** 			{
 688:../FreeRTOS/Sources/queue.c **** 				/* Try again. */
 689:../FreeRTOS/Sources/queue.c **** 				prvUnlockQueue( pxQueue );
 690:../FreeRTOS/Sources/queue.c **** 				( void ) xTaskResumeAll();
 691:../FreeRTOS/Sources/queue.c **** 			}
 692:../FreeRTOS/Sources/queue.c **** 		}
 693:../FreeRTOS/Sources/queue.c **** 		else
 694:../FreeRTOS/Sources/queue.c **** 		{
 695:../FreeRTOS/Sources/queue.c **** 			/* The timeout has expired. */
 696:../FreeRTOS/Sources/queue.c **** 			prvUnlockQueue( pxQueue );
 697:../FreeRTOS/Sources/queue.c **** 			( void ) xTaskResumeAll();
 698:../FreeRTOS/Sources/queue.c **** 
 699:../FreeRTOS/Sources/queue.c **** 			/* Return to the original privilege level before exiting the
 700:../FreeRTOS/Sources/queue.c **** 			function. */
 701:../FreeRTOS/Sources/queue.c **** 			traceQUEUE_SEND_FAILED( pxQueue );
 702:../FreeRTOS/Sources/queue.c **** 			return errQUEUE_FULL;
 703:../FreeRTOS/Sources/queue.c **** 		}
 704:../FreeRTOS/Sources/queue.c **** 	}
 418              		.loc 1 704 0 is_stmt 1
 419 0046 00BF     		nop
 420              	.L24:
 569:../FreeRTOS/Sources/queue.c **** 		taskENTER_CRITICAL();
 421              		.loc 1 569 0
 422 0048 FFF7FEFF 		bl	vPortEnterCritical
 573:../FreeRTOS/Sources/queue.c **** 			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 423              		.loc 1 573 0
 424 004c BB69     		ldr	r3, [r7, #24]
 425 004e 9A6B     		ldr	r2, [r3, #56]
 426 0050 BB69     		ldr	r3, [r7, #24]
 427 0052 DB6B     		ldr	r3, [r3, #60]
 428 0054 9A42     		cmp	r2, r3
 429 0056 18D2     		bcs	.L26
 576:../FreeRTOS/Sources/queue.c **** 				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 430              		.loc 1 576 0
 431 0058 B869     		ldr	r0, [r7, #24]
 432 005a B968     		ldr	r1, [r7, #8]
 433 005c 3A68     		ldr	r2, [r7, #0]
 434 005e FFF7FEFF 		bl	prvCopyDataToQueue
 611:../FreeRTOS/Sources/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 435              		.loc 1 611 0
 436 0062 BB69     		ldr	r3, [r7, #24]
 437 0064 5B6A     		ldr	r3, [r3, #36]
 438 0066 002B     		cmp	r3, #0
 439 0068 0AD0     		beq	.L27
 613:../FreeRTOS/Sources/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
 440              		.loc 1 613 0
 441 006a BB69     		ldr	r3, [r7, #24]
 442 006c 03F12403 		add	r3, r3, #36
 443 0070 1846     		mov	r0, r3
 444 0072 FFF7FEFF 		bl	xTaskRemoveFromEventList
 445 0076 0346     		mov	r3, r0
 446 0078 012B     		cmp	r3, #1
 447 007a 01D1     		bne	.L27
 619:../FreeRTOS/Sources/queue.c **** 							portYIELD_WITHIN_API();
 448              		.loc 1 619 0
 449 007c FFF7FEFF 		bl	vPortYieldFromISR
 450              	.L27:
 625:../FreeRTOS/Sources/queue.c **** 				taskEXIT_CRITICAL();
 451              		.loc 1 625 0
 452 0080 FFF7FEFF 		bl	vPortExitCritical
 629:../FreeRTOS/Sources/queue.c **** 				return pdPASS;
 453              		.loc 1 629 0
 454 0084 4FF00103 		mov	r3, #1
 455 0088 5DE0     		b	.L36
 456              	.L26:
 633:../FreeRTOS/Sources/queue.c **** 				if( xTicksToWait == ( portTickType ) 0 )
 457              		.loc 1 633 0
 458 008a 7B68     		ldr	r3, [r7, #4]
 459 008c 002B     		cmp	r3, #0
 460 008e 04D1     		bne	.L29
 637:../FreeRTOS/Sources/queue.c **** 					taskEXIT_CRITICAL();
 461              		.loc 1 637 0
 462 0090 FFF7FEFF 		bl	vPortExitCritical
 642:../FreeRTOS/Sources/queue.c **** 					return errQUEUE_FULL;
 463              		.loc 1 642 0
 464 0094 4FF00003 		mov	r3, #0
 465 0098 55E0     		b	.L36
 466              	.L29:
 644:../FreeRTOS/Sources/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 467              		.loc 1 644 0
 468 009a FB69     		ldr	r3, [r7, #28]
 469 009c 002B     		cmp	r3, #0
 470 009e 07D1     		bne	.L30
 648:../FreeRTOS/Sources/queue.c **** 					vTaskSetTimeOutState( &xTimeOut );
 471              		.loc 1 648 0
 472 00a0 07F11003 		add	r3, r7, #16
 473 00a4 1846     		mov	r0, r3
 474 00a6 FFF7FEFF 		bl	vTaskSetTimeOutState
 649:../FreeRTOS/Sources/queue.c **** 					xEntryTimeSet = pdTRUE;
 475              		.loc 1 649 0
 476 00aa 4FF00103 		mov	r3, #1
 477 00ae FB61     		str	r3, [r7, #28]
 478              	.L30:
 653:../FreeRTOS/Sources/queue.c **** 		taskEXIT_CRITICAL();
 479              		.loc 1 653 0
 480 00b0 FFF7FEFF 		bl	vPortExitCritical
 658:../FreeRTOS/Sources/queue.c **** 		vTaskSuspendAll();
 481              		.loc 1 658 0
 482 00b4 FFF7FEFF 		bl	vTaskSuspendAll
 659:../FreeRTOS/Sources/queue.c **** 		prvLockQueue( pxQueue );
 483              		.loc 1 659 0
 484 00b8 FFF7FEFF 		bl	vPortEnterCritical
 485 00bc BB69     		ldr	r3, [r7, #24]
 486 00be 5B6C     		ldr	r3, [r3, #68]
 487 00c0 B3F1FF3F 		cmp	r3, #-1
 488 00c4 03D1     		bne	.L31
 659:../FreeRTOS/Sources/queue.c **** 		prvLockQueue( pxQueue );
 489              		.loc 1 659 0 is_stmt 0 discriminator 1
 490 00c6 BB69     		ldr	r3, [r7, #24]
 491 00c8 4FF00002 		mov	r2, #0
 492 00cc 5A64     		str	r2, [r3, #68]
 493              	.L31:
 659:../FreeRTOS/Sources/queue.c **** 		prvLockQueue( pxQueue );
 494              		.loc 1 659 0 discriminator 2
 495 00ce BB69     		ldr	r3, [r7, #24]
 496 00d0 9B6C     		ldr	r3, [r3, #72]
 497 00d2 B3F1FF3F 		cmp	r3, #-1
 498 00d6 03D1     		bne	.L32
 659:../FreeRTOS/Sources/queue.c **** 		prvLockQueue( pxQueue );
 499              		.loc 1 659 0 discriminator 3
 500 00d8 BB69     		ldr	r3, [r7, #24]
 501 00da 4FF00002 		mov	r2, #0
 502 00de 9A64     		str	r2, [r3, #72]
 503              	.L32:
 659:../FreeRTOS/Sources/queue.c **** 		prvLockQueue( pxQueue );
 504              		.loc 1 659 0 discriminator 4
 505 00e0 FFF7FEFF 		bl	vPortExitCritical
 662:../FreeRTOS/Sources/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 506              		.loc 1 662 0 is_stmt 1 discriminator 4
 507 00e4 07F11002 		add	r2, r7, #16
 508 00e8 07F10403 		add	r3, r7, #4
 509 00ec 1046     		mov	r0, r2
 510 00ee 1946     		mov	r1, r3
 511 00f0 FFF7FEFF 		bl	xTaskCheckForTimeOut
 512 00f4 0346     		mov	r3, r0
 513 00f6 002B     		cmp	r3, #0
 514 00f8 1ED1     		bne	.L33
 664:../FreeRTOS/Sources/queue.c **** 			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 515              		.loc 1 664 0
 516 00fa B869     		ldr	r0, [r7, #24]
 517 00fc FFF7FEFF 		bl	prvIsQueueFull
 518 0100 0346     		mov	r3, r0
 519 0102 002B     		cmp	r3, #0
 520 0104 12D0     		beq	.L34
 667:../FreeRTOS/Sources/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 521              		.loc 1 667 0
 522 0106 BB69     		ldr	r3, [r7, #24]
 523 0108 03F11002 		add	r2, r3, #16
 524 010c 7B68     		ldr	r3, [r7, #4]
 525 010e 1046     		mov	r0, r2
 526 0110 1946     		mov	r1, r3
 527 0112 FFF7FEFF 		bl	vTaskPlaceOnEventList
 674:../FreeRTOS/Sources/queue.c **** 				prvUnlockQueue( pxQueue );
 528              		.loc 1 674 0
 529 0116 B869     		ldr	r0, [r7, #24]
 530 0118 FFF7FEFF 		bl	prvUnlockQueue
 681:../FreeRTOS/Sources/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 531              		.loc 1 681 0
 532 011c FFF7FEFF 		bl	xTaskResumeAll
 533 0120 0346     		mov	r3, r0
 534 0122 002B     		cmp	r3, #0
 535 0124 8FD1     		bne	.L37
 683:../FreeRTOS/Sources/queue.c **** 					portYIELD_WITHIN_API();
 536              		.loc 1 683 0
 537 0126 FFF7FEFF 		bl	vPortYieldFromISR
 538              		.loc 1 704 0
 539 012a 8CE7     		b	.L37
 540              	.L34:
 689:../FreeRTOS/Sources/queue.c **** 				prvUnlockQueue( pxQueue );
 541              		.loc 1 689 0
 542 012c B869     		ldr	r0, [r7, #24]
 543 012e FFF7FEFF 		bl	prvUnlockQueue
 690:../FreeRTOS/Sources/queue.c **** 				( void ) xTaskResumeAll();
 544              		.loc 1 690 0
 545 0132 FFF7FEFF 		bl	xTaskResumeAll
 546              		.loc 1 704 0
 547 0136 86E7     		b	.L37
 548              	.L33:
 696:../FreeRTOS/Sources/queue.c **** 			prvUnlockQueue( pxQueue );
 549              		.loc 1 696 0
 550 0138 B869     		ldr	r0, [r7, #24]
 551 013a FFF7FEFF 		bl	prvUnlockQueue
 697:../FreeRTOS/Sources/queue.c **** 			( void ) xTaskResumeAll();
 552              		.loc 1 697 0
 553 013e FFF7FEFF 		bl	xTaskResumeAll
 702:../FreeRTOS/Sources/queue.c **** 			return errQUEUE_FULL;
 554              		.loc 1 702 0
 555 0142 4FF00003 		mov	r3, #0
 556              	.L36:
 705:../FreeRTOS/Sources/queue.c **** }
 557              		.loc 1 705 0
 558 0146 1846     		mov	r0, r3
 559 0148 07F12007 		add	r7, r7, #32
 560 014c BD46     		mov	sp, r7
 561 014e 80BD     		pop	{r7, pc}
 562              		.cfi_endproc
 563              	.LFE3:
 565              		.section	.text.xQueueGenericSendFromISR,"ax",%progbits
 566              		.align	2
 567              		.global	xQueueGenericSendFromISR
 568              		.thumb
 569              		.thumb_func
 571              	xQueueGenericSendFromISR:
 572              	.LFB4:
 706:../FreeRTOS/Sources/queue.c **** /*-----------------------------------------------------------*/
 707:../FreeRTOS/Sources/queue.c **** 
 708:../FreeRTOS/Sources/queue.c **** #if ( configUSE_ALTERNATIVE_API == 1 )
 709:../FreeRTOS/Sources/queue.c **** 
 710:../FreeRTOS/Sources/queue.c **** 	signed portBASE_TYPE xQueueAltGenericSend( xQueueHandle xQueue, const void * const pvItemToQueue, 
 711:../FreeRTOS/Sources/queue.c **** 	{
 712:../FreeRTOS/Sources/queue.c **** 	signed portBASE_TYPE xEntryTimeSet = pdFALSE;
 713:../FreeRTOS/Sources/queue.c **** 	xTimeOutType xTimeOut;
 714:../FreeRTOS/Sources/queue.c **** 	xQUEUE *pxQueue;
 715:../FreeRTOS/Sources/queue.c **** 
 716:../FreeRTOS/Sources/queue.c **** 		pxQueue = ( xQUEUE * ) xQueue;
 717:../FreeRTOS/Sources/queue.c **** 		configASSERT( pxQueue );
 718:../FreeRTOS/Sources/queue.c **** 		configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE )
 719:../FreeRTOS/Sources/queue.c **** 
 720:../FreeRTOS/Sources/queue.c **** 		for( ;; )
 721:../FreeRTOS/Sources/queue.c **** 		{
 722:../FreeRTOS/Sources/queue.c **** 			taskENTER_CRITICAL();
 723:../FreeRTOS/Sources/queue.c **** 			{
 724:../FreeRTOS/Sources/queue.c **** 				/* Is there room on the queue now?  To be running we must be
 725:../FreeRTOS/Sources/queue.c **** 				the highest priority task wanting to access the queue. */
 726:../FreeRTOS/Sources/queue.c **** 				if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 727:../FreeRTOS/Sources/queue.c **** 				{
 728:../FreeRTOS/Sources/queue.c **** 					traceQUEUE_SEND( pxQueue );
 729:../FreeRTOS/Sources/queue.c **** 					prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 730:../FreeRTOS/Sources/queue.c **** 
 731:../FreeRTOS/Sources/queue.c **** 					/* If there was a task waiting for data to arrive on the
 732:../FreeRTOS/Sources/queue.c **** 					queue then unblock it now. */
 733:../FreeRTOS/Sources/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 734:../FreeRTOS/Sources/queue.c **** 					{
 735:../FreeRTOS/Sources/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
 736:../FreeRTOS/Sources/queue.c **** 						{
 737:../FreeRTOS/Sources/queue.c **** 							/* The unblocked task has a priority higher than
 738:../FreeRTOS/Sources/queue.c **** 							our own so yield immediately. */
 739:../FreeRTOS/Sources/queue.c **** 							portYIELD_WITHIN_API();
 740:../FreeRTOS/Sources/queue.c **** 						}
 741:../FreeRTOS/Sources/queue.c **** 					}
 742:../FreeRTOS/Sources/queue.c **** 
 743:../FreeRTOS/Sources/queue.c **** 					taskEXIT_CRITICAL();
 744:../FreeRTOS/Sources/queue.c **** 					return pdPASS;
 745:../FreeRTOS/Sources/queue.c **** 				}
 746:../FreeRTOS/Sources/queue.c **** 				else
 747:../FreeRTOS/Sources/queue.c **** 				{
 748:../FreeRTOS/Sources/queue.c **** 					if( xTicksToWait == ( portTickType ) 0 )
 749:../FreeRTOS/Sources/queue.c **** 					{
 750:../FreeRTOS/Sources/queue.c **** 						taskEXIT_CRITICAL();
 751:../FreeRTOS/Sources/queue.c **** 						return errQUEUE_FULL;
 752:../FreeRTOS/Sources/queue.c **** 					}
 753:../FreeRTOS/Sources/queue.c **** 					else if( xEntryTimeSet == pdFALSE )
 754:../FreeRTOS/Sources/queue.c **** 					{
 755:../FreeRTOS/Sources/queue.c **** 						vTaskSetTimeOutState( &xTimeOut );
 756:../FreeRTOS/Sources/queue.c **** 						xEntryTimeSet = pdTRUE;
 757:../FreeRTOS/Sources/queue.c **** 					}
 758:../FreeRTOS/Sources/queue.c **** 				}
 759:../FreeRTOS/Sources/queue.c **** 			}
 760:../FreeRTOS/Sources/queue.c **** 			taskEXIT_CRITICAL();
 761:../FreeRTOS/Sources/queue.c **** 
 762:../FreeRTOS/Sources/queue.c **** 			taskENTER_CRITICAL();
 763:../FreeRTOS/Sources/queue.c **** 			{
 764:../FreeRTOS/Sources/queue.c **** 				if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 765:../FreeRTOS/Sources/queue.c **** 				{
 766:../FreeRTOS/Sources/queue.c **** 					if( prvIsQueueFull( pxQueue ) != pdFALSE )
 767:../FreeRTOS/Sources/queue.c **** 					{
 768:../FreeRTOS/Sources/queue.c **** 						traceBLOCKING_ON_QUEUE_SEND( pxQueue );
 769:../FreeRTOS/Sources/queue.c **** 						vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 770:../FreeRTOS/Sources/queue.c **** 						portYIELD_WITHIN_API();
 771:../FreeRTOS/Sources/queue.c **** 					}
 772:../FreeRTOS/Sources/queue.c **** 				}
 773:../FreeRTOS/Sources/queue.c **** 				else
 774:../FreeRTOS/Sources/queue.c **** 				{
 775:../FreeRTOS/Sources/queue.c **** 					taskEXIT_CRITICAL();
 776:../FreeRTOS/Sources/queue.c **** 					traceQUEUE_SEND_FAILED( pxQueue );
 777:../FreeRTOS/Sources/queue.c **** 					return errQUEUE_FULL;
 778:../FreeRTOS/Sources/queue.c **** 				}
 779:../FreeRTOS/Sources/queue.c **** 			}
 780:../FreeRTOS/Sources/queue.c **** 			taskEXIT_CRITICAL();
 781:../FreeRTOS/Sources/queue.c **** 		}
 782:../FreeRTOS/Sources/queue.c **** 	}
 783:../FreeRTOS/Sources/queue.c **** 
 784:../FreeRTOS/Sources/queue.c **** #endif /* configUSE_ALTERNATIVE_API */
 785:../FreeRTOS/Sources/queue.c **** /*-----------------------------------------------------------*/
 786:../FreeRTOS/Sources/queue.c **** 
 787:../FreeRTOS/Sources/queue.c **** #if ( configUSE_ALTERNATIVE_API == 1 )
 788:../FreeRTOS/Sources/queue.c **** 
 789:../FreeRTOS/Sources/queue.c **** 	signed portBASE_TYPE xQueueAltGenericReceive( xQueueHandle xQueue, void * const pvBuffer, portTick
 790:../FreeRTOS/Sources/queue.c **** 	{
 791:../FreeRTOS/Sources/queue.c **** 	signed portBASE_TYPE xEntryTimeSet = pdFALSE;
 792:../FreeRTOS/Sources/queue.c **** 	xTimeOutType xTimeOut;
 793:../FreeRTOS/Sources/queue.c **** 	signed char *pcOriginalReadPosition;
 794:../FreeRTOS/Sources/queue.c **** 	xQUEUE *pxQueue;
 795:../FreeRTOS/Sources/queue.c **** 
 796:../FreeRTOS/Sources/queue.c **** 		pxQueue = ( xQUEUE * ) xQueue;
 797:../FreeRTOS/Sources/queue.c **** 		configASSERT( pxQueue );
 798:../FreeRTOS/Sources/queue.c **** 		configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U )
 799:../FreeRTOS/Sources/queue.c **** 
 800:../FreeRTOS/Sources/queue.c **** 		for( ;; )
 801:../FreeRTOS/Sources/queue.c **** 		{
 802:../FreeRTOS/Sources/queue.c **** 			taskENTER_CRITICAL();
 803:../FreeRTOS/Sources/queue.c **** 			{
 804:../FreeRTOS/Sources/queue.c **** 				if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 805:../FreeRTOS/Sources/queue.c **** 				{
 806:../FreeRTOS/Sources/queue.c **** 					/* Remember our read position in case we are just peeking. */
 807:../FreeRTOS/Sources/queue.c **** 					pcOriginalReadPosition = pxQueue->pcReadFrom;
 808:../FreeRTOS/Sources/queue.c **** 
 809:../FreeRTOS/Sources/queue.c **** 					prvCopyDataFromQueue( pxQueue, pvBuffer );
 810:../FreeRTOS/Sources/queue.c **** 
 811:../FreeRTOS/Sources/queue.c **** 					if( xJustPeeking == pdFALSE )
 812:../FreeRTOS/Sources/queue.c **** 					{
 813:../FreeRTOS/Sources/queue.c **** 						traceQUEUE_RECEIVE( pxQueue );
 814:../FreeRTOS/Sources/queue.c **** 
 815:../FreeRTOS/Sources/queue.c **** 						/* We are actually removing data. */
 816:../FreeRTOS/Sources/queue.c **** 						--( pxQueue->uxMessagesWaiting );
 817:../FreeRTOS/Sources/queue.c **** 
 818:../FreeRTOS/Sources/queue.c **** 						#if ( configUSE_MUTEXES == 1 )
 819:../FreeRTOS/Sources/queue.c **** 						{
 820:../FreeRTOS/Sources/queue.c **** 							if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 821:../FreeRTOS/Sources/queue.c **** 							{
 822:../FreeRTOS/Sources/queue.c **** 								/* Record the information required to implement
 823:../FreeRTOS/Sources/queue.c **** 								priority inheritance should it become necessary. */
 824:../FreeRTOS/Sources/queue.c **** 								pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
 825:../FreeRTOS/Sources/queue.c **** 							}
 826:../FreeRTOS/Sources/queue.c **** 						}
 827:../FreeRTOS/Sources/queue.c **** 						#endif
 828:../FreeRTOS/Sources/queue.c **** 
 829:../FreeRTOS/Sources/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 830:../FreeRTOS/Sources/queue.c **** 						{
 831:../FreeRTOS/Sources/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 832:../FreeRTOS/Sources/queue.c **** 							{
 833:../FreeRTOS/Sources/queue.c **** 								portYIELD_WITHIN_API();
 834:../FreeRTOS/Sources/queue.c **** 							}
 835:../FreeRTOS/Sources/queue.c **** 						}
 836:../FreeRTOS/Sources/queue.c **** 					}
 837:../FreeRTOS/Sources/queue.c **** 					else
 838:../FreeRTOS/Sources/queue.c **** 					{
 839:../FreeRTOS/Sources/queue.c **** 						traceQUEUE_PEEK( pxQueue );
 840:../FreeRTOS/Sources/queue.c **** 
 841:../FreeRTOS/Sources/queue.c **** 						/* We are not removing the data, so reset our read
 842:../FreeRTOS/Sources/queue.c **** 						pointer. */
 843:../FreeRTOS/Sources/queue.c **** 						pxQueue->pcReadFrom = pcOriginalReadPosition;
 844:../FreeRTOS/Sources/queue.c **** 
 845:../FreeRTOS/Sources/queue.c **** 						/* The data is being left in the queue, so see if there are
 846:../FreeRTOS/Sources/queue.c **** 						any other tasks waiting for the data. */
 847:../FreeRTOS/Sources/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 848:../FreeRTOS/Sources/queue.c **** 						{
 849:../FreeRTOS/Sources/queue.c **** 							/* Tasks that are removed from the event list will get added to
 850:../FreeRTOS/Sources/queue.c **** 							the pending ready list as the scheduler is still suspended. */
 851:../FreeRTOS/Sources/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 852:../FreeRTOS/Sources/queue.c **** 							{
 853:../FreeRTOS/Sources/queue.c **** 								/* The task waiting has a higher priority than this task. */
 854:../FreeRTOS/Sources/queue.c **** 								portYIELD_WITHIN_API();
 855:../FreeRTOS/Sources/queue.c **** 							}
 856:../FreeRTOS/Sources/queue.c **** 						}
 857:../FreeRTOS/Sources/queue.c **** 
 858:../FreeRTOS/Sources/queue.c **** 					}
 859:../FreeRTOS/Sources/queue.c **** 
 860:../FreeRTOS/Sources/queue.c **** 					taskEXIT_CRITICAL();
 861:../FreeRTOS/Sources/queue.c **** 					return pdPASS;
 862:../FreeRTOS/Sources/queue.c **** 				}
 863:../FreeRTOS/Sources/queue.c **** 				else
 864:../FreeRTOS/Sources/queue.c **** 				{
 865:../FreeRTOS/Sources/queue.c **** 					if( xTicksToWait == ( portTickType ) 0 )
 866:../FreeRTOS/Sources/queue.c **** 					{
 867:../FreeRTOS/Sources/queue.c **** 						taskEXIT_CRITICAL();
 868:../FreeRTOS/Sources/queue.c **** 						traceQUEUE_RECEIVE_FAILED( pxQueue );
 869:../FreeRTOS/Sources/queue.c **** 						return errQUEUE_EMPTY;
 870:../FreeRTOS/Sources/queue.c **** 					}
 871:../FreeRTOS/Sources/queue.c **** 					else if( xEntryTimeSet == pdFALSE )
 872:../FreeRTOS/Sources/queue.c **** 					{
 873:../FreeRTOS/Sources/queue.c **** 						vTaskSetTimeOutState( &xTimeOut );
 874:../FreeRTOS/Sources/queue.c **** 						xEntryTimeSet = pdTRUE;
 875:../FreeRTOS/Sources/queue.c **** 					}
 876:../FreeRTOS/Sources/queue.c **** 				}
 877:../FreeRTOS/Sources/queue.c **** 			}
 878:../FreeRTOS/Sources/queue.c **** 			taskEXIT_CRITICAL();
 879:../FreeRTOS/Sources/queue.c **** 
 880:../FreeRTOS/Sources/queue.c **** 			taskENTER_CRITICAL();
 881:../FreeRTOS/Sources/queue.c **** 			{
 882:../FreeRTOS/Sources/queue.c **** 				if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 883:../FreeRTOS/Sources/queue.c **** 				{
 884:../FreeRTOS/Sources/queue.c **** 					if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 885:../FreeRTOS/Sources/queue.c **** 					{
 886:../FreeRTOS/Sources/queue.c **** 						traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
 887:../FreeRTOS/Sources/queue.c **** 
 888:../FreeRTOS/Sources/queue.c **** 						#if ( configUSE_MUTEXES == 1 )
 889:../FreeRTOS/Sources/queue.c **** 						{
 890:../FreeRTOS/Sources/queue.c **** 							if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 891:../FreeRTOS/Sources/queue.c **** 							{
 892:../FreeRTOS/Sources/queue.c **** 								portENTER_CRITICAL();
 893:../FreeRTOS/Sources/queue.c **** 								{
 894:../FreeRTOS/Sources/queue.c **** 									vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 895:../FreeRTOS/Sources/queue.c **** 								}
 896:../FreeRTOS/Sources/queue.c **** 								portEXIT_CRITICAL();
 897:../FreeRTOS/Sources/queue.c **** 							}
 898:../FreeRTOS/Sources/queue.c **** 						}
 899:../FreeRTOS/Sources/queue.c **** 						#endif
 900:../FreeRTOS/Sources/queue.c **** 
 901:../FreeRTOS/Sources/queue.c **** 						vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 902:../FreeRTOS/Sources/queue.c **** 						portYIELD_WITHIN_API();
 903:../FreeRTOS/Sources/queue.c **** 					}
 904:../FreeRTOS/Sources/queue.c **** 				}
 905:../FreeRTOS/Sources/queue.c **** 				else
 906:../FreeRTOS/Sources/queue.c **** 				{
 907:../FreeRTOS/Sources/queue.c **** 					taskEXIT_CRITICAL();
 908:../FreeRTOS/Sources/queue.c **** 					traceQUEUE_RECEIVE_FAILED( pxQueue );
 909:../FreeRTOS/Sources/queue.c **** 					return errQUEUE_EMPTY;
 910:../FreeRTOS/Sources/queue.c **** 				}
 911:../FreeRTOS/Sources/queue.c **** 			}
 912:../FreeRTOS/Sources/queue.c **** 			taskEXIT_CRITICAL();
 913:../FreeRTOS/Sources/queue.c **** 		}
 914:../FreeRTOS/Sources/queue.c **** 	}
 915:../FreeRTOS/Sources/queue.c **** 
 916:../FreeRTOS/Sources/queue.c **** 
 917:../FreeRTOS/Sources/queue.c **** #endif /* configUSE_ALTERNATIVE_API */
 918:../FreeRTOS/Sources/queue.c **** /*-----------------------------------------------------------*/
 919:../FreeRTOS/Sources/queue.c **** 
 920:../FreeRTOS/Sources/queue.c **** signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle xQueue, const void * const pvItemToQueu
 921:../FreeRTOS/Sources/queue.c **** {
 573              		.loc 1 921 0
 574              		.cfi_startproc
 575              		@ args = 0, pretend = 0, frame = 32
 576              		@ frame_needed = 1, uses_anonymous_args = 0
 577 0000 80B5     		push	{r7, lr}
 578              	.LCFI12:
 579              		.cfi_def_cfa_offset 8
 580              		.cfi_offset 7, -8
 581              		.cfi_offset 14, -4
 582 0002 88B0     		sub	sp, sp, #32
 583              	.LCFI13:
 584              		.cfi_def_cfa_offset 40
 585 0004 00AF     		add	r7, sp, #0
 586              	.LCFI14:
 587              		.cfi_def_cfa_register 7
 588 0006 F860     		str	r0, [r7, #12]
 589 0008 B960     		str	r1, [r7, #8]
 590 000a 7A60     		str	r2, [r7, #4]
 591 000c 3B60     		str	r3, [r7, #0]
 922:../FreeRTOS/Sources/queue.c **** signed portBASE_TYPE xReturn;
 923:../FreeRTOS/Sources/queue.c **** unsigned portBASE_TYPE uxSavedInterruptStatus;
 924:../FreeRTOS/Sources/queue.c **** xQUEUE *pxQueue;
 925:../FreeRTOS/Sources/queue.c **** 
 926:../FreeRTOS/Sources/queue.c **** 	pxQueue = ( xQUEUE * ) xQueue;
 592              		.loc 1 926 0
 593 000e FB68     		ldr	r3, [r7, #12]
 594 0010 BB61     		str	r3, [r7, #24]
 927:../FreeRTOS/Sources/queue.c **** 	configASSERT( pxQueue );
 595              		.loc 1 927 0
 596 0012 BB69     		ldr	r3, [r7, #24]
 597 0014 002B     		cmp	r3, #0
 598 0016 02D1     		bne	.L39
 599              		.loc 1 927 0 is_stmt 0 discriminator 1
 600 0018 FFF7FEFF 		bl	ulPortSetInterruptMask
 601              	.L40:
 602              		.loc 1 927 0 discriminator 2
 603 001c FEE7     		b	.L40
 604              	.L39:
 928:../FreeRTOS/Sources/queue.c **** 	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 
 605              		.loc 1 928 0 is_stmt 1
 606 001e BB68     		ldr	r3, [r7, #8]
 607 0020 002B     		cmp	r3, #0
 608 0022 03D1     		bne	.L41
 609              		.loc 1 928 0 is_stmt 0 discriminator 2
 610 0024 BB69     		ldr	r3, [r7, #24]
 611 0026 1B6C     		ldr	r3, [r3, #64]
 612 0028 002B     		cmp	r3, #0
 613 002a 02D1     		bne	.L42
 614              	.L41:
 615              		.loc 1 928 0 discriminator 1
 616 002c 4FF00103 		mov	r3, #1
 617 0030 01E0     		b	.L43
 618              	.L42:
 619              		.loc 1 928 0 discriminator 3
 620 0032 4FF00003 		mov	r3, #0
 621              	.L43:
 622              		.loc 1 928 0 discriminator 4
 623 0036 002B     		cmp	r3, #0
 624 0038 02D1     		bne	.L44
 625              		.loc 1 928 0 discriminator 5
 626 003a FFF7FEFF 		bl	ulPortSetInterruptMask
 627              	.L45:
 628              		.loc 1 928 0 discriminator 6
 629 003e FEE7     		b	.L45
 630              	.L44:
 929:../FreeRTOS/Sources/queue.c **** 
 930:../FreeRTOS/Sources/queue.c **** 	/* Similar to xQueueGenericSend, except we don't block if there is no room
 931:../FreeRTOS/Sources/queue.c **** 	in the queue.  Also we don't directly wake a task that was blocked on a
 932:../FreeRTOS/Sources/queue.c **** 	queue read, instead we return a flag to say whether a context switch is
 933:../FreeRTOS/Sources/queue.c **** 	required or not (i.e. has a task with a higher priority than us been woken
 934:../FreeRTOS/Sources/queue.c **** 	by this	post). */
 935:../FreeRTOS/Sources/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 631              		.loc 1 935 0 is_stmt 1
 632 0040 FFF7FEFF 		bl	ulPortSetInterruptMask
 633 0044 7861     		str	r0, [r7, #20]
 936:../FreeRTOS/Sources/queue.c **** 	{
 937:../FreeRTOS/Sources/queue.c **** 		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 634              		.loc 1 937 0
 635 0046 BB69     		ldr	r3, [r7, #24]
 636 0048 9A6B     		ldr	r2, [r3, #56]
 637 004a BB69     		ldr	r3, [r7, #24]
 638 004c DB6B     		ldr	r3, [r3, #60]
 639 004e 9A42     		cmp	r2, r3
 640 0050 28D2     		bcs	.L46
 938:../FreeRTOS/Sources/queue.c **** 		{
 939:../FreeRTOS/Sources/queue.c **** 			traceQUEUE_SEND_FROM_ISR( pxQueue );
 940:../FreeRTOS/Sources/queue.c **** 
 941:../FreeRTOS/Sources/queue.c **** 			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 641              		.loc 1 941 0
 642 0052 B869     		ldr	r0, [r7, #24]
 643 0054 B968     		ldr	r1, [r7, #8]
 644 0056 3A68     		ldr	r2, [r7, #0]
 645 0058 FFF7FEFF 		bl	prvCopyDataToQueue
 942:../FreeRTOS/Sources/queue.c **** 
 943:../FreeRTOS/Sources/queue.c **** 			/* If the queue is locked we do not alter the event list.  This will
 944:../FreeRTOS/Sources/queue.c **** 			be done when the queue is unlocked later. */
 945:../FreeRTOS/Sources/queue.c **** 			if( pxQueue->xTxLock == queueUNLOCKED )
 646              		.loc 1 945 0
 647 005c BB69     		ldr	r3, [r7, #24]
 648 005e 9B6C     		ldr	r3, [r3, #72]
 649 0060 B3F1FF3F 		cmp	r3, #-1
 650 0064 14D1     		bne	.L47
 946:../FreeRTOS/Sources/queue.c **** 			{
 947:../FreeRTOS/Sources/queue.c **** 				#if ( configUSE_QUEUE_SETS == 1 )
 948:../FreeRTOS/Sources/queue.c **** 				{
 949:../FreeRTOS/Sources/queue.c **** 					if( pxQueue->pxQueueSetContainer != NULL )
 950:../FreeRTOS/Sources/queue.c **** 					{
 951:../FreeRTOS/Sources/queue.c **** 						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) == pdTRUE )
 952:../FreeRTOS/Sources/queue.c **** 						{
 953:../FreeRTOS/Sources/queue.c **** 							/* The queue is a member of a queue set, and posting
 954:../FreeRTOS/Sources/queue.c **** 							to the queue set caused a higher priority task to
 955:../FreeRTOS/Sources/queue.c **** 							unblock.  A context switch is required. */
 956:../FreeRTOS/Sources/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
 957:../FreeRTOS/Sources/queue.c **** 							{
 958:../FreeRTOS/Sources/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
 959:../FreeRTOS/Sources/queue.c **** 							}
 960:../FreeRTOS/Sources/queue.c **** 						}
 961:../FreeRTOS/Sources/queue.c **** 					}
 962:../FreeRTOS/Sources/queue.c **** 					else
 963:../FreeRTOS/Sources/queue.c **** 					{
 964:../FreeRTOS/Sources/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 965:../FreeRTOS/Sources/queue.c **** 						{
 966:../FreeRTOS/Sources/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 967:../FreeRTOS/Sources/queue.c **** 							{
 968:../FreeRTOS/Sources/queue.c **** 								/* The task waiting has a higher priority so record that a
 969:../FreeRTOS/Sources/queue.c **** 								context	switch is required. */
 970:../FreeRTOS/Sources/queue.c **** 								if( pxHigherPriorityTaskWoken != NULL )
 971:../FreeRTOS/Sources/queue.c **** 								{
 972:../FreeRTOS/Sources/queue.c **** 									*pxHigherPriorityTaskWoken = pdTRUE;
 973:../FreeRTOS/Sources/queue.c **** 								}
 974:../FreeRTOS/Sources/queue.c **** 							}
 975:../FreeRTOS/Sources/queue.c **** 						}
 976:../FreeRTOS/Sources/queue.c **** 					}
 977:../FreeRTOS/Sources/queue.c **** 				}
 978:../FreeRTOS/Sources/queue.c **** 				#else /* configUSE_QUEUE_SETS */
 979:../FreeRTOS/Sources/queue.c **** 				{
 980:../FreeRTOS/Sources/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 651              		.loc 1 980 0
 652 0066 BB69     		ldr	r3, [r7, #24]
 653 0068 5B6A     		ldr	r3, [r3, #36]
 654 006a 002B     		cmp	r3, #0
 655 006c 16D0     		beq	.L48
 981:../FreeRTOS/Sources/queue.c **** 					{
 982:../FreeRTOS/Sources/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 656              		.loc 1 982 0
 657 006e BB69     		ldr	r3, [r7, #24]
 658 0070 03F12403 		add	r3, r3, #36
 659 0074 1846     		mov	r0, r3
 660 0076 FFF7FEFF 		bl	xTaskRemoveFromEventList
 661 007a 0346     		mov	r3, r0
 662 007c 002B     		cmp	r3, #0
 663 007e 0DD0     		beq	.L48
 983:../FreeRTOS/Sources/queue.c **** 						{
 984:../FreeRTOS/Sources/queue.c **** 							/* The task waiting has a higher priority so record that a
 985:../FreeRTOS/Sources/queue.c **** 							context	switch is required. */
 986:../FreeRTOS/Sources/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
 664              		.loc 1 986 0
 665 0080 7B68     		ldr	r3, [r7, #4]
 666 0082 002B     		cmp	r3, #0
 667 0084 0AD0     		beq	.L48
 987:../FreeRTOS/Sources/queue.c **** 							{
 988:../FreeRTOS/Sources/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
 668              		.loc 1 988 0
 669 0086 7B68     		ldr	r3, [r7, #4]
 670 0088 4FF00102 		mov	r2, #1
 671 008c 1A60     		str	r2, [r3, #0]
 672 008e 05E0     		b	.L48
 673              	.L47:
 989:../FreeRTOS/Sources/queue.c **** 							}
 990:../FreeRTOS/Sources/queue.c **** 						}
 991:../FreeRTOS/Sources/queue.c **** 					}
 992:../FreeRTOS/Sources/queue.c **** 				}
 993:../FreeRTOS/Sources/queue.c **** 				#endif /* configUSE_QUEUE_SETS */
 994:../FreeRTOS/Sources/queue.c **** 			}
 995:../FreeRTOS/Sources/queue.c **** 			else
 996:../FreeRTOS/Sources/queue.c **** 			{
 997:../FreeRTOS/Sources/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
 998:../FreeRTOS/Sources/queue.c **** 				knows that data was posted while it was locked. */
 999:../FreeRTOS/Sources/queue.c **** 				++( pxQueue->xTxLock );
 674              		.loc 1 999 0
 675 0090 BB69     		ldr	r3, [r7, #24]
 676 0092 9B6C     		ldr	r3, [r3, #72]
 677 0094 03F10102 		add	r2, r3, #1
 678 0098 BB69     		ldr	r3, [r7, #24]
 679 009a 9A64     		str	r2, [r3, #72]
 680              	.L48:
1000:../FreeRTOS/Sources/queue.c **** 			}
1001:../FreeRTOS/Sources/queue.c **** 
1002:../FreeRTOS/Sources/queue.c **** 			xReturn = pdPASS;
 681              		.loc 1 1002 0
 682 009c 4FF00103 		mov	r3, #1
 683 00a0 FB61     		str	r3, [r7, #28]
 684 00a2 02E0     		b	.L49
 685              	.L46:
1003:../FreeRTOS/Sources/queue.c **** 		}
1004:../FreeRTOS/Sources/queue.c **** 		else
1005:../FreeRTOS/Sources/queue.c **** 		{
1006:../FreeRTOS/Sources/queue.c **** 			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
1007:../FreeRTOS/Sources/queue.c **** 			xReturn = errQUEUE_FULL;
 686              		.loc 1 1007 0
 687 00a4 4FF00003 		mov	r3, #0
 688 00a8 FB61     		str	r3, [r7, #28]
 689              	.L49:
1008:../FreeRTOS/Sources/queue.c **** 		}
1009:../FreeRTOS/Sources/queue.c **** 	}
1010:../FreeRTOS/Sources/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 690              		.loc 1 1010 0
 691 00aa 7869     		ldr	r0, [r7, #20]
 692 00ac FFF7FEFF 		bl	vPortClearInterruptMask
1011:../FreeRTOS/Sources/queue.c **** 
1012:../FreeRTOS/Sources/queue.c **** 	return xReturn;
 693              		.loc 1 1012 0
 694 00b0 FB69     		ldr	r3, [r7, #28]
1013:../FreeRTOS/Sources/queue.c **** }
 695              		.loc 1 1013 0
 696 00b2 1846     		mov	r0, r3
 697 00b4 07F12007 		add	r7, r7, #32
 698 00b8 BD46     		mov	sp, r7
 699 00ba 80BD     		pop	{r7, pc}
 700              		.cfi_endproc
 701              	.LFE4:
 703              		.section	.text.xQueueGenericReceive,"ax",%progbits
 704              		.align	2
 705              		.global	xQueueGenericReceive
 706              		.thumb
 707              		.thumb_func
 709              	xQueueGenericReceive:
 710              	.LFB5:
1014:../FreeRTOS/Sources/queue.c **** /*-----------------------------------------------------------*/
1015:../FreeRTOS/Sources/queue.c **** 
1016:../FreeRTOS/Sources/queue.c **** signed portBASE_TYPE xQueueGenericReceive( xQueueHandle xQueue, void * const pvBuffer, portTickType
1017:../FreeRTOS/Sources/queue.c **** {
 711              		.loc 1 1017 0
 712              		.cfi_startproc
 713              		@ args = 0, pretend = 0, frame = 40
 714              		@ frame_needed = 1, uses_anonymous_args = 0
 715 0000 80B5     		push	{r7, lr}
 716              	.LCFI15:
 717              		.cfi_def_cfa_offset 8
 718              		.cfi_offset 7, -8
 719              		.cfi_offset 14, -4
 720 0002 8AB0     		sub	sp, sp, #40
 721              	.LCFI16:
 722              		.cfi_def_cfa_offset 48
 723 0004 00AF     		add	r7, sp, #0
 724              	.LCFI17:
 725              		.cfi_def_cfa_register 7
 726 0006 F860     		str	r0, [r7, #12]
 727 0008 B960     		str	r1, [r7, #8]
 728 000a 7A60     		str	r2, [r7, #4]
 729 000c 3B60     		str	r3, [r7, #0]
1018:../FreeRTOS/Sources/queue.c **** signed portBASE_TYPE xEntryTimeSet = pdFALSE;
 730              		.loc 1 1018 0
 731 000e 4FF00003 		mov	r3, #0
 732 0012 7B62     		str	r3, [r7, #36]
1019:../FreeRTOS/Sources/queue.c **** xTimeOutType xTimeOut;
1020:../FreeRTOS/Sources/queue.c **** signed char *pcOriginalReadPosition;
1021:../FreeRTOS/Sources/queue.c **** xQUEUE *pxQueue;
1022:../FreeRTOS/Sources/queue.c **** 
1023:../FreeRTOS/Sources/queue.c **** 	pxQueue = ( xQUEUE * ) xQueue;
 733              		.loc 1 1023 0
 734 0014 FB68     		ldr	r3, [r7, #12]
 735 0016 3B62     		str	r3, [r7, #32]
1024:../FreeRTOS/Sources/queue.c **** 	configASSERT( pxQueue );
 736              		.loc 1 1024 0
 737 0018 3B6A     		ldr	r3, [r7, #32]
 738 001a 002B     		cmp	r3, #0
 739 001c 02D1     		bne	.L52
 740              		.loc 1 1024 0 is_stmt 0 discriminator 1
 741 001e FFF7FEFF 		bl	ulPortSetInterruptMask
 742              	.L53:
 743              		.loc 1 1024 0 discriminator 2
 744 0022 FEE7     		b	.L53
 745              	.L52:
1025:../FreeRTOS/Sources/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) 
 746              		.loc 1 1025 0 is_stmt 1
 747 0024 BB68     		ldr	r3, [r7, #8]
 748 0026 002B     		cmp	r3, #0
 749 0028 03D1     		bne	.L54
 750              		.loc 1 1025 0 is_stmt 0 discriminator 2
 751 002a 3B6A     		ldr	r3, [r7, #32]
 752 002c 1B6C     		ldr	r3, [r3, #64]
 753 002e 002B     		cmp	r3, #0
 754 0030 02D1     		bne	.L55
 755              	.L54:
 756              		.loc 1 1025 0 discriminator 1
 757 0032 4FF00103 		mov	r3, #1
 758 0036 01E0     		b	.L56
 759              	.L55:
 760              		.loc 1 1025 0 discriminator 3
 761 0038 4FF00003 		mov	r3, #0
 762              	.L56:
 763              		.loc 1 1025 0 discriminator 4
 764 003c 002B     		cmp	r3, #0
 765 003e 03D1     		bne	.L57
 766              		.loc 1 1025 0 discriminator 5
 767 0040 FFF7FEFF 		bl	ulPortSetInterruptMask
 768              	.L58:
 769              		.loc 1 1025 0 discriminator 6
 770 0044 FEE7     		b	.L58
 771              	.L73:
1026:../FreeRTOS/Sources/queue.c **** 
1027:../FreeRTOS/Sources/queue.c **** 	/* This function relaxes the coding standard somewhat to allow return
1028:../FreeRTOS/Sources/queue.c **** 	statements within the function itself.  This is done in the interest
1029:../FreeRTOS/Sources/queue.c **** 	of execution time efficiency. */
1030:../FreeRTOS/Sources/queue.c **** 
1031:../FreeRTOS/Sources/queue.c **** 	for( ;; )
1032:../FreeRTOS/Sources/queue.c **** 	{
1033:../FreeRTOS/Sources/queue.c **** 		taskENTER_CRITICAL();
1034:../FreeRTOS/Sources/queue.c **** 		{
1035:../FreeRTOS/Sources/queue.c **** 			/* Is there data in the queue now?  To be running we must be
1036:../FreeRTOS/Sources/queue.c **** 			the highest priority task wanting to access the queue. */
1037:../FreeRTOS/Sources/queue.c **** 			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
1038:../FreeRTOS/Sources/queue.c **** 			{
1039:../FreeRTOS/Sources/queue.c **** 				/* Remember our read position in case we are just peeking. */
1040:../FreeRTOS/Sources/queue.c **** 				pcOriginalReadPosition = pxQueue->pcReadFrom;
1041:../FreeRTOS/Sources/queue.c **** 
1042:../FreeRTOS/Sources/queue.c **** 				prvCopyDataFromQueue( pxQueue, pvBuffer );
1043:../FreeRTOS/Sources/queue.c **** 
1044:../FreeRTOS/Sources/queue.c **** 				if( xJustPeeking == pdFALSE )
1045:../FreeRTOS/Sources/queue.c **** 				{
1046:../FreeRTOS/Sources/queue.c **** 					traceQUEUE_RECEIVE( pxQueue );
1047:../FreeRTOS/Sources/queue.c **** 
1048:../FreeRTOS/Sources/queue.c **** 					/* We are actually removing data. */
1049:../FreeRTOS/Sources/queue.c **** 					--( pxQueue->uxMessagesWaiting );
1050:../FreeRTOS/Sources/queue.c **** 
1051:../FreeRTOS/Sources/queue.c **** 					#if ( configUSE_MUTEXES == 1 )
1052:../FreeRTOS/Sources/queue.c **** 					{
1053:../FreeRTOS/Sources/queue.c **** 						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
1054:../FreeRTOS/Sources/queue.c **** 						{
1055:../FreeRTOS/Sources/queue.c **** 							/* Record the information required to implement
1056:../FreeRTOS/Sources/queue.c **** 							priority inheritance should it become necessary. */
1057:../FreeRTOS/Sources/queue.c **** 							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
1058:../FreeRTOS/Sources/queue.c **** 						}
1059:../FreeRTOS/Sources/queue.c **** 					}
1060:../FreeRTOS/Sources/queue.c **** 					#endif
1061:../FreeRTOS/Sources/queue.c **** 
1062:../FreeRTOS/Sources/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
1063:../FreeRTOS/Sources/queue.c **** 					{
1064:../FreeRTOS/Sources/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
1065:../FreeRTOS/Sources/queue.c **** 						{
1066:../FreeRTOS/Sources/queue.c **** 							portYIELD_WITHIN_API();
1067:../FreeRTOS/Sources/queue.c **** 						}
1068:../FreeRTOS/Sources/queue.c **** 					}
1069:../FreeRTOS/Sources/queue.c **** 				}
1070:../FreeRTOS/Sources/queue.c **** 				else
1071:../FreeRTOS/Sources/queue.c **** 				{
1072:../FreeRTOS/Sources/queue.c **** 					traceQUEUE_PEEK( pxQueue );
1073:../FreeRTOS/Sources/queue.c **** 
1074:../FreeRTOS/Sources/queue.c **** 					/* The data is not being removed, so reset the read
1075:../FreeRTOS/Sources/queue.c **** 					pointer. */
1076:../FreeRTOS/Sources/queue.c **** 					pxQueue->pcReadFrom = pcOriginalReadPosition;
1077:../FreeRTOS/Sources/queue.c **** 
1078:../FreeRTOS/Sources/queue.c **** 					/* The data is being left in the queue, so see if there are
1079:../FreeRTOS/Sources/queue.c **** 					any other tasks waiting for the data. */
1080:../FreeRTOS/Sources/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1081:../FreeRTOS/Sources/queue.c **** 					{
1082:../FreeRTOS/Sources/queue.c **** 						/* Tasks that are removed from the event list will get added to
1083:../FreeRTOS/Sources/queue.c **** 						the pending ready list as the scheduler is still suspended. */
1084:../FreeRTOS/Sources/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1085:../FreeRTOS/Sources/queue.c **** 						{
1086:../FreeRTOS/Sources/queue.c **** 							/* The task waiting has a higher priority than this task. */
1087:../FreeRTOS/Sources/queue.c **** 							portYIELD_WITHIN_API();
1088:../FreeRTOS/Sources/queue.c **** 						}
1089:../FreeRTOS/Sources/queue.c **** 					}
1090:../FreeRTOS/Sources/queue.c **** 				}
1091:../FreeRTOS/Sources/queue.c **** 
1092:../FreeRTOS/Sources/queue.c **** 				taskEXIT_CRITICAL();
1093:../FreeRTOS/Sources/queue.c **** 				return pdPASS;
1094:../FreeRTOS/Sources/queue.c **** 			}
1095:../FreeRTOS/Sources/queue.c **** 			else
1096:../FreeRTOS/Sources/queue.c **** 			{
1097:../FreeRTOS/Sources/queue.c **** 				if( xTicksToWait == ( portTickType ) 0 )
1098:../FreeRTOS/Sources/queue.c **** 				{
1099:../FreeRTOS/Sources/queue.c **** 					/* The queue was empty and no block time is specified (or
1100:../FreeRTOS/Sources/queue.c **** 					the block time has expired) so leave now. */
1101:../FreeRTOS/Sources/queue.c **** 					taskEXIT_CRITICAL();
1102:../FreeRTOS/Sources/queue.c **** 					traceQUEUE_RECEIVE_FAILED( pxQueue );
1103:../FreeRTOS/Sources/queue.c **** 					return errQUEUE_EMPTY;
1104:../FreeRTOS/Sources/queue.c **** 				}
1105:../FreeRTOS/Sources/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
1106:../FreeRTOS/Sources/queue.c **** 				{
1107:../FreeRTOS/Sources/queue.c **** 					/* The queue was empty and a block time was specified so
1108:../FreeRTOS/Sources/queue.c **** 					configure the timeout structure. */
1109:../FreeRTOS/Sources/queue.c **** 					vTaskSetTimeOutState( &xTimeOut );
1110:../FreeRTOS/Sources/queue.c **** 					xEntryTimeSet = pdTRUE;
1111:../FreeRTOS/Sources/queue.c **** 				}
1112:../FreeRTOS/Sources/queue.c **** 			}
1113:../FreeRTOS/Sources/queue.c **** 		}
1114:../FreeRTOS/Sources/queue.c **** 		taskEXIT_CRITICAL();
1115:../FreeRTOS/Sources/queue.c **** 
1116:../FreeRTOS/Sources/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
1117:../FreeRTOS/Sources/queue.c **** 		now the critical section has been exited. */
1118:../FreeRTOS/Sources/queue.c **** 
1119:../FreeRTOS/Sources/queue.c **** 		vTaskSuspendAll();
1120:../FreeRTOS/Sources/queue.c **** 		prvLockQueue( pxQueue );
1121:../FreeRTOS/Sources/queue.c **** 
1122:../FreeRTOS/Sources/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
1123:../FreeRTOS/Sources/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
1124:../FreeRTOS/Sources/queue.c **** 		{
1125:../FreeRTOS/Sources/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
1126:../FreeRTOS/Sources/queue.c **** 			{
1127:../FreeRTOS/Sources/queue.c **** 				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
1128:../FreeRTOS/Sources/queue.c **** 
1129:../FreeRTOS/Sources/queue.c **** 				#if ( configUSE_MUTEXES == 1 )
1130:../FreeRTOS/Sources/queue.c **** 				{
1131:../FreeRTOS/Sources/queue.c **** 					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
1132:../FreeRTOS/Sources/queue.c **** 					{
1133:../FreeRTOS/Sources/queue.c **** 						portENTER_CRITICAL();
1134:../FreeRTOS/Sources/queue.c **** 						{
1135:../FreeRTOS/Sources/queue.c **** 							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
1136:../FreeRTOS/Sources/queue.c **** 						}
1137:../FreeRTOS/Sources/queue.c **** 						portEXIT_CRITICAL();
1138:../FreeRTOS/Sources/queue.c **** 					}
1139:../FreeRTOS/Sources/queue.c **** 				}
1140:../FreeRTOS/Sources/queue.c **** 				#endif
1141:../FreeRTOS/Sources/queue.c **** 
1142:../FreeRTOS/Sources/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
1143:../FreeRTOS/Sources/queue.c **** 				prvUnlockQueue( pxQueue );
1144:../FreeRTOS/Sources/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
1145:../FreeRTOS/Sources/queue.c **** 				{
1146:../FreeRTOS/Sources/queue.c **** 					portYIELD_WITHIN_API();
1147:../FreeRTOS/Sources/queue.c **** 				}
1148:../FreeRTOS/Sources/queue.c **** 			}
1149:../FreeRTOS/Sources/queue.c **** 			else
1150:../FreeRTOS/Sources/queue.c **** 			{
1151:../FreeRTOS/Sources/queue.c **** 				/* Try again. */
1152:../FreeRTOS/Sources/queue.c **** 				prvUnlockQueue( pxQueue );
1153:../FreeRTOS/Sources/queue.c **** 				( void ) xTaskResumeAll();
1154:../FreeRTOS/Sources/queue.c **** 			}
1155:../FreeRTOS/Sources/queue.c **** 		}
1156:../FreeRTOS/Sources/queue.c **** 		else
1157:../FreeRTOS/Sources/queue.c **** 		{
1158:../FreeRTOS/Sources/queue.c **** 			prvUnlockQueue( pxQueue );
1159:../FreeRTOS/Sources/queue.c **** 			( void ) xTaskResumeAll();
1160:../FreeRTOS/Sources/queue.c **** 			traceQUEUE_RECEIVE_FAILED( pxQueue );
1161:../FreeRTOS/Sources/queue.c **** 			return errQUEUE_EMPTY;
1162:../FreeRTOS/Sources/queue.c **** 		}
1163:../FreeRTOS/Sources/queue.c **** 	}
 772              		.loc 1 1163 0 is_stmt 1
 773 0046 00BF     		nop
 774              	.L57:
1033:../FreeRTOS/Sources/queue.c **** 		taskENTER_CRITICAL();
 775              		.loc 1 1033 0
 776 0048 FFF7FEFF 		bl	vPortEnterCritical
1037:../FreeRTOS/Sources/queue.c **** 			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 777              		.loc 1 1037 0
 778 004c 3B6A     		ldr	r3, [r7, #32]
 779 004e 9B6B     		ldr	r3, [r3, #56]
 780 0050 002B     		cmp	r3, #0
 781 0052 3FD0     		beq	.L59
1040:../FreeRTOS/Sources/queue.c **** 				pcOriginalReadPosition = pxQueue->pcReadFrom;
 782              		.loc 1 1040 0
 783 0054 3B6A     		ldr	r3, [r7, #32]
 784 0056 DB68     		ldr	r3, [r3, #12]
 785 0058 FB61     		str	r3, [r7, #28]
1042:../FreeRTOS/Sources/queue.c **** 				prvCopyDataFromQueue( pxQueue, pvBuffer );
 786              		.loc 1 1042 0
 787 005a 386A     		ldr	r0, [r7, #32]
 788 005c B968     		ldr	r1, [r7, #8]
 789 005e FFF7FEFF 		bl	prvCopyDataFromQueue
1044:../FreeRTOS/Sources/queue.c **** 				if( xJustPeeking == pdFALSE )
 790              		.loc 1 1044 0
 791 0062 3B68     		ldr	r3, [r7, #0]
 792 0064 002B     		cmp	r3, #0
 793 0066 1ED1     		bne	.L60
1049:../FreeRTOS/Sources/queue.c **** 					--( pxQueue->uxMessagesWaiting );
 794              		.loc 1 1049 0
 795 0068 3B6A     		ldr	r3, [r7, #32]
 796 006a 9B6B     		ldr	r3, [r3, #56]
 797 006c 03F1FF32 		add	r2, r3, #-1
 798 0070 3B6A     		ldr	r3, [r7, #32]
 799 0072 9A63     		str	r2, [r3, #56]
1053:../FreeRTOS/Sources/queue.c **** 						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 800              		.loc 1 1053 0
 801 0074 3B6A     		ldr	r3, [r7, #32]
 802 0076 1B68     		ldr	r3, [r3, #0]
 803 0078 002B     		cmp	r3, #0
 804 007a 04D1     		bne	.L61
1057:../FreeRTOS/Sources/queue.c **** 							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
 805              		.loc 1 1057 0
 806 007c FFF7FEFF 		bl	xTaskGetCurrentTaskHandle
 807 0080 0246     		mov	r2, r0
 808 0082 3B6A     		ldr	r3, [r7, #32]
 809 0084 5A60     		str	r2, [r3, #4]
 810              	.L61:
1062:../FreeRTOS/Sources/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 811              		.loc 1 1062 0
 812 0086 3B6A     		ldr	r3, [r7, #32]
 813 0088 1B69     		ldr	r3, [r3, #16]
 814 008a 002B     		cmp	r3, #0
 815 008c 1DD0     		beq	.L62
1064:../FreeRTOS/Sources/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 816              		.loc 1 1064 0
 817 008e 3B6A     		ldr	r3, [r7, #32]
 818 0090 03F11003 		add	r3, r3, #16
 819 0094 1846     		mov	r0, r3
 820 0096 FFF7FEFF 		bl	xTaskRemoveFromEventList
 821 009a 0346     		mov	r3, r0
 822 009c 012B     		cmp	r3, #1
 823 009e 14D1     		bne	.L62
1066:../FreeRTOS/Sources/queue.c **** 							portYIELD_WITHIN_API();
 824              		.loc 1 1066 0
 825 00a0 FFF7FEFF 		bl	vPortYieldFromISR
 826 00a4 11E0     		b	.L62
 827              	.L60:
1076:../FreeRTOS/Sources/queue.c **** 					pxQueue->pcReadFrom = pcOriginalReadPosition;
 828              		.loc 1 1076 0
 829 00a6 3B6A     		ldr	r3, [r7, #32]
 830 00a8 FA69     		ldr	r2, [r7, #28]
 831 00aa DA60     		str	r2, [r3, #12]
1080:../FreeRTOS/Sources/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 832              		.loc 1 1080 0
 833 00ac 3B6A     		ldr	r3, [r7, #32]
 834 00ae 5B6A     		ldr	r3, [r3, #36]
 835 00b0 002B     		cmp	r3, #0
 836 00b2 0AD0     		beq	.L62
1084:../FreeRTOS/Sources/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 837              		.loc 1 1084 0
 838 00b4 3B6A     		ldr	r3, [r7, #32]
 839 00b6 03F12403 		add	r3, r3, #36
 840 00ba 1846     		mov	r0, r3
 841 00bc FFF7FEFF 		bl	xTaskRemoveFromEventList
 842 00c0 0346     		mov	r3, r0
 843 00c2 002B     		cmp	r3, #0
 844 00c4 01D0     		beq	.L62
1087:../FreeRTOS/Sources/queue.c **** 							portYIELD_WITHIN_API();
 845              		.loc 1 1087 0
 846 00c6 FFF7FEFF 		bl	vPortYieldFromISR
 847              	.L62:
1092:../FreeRTOS/Sources/queue.c **** 				taskEXIT_CRITICAL();
 848              		.loc 1 1092 0
 849 00ca FFF7FEFF 		bl	vPortExitCritical
1093:../FreeRTOS/Sources/queue.c **** 				return pdPASS;
 850              		.loc 1 1093 0
 851 00ce 4FF00103 		mov	r3, #1
 852 00d2 6BE0     		b	.L72
 853              	.L59:
1097:../FreeRTOS/Sources/queue.c **** 				if( xTicksToWait == ( portTickType ) 0 )
 854              		.loc 1 1097 0
 855 00d4 7B68     		ldr	r3, [r7, #4]
 856 00d6 002B     		cmp	r3, #0
 857 00d8 04D1     		bne	.L64
1101:../FreeRTOS/Sources/queue.c **** 					taskEXIT_CRITICAL();
 858              		.loc 1 1101 0
 859 00da FFF7FEFF 		bl	vPortExitCritical
1103:../FreeRTOS/Sources/queue.c **** 					return errQUEUE_EMPTY;
 860              		.loc 1 1103 0
 861 00de 4FF00003 		mov	r3, #0
 862 00e2 63E0     		b	.L72
 863              	.L64:
1105:../FreeRTOS/Sources/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 864              		.loc 1 1105 0
 865 00e4 7B6A     		ldr	r3, [r7, #36]
 866 00e6 002B     		cmp	r3, #0
 867 00e8 07D1     		bne	.L65
1109:../FreeRTOS/Sources/queue.c **** 					vTaskSetTimeOutState( &xTimeOut );
 868              		.loc 1 1109 0
 869 00ea 07F11403 		add	r3, r7, #20
 870 00ee 1846     		mov	r0, r3
 871 00f0 FFF7FEFF 		bl	vTaskSetTimeOutState
1110:../FreeRTOS/Sources/queue.c **** 					xEntryTimeSet = pdTRUE;
 872              		.loc 1 1110 0
 873 00f4 4FF00103 		mov	r3, #1
 874 00f8 7B62     		str	r3, [r7, #36]
 875              	.L65:
1114:../FreeRTOS/Sources/queue.c **** 		taskEXIT_CRITICAL();
 876              		.loc 1 1114 0
 877 00fa FFF7FEFF 		bl	vPortExitCritical
1119:../FreeRTOS/Sources/queue.c **** 		vTaskSuspendAll();
 878              		.loc 1 1119 0
 879 00fe FFF7FEFF 		bl	vTaskSuspendAll
1120:../FreeRTOS/Sources/queue.c **** 		prvLockQueue( pxQueue );
 880              		.loc 1 1120 0
 881 0102 FFF7FEFF 		bl	vPortEnterCritical
 882 0106 3B6A     		ldr	r3, [r7, #32]
 883 0108 5B6C     		ldr	r3, [r3, #68]
 884 010a B3F1FF3F 		cmp	r3, #-1
 885 010e 03D1     		bne	.L66
1120:../FreeRTOS/Sources/queue.c **** 		prvLockQueue( pxQueue );
 886              		.loc 1 1120 0 is_stmt 0 discriminator 1
 887 0110 3B6A     		ldr	r3, [r7, #32]
 888 0112 4FF00002 		mov	r2, #0
 889 0116 5A64     		str	r2, [r3, #68]
 890              	.L66:
1120:../FreeRTOS/Sources/queue.c **** 		prvLockQueue( pxQueue );
 891              		.loc 1 1120 0 discriminator 2
 892 0118 3B6A     		ldr	r3, [r7, #32]
 893 011a 9B6C     		ldr	r3, [r3, #72]
 894 011c B3F1FF3F 		cmp	r3, #-1
 895 0120 03D1     		bne	.L67
1120:../FreeRTOS/Sources/queue.c **** 		prvLockQueue( pxQueue );
 896              		.loc 1 1120 0 discriminator 3
 897 0122 3B6A     		ldr	r3, [r7, #32]
 898 0124 4FF00002 		mov	r2, #0
 899 0128 9A64     		str	r2, [r3, #72]
 900              	.L67:
1120:../FreeRTOS/Sources/queue.c **** 		prvLockQueue( pxQueue );
 901              		.loc 1 1120 0 discriminator 4
 902 012a FFF7FEFF 		bl	vPortExitCritical
1123:../FreeRTOS/Sources/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 903              		.loc 1 1123 0 is_stmt 1 discriminator 4
 904 012e 07F11402 		add	r2, r7, #20
 905 0132 07F10403 		add	r3, r7, #4
 906 0136 1046     		mov	r0, r2
 907 0138 1946     		mov	r1, r3
 908 013a FFF7FEFF 		bl	xTaskCheckForTimeOut
 909 013e 0346     		mov	r3, r0
 910 0140 002B     		cmp	r3, #0
 911 0142 2CD1     		bne	.L68
1125:../FreeRTOS/Sources/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 912              		.loc 1 1125 0
 913 0144 386A     		ldr	r0, [r7, #32]
 914 0146 FFF7FEFF 		bl	prvIsQueueEmpty
 915 014a 0346     		mov	r3, r0
 916 014c 002B     		cmp	r3, #0
 917 014e 20D0     		beq	.L69
1131:../FreeRTOS/Sources/queue.c **** 					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 918              		.loc 1 1131 0
 919 0150 3B6A     		ldr	r3, [r7, #32]
 920 0152 1B68     		ldr	r3, [r3, #0]
 921 0154 002B     		cmp	r3, #0
 922 0156 08D1     		bne	.L70
1133:../FreeRTOS/Sources/queue.c **** 						portENTER_CRITICAL();
 923              		.loc 1 1133 0
 924 0158 FFF7FEFF 		bl	vPortEnterCritical
1135:../FreeRTOS/Sources/queue.c **** 							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 925              		.loc 1 1135 0
 926 015c 3B6A     		ldr	r3, [r7, #32]
 927 015e 5B68     		ldr	r3, [r3, #4]
 928 0160 1846     		mov	r0, r3
 929 0162 FFF7FEFF 		bl	vTaskPriorityInherit
1137:../FreeRTOS/Sources/queue.c **** 						portEXIT_CRITICAL();
 930              		.loc 1 1137 0
 931 0166 FFF7FEFF 		bl	vPortExitCritical
 932              	.L70:
1142:../FreeRTOS/Sources/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 933              		.loc 1 1142 0
 934 016a 3B6A     		ldr	r3, [r7, #32]
 935 016c 03F12402 		add	r2, r3, #36
 936 0170 7B68     		ldr	r3, [r7, #4]
 937 0172 1046     		mov	r0, r2
 938 0174 1946     		mov	r1, r3
 939 0176 FFF7FEFF 		bl	vTaskPlaceOnEventList
1143:../FreeRTOS/Sources/queue.c **** 				prvUnlockQueue( pxQueue );
 940              		.loc 1 1143 0
 941 017a 386A     		ldr	r0, [r7, #32]
 942 017c FFF7FEFF 		bl	prvUnlockQueue
1144:../FreeRTOS/Sources/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 943              		.loc 1 1144 0
 944 0180 FFF7FEFF 		bl	xTaskResumeAll
 945 0184 0346     		mov	r3, r0
 946 0186 002B     		cmp	r3, #0
 947 0188 7FF45DAF 		bne	.L73
1146:../FreeRTOS/Sources/queue.c **** 					portYIELD_WITHIN_API();
 948              		.loc 1 1146 0
 949 018c FFF7FEFF 		bl	vPortYieldFromISR
 950              		.loc 1 1163 0
 951 0190 59E7     		b	.L73
 952              	.L69:
1152:../FreeRTOS/Sources/queue.c **** 				prvUnlockQueue( pxQueue );
 953              		.loc 1 1152 0
 954 0192 386A     		ldr	r0, [r7, #32]
 955 0194 FFF7FEFF 		bl	prvUnlockQueue
1153:../FreeRTOS/Sources/queue.c **** 				( void ) xTaskResumeAll();
 956              		.loc 1 1153 0
 957 0198 FFF7FEFF 		bl	xTaskResumeAll
 958              		.loc 1 1163 0
 959 019c 53E7     		b	.L73
 960              	.L68:
1158:../FreeRTOS/Sources/queue.c **** 			prvUnlockQueue( pxQueue );
 961              		.loc 1 1158 0
 962 019e 386A     		ldr	r0, [r7, #32]
 963 01a0 FFF7FEFF 		bl	prvUnlockQueue
1159:../FreeRTOS/Sources/queue.c **** 			( void ) xTaskResumeAll();
 964              		.loc 1 1159 0
 965 01a4 FFF7FEFF 		bl	xTaskResumeAll
1161:../FreeRTOS/Sources/queue.c **** 			return errQUEUE_EMPTY;
 966              		.loc 1 1161 0
 967 01a8 4FF00003 		mov	r3, #0
 968              	.L72:
1164:../FreeRTOS/Sources/queue.c **** }
 969              		.loc 1 1164 0
 970 01ac 1846     		mov	r0, r3
 971 01ae 07F12807 		add	r7, r7, #40
 972 01b2 BD46     		mov	sp, r7
 973 01b4 80BD     		pop	{r7, pc}
 974              		.cfi_endproc
 975              	.LFE5:
 977 01b6 00BF     		.section	.text.xQueueReceiveFromISR,"ax",%progbits
 978              		.align	2
 979              		.global	xQueueReceiveFromISR
 980              		.thumb
 981              		.thumb_func
 983              	xQueueReceiveFromISR:
 984              	.LFB6:
1165:../FreeRTOS/Sources/queue.c **** /*-----------------------------------------------------------*/
1166:../FreeRTOS/Sources/queue.c **** 
1167:../FreeRTOS/Sources/queue.c **** signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle xQueue, void * const pvBuffer, signed portB
1168:../FreeRTOS/Sources/queue.c **** {
 985              		.loc 1 1168 0
 986              		.cfi_startproc
 987              		@ args = 0, pretend = 0, frame = 32
 988              		@ frame_needed = 1, uses_anonymous_args = 0
 989 0000 80B5     		push	{r7, lr}
 990              	.LCFI18:
 991              		.cfi_def_cfa_offset 8
 992              		.cfi_offset 7, -8
 993              		.cfi_offset 14, -4
 994 0002 88B0     		sub	sp, sp, #32
 995              	.LCFI19:
 996              		.cfi_def_cfa_offset 40
 997 0004 00AF     		add	r7, sp, #0
 998              	.LCFI20:
 999              		.cfi_def_cfa_register 7
 1000 0006 F860     		str	r0, [r7, #12]
 1001 0008 B960     		str	r1, [r7, #8]
 1002 000a 7A60     		str	r2, [r7, #4]
1169:../FreeRTOS/Sources/queue.c **** signed portBASE_TYPE xReturn;
1170:../FreeRTOS/Sources/queue.c **** unsigned portBASE_TYPE uxSavedInterruptStatus;
1171:../FreeRTOS/Sources/queue.c **** xQUEUE *pxQueue;
1172:../FreeRTOS/Sources/queue.c **** 
1173:../FreeRTOS/Sources/queue.c **** 	pxQueue = ( xQUEUE * ) xQueue;
 1003              		.loc 1 1173 0
 1004 000c FB68     		ldr	r3, [r7, #12]
 1005 000e BB61     		str	r3, [r7, #24]
1174:../FreeRTOS/Sources/queue.c **** 	configASSERT( pxQueue );
 1006              		.loc 1 1174 0
 1007 0010 BB69     		ldr	r3, [r7, #24]
 1008 0012 002B     		cmp	r3, #0
 1009 0014 02D1     		bne	.L75
 1010              		.loc 1 1174 0 is_stmt 0 discriminator 1
 1011 0016 FFF7FEFF 		bl	ulPortSetInterruptMask
 1012              	.L76:
 1013              		.loc 1 1174 0 discriminator 2
 1014 001a FEE7     		b	.L76
 1015              	.L75:
1175:../FreeRTOS/Sources/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) 
 1016              		.loc 1 1175 0 is_stmt 1
 1017 001c BB68     		ldr	r3, [r7, #8]
 1018 001e 002B     		cmp	r3, #0
 1019 0020 03D1     		bne	.L77
 1020              		.loc 1 1175 0 is_stmt 0 discriminator 2
 1021 0022 BB69     		ldr	r3, [r7, #24]
 1022 0024 1B6C     		ldr	r3, [r3, #64]
 1023 0026 002B     		cmp	r3, #0
 1024 0028 02D1     		bne	.L78
 1025              	.L77:
 1026              		.loc 1 1175 0 discriminator 1
 1027 002a 4FF00103 		mov	r3, #1
 1028 002e 01E0     		b	.L79
 1029              	.L78:
 1030              		.loc 1 1175 0 discriminator 3
 1031 0030 4FF00003 		mov	r3, #0
 1032              	.L79:
 1033              		.loc 1 1175 0 discriminator 4
 1034 0034 002B     		cmp	r3, #0
 1035 0036 02D1     		bne	.L80
 1036              		.loc 1 1175 0 discriminator 5
 1037 0038 FFF7FEFF 		bl	ulPortSetInterruptMask
 1038              	.L81:
 1039              		.loc 1 1175 0 discriminator 6
 1040 003c FEE7     		b	.L81
 1041              	.L80:
1176:../FreeRTOS/Sources/queue.c **** 
1177:../FreeRTOS/Sources/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1042              		.loc 1 1177 0 is_stmt 1
 1043 003e FFF7FEFF 		bl	ulPortSetInterruptMask
 1044 0042 7861     		str	r0, [r7, #20]
1178:../FreeRTOS/Sources/queue.c **** 	{
1179:../FreeRTOS/Sources/queue.c **** 		/* We cannot block from an ISR, so check there is data available. */
1180:../FreeRTOS/Sources/queue.c **** 		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 1045              		.loc 1 1180 0
 1046 0044 BB69     		ldr	r3, [r7, #24]
 1047 0046 9B6B     		ldr	r3, [r3, #56]
 1048 0048 002B     		cmp	r3, #0
 1049 004a 2DD0     		beq	.L82
1181:../FreeRTOS/Sources/queue.c **** 		{
1182:../FreeRTOS/Sources/queue.c **** 			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
1183:../FreeRTOS/Sources/queue.c **** 
1184:../FreeRTOS/Sources/queue.c **** 			prvCopyDataFromQueue( pxQueue, pvBuffer );
 1050              		.loc 1 1184 0
 1051 004c B869     		ldr	r0, [r7, #24]
 1052 004e B968     		ldr	r1, [r7, #8]
 1053 0050 FFF7FEFF 		bl	prvCopyDataFromQueue
1185:../FreeRTOS/Sources/queue.c **** 			--( pxQueue->uxMessagesWaiting );
 1054              		.loc 1 1185 0
 1055 0054 BB69     		ldr	r3, [r7, #24]
 1056 0056 9B6B     		ldr	r3, [r3, #56]
 1057 0058 03F1FF32 		add	r2, r3, #-1
 1058 005c BB69     		ldr	r3, [r7, #24]
 1059 005e 9A63     		str	r2, [r3, #56]
1186:../FreeRTOS/Sources/queue.c **** 
1187:../FreeRTOS/Sources/queue.c **** 			/* If the queue is locked we will not modify the event list.  Instead
1188:../FreeRTOS/Sources/queue.c **** 			we update the lock count so the task that unlocks the queue will know
1189:../FreeRTOS/Sources/queue.c **** 			that an ISR has removed data while the queue was locked. */
1190:../FreeRTOS/Sources/queue.c **** 			if( pxQueue->xRxLock == queueUNLOCKED )
 1060              		.loc 1 1190 0
 1061 0060 BB69     		ldr	r3, [r7, #24]
 1062 0062 5B6C     		ldr	r3, [r3, #68]
 1063 0064 B3F1FF3F 		cmp	r3, #-1
 1064 0068 14D1     		bne	.L83
1191:../FreeRTOS/Sources/queue.c **** 			{
1192:../FreeRTOS/Sources/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 1065              		.loc 1 1192 0
 1066 006a BB69     		ldr	r3, [r7, #24]
 1067 006c 1B69     		ldr	r3, [r3, #16]
 1068 006e 002B     		cmp	r3, #0
 1069 0070 16D0     		beq	.L84
1193:../FreeRTOS/Sources/queue.c **** 				{
1194:../FreeRTOS/Sources/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 1070              		.loc 1 1194 0
 1071 0072 BB69     		ldr	r3, [r7, #24]
 1072 0074 03F11003 		add	r3, r3, #16
 1073 0078 1846     		mov	r0, r3
 1074 007a FFF7FEFF 		bl	xTaskRemoveFromEventList
 1075 007e 0346     		mov	r3, r0
 1076 0080 002B     		cmp	r3, #0
 1077 0082 0DD0     		beq	.L84
1195:../FreeRTOS/Sources/queue.c **** 					{
1196:../FreeRTOS/Sources/queue.c **** 						/* The task waiting has a higher priority than us so
1197:../FreeRTOS/Sources/queue.c **** 						force a context switch. */
1198:../FreeRTOS/Sources/queue.c **** 						if( pxHigherPriorityTaskWoken != NULL )
 1078              		.loc 1 1198 0
 1079 0084 7B68     		ldr	r3, [r7, #4]
 1080 0086 002B     		cmp	r3, #0
 1081 0088 0AD0     		beq	.L84
1199:../FreeRTOS/Sources/queue.c **** 						{
1200:../FreeRTOS/Sources/queue.c **** 							*pxHigherPriorityTaskWoken = pdTRUE;
 1082              		.loc 1 1200 0
 1083 008a 7B68     		ldr	r3, [r7, #4]
 1084 008c 4FF00102 		mov	r2, #1
 1085 0090 1A60     		str	r2, [r3, #0]
 1086 0092 05E0     		b	.L84
 1087              	.L83:
1201:../FreeRTOS/Sources/queue.c **** 						}
1202:../FreeRTOS/Sources/queue.c **** 					}
1203:../FreeRTOS/Sources/queue.c **** 				}
1204:../FreeRTOS/Sources/queue.c **** 			}
1205:../FreeRTOS/Sources/queue.c **** 			else
1206:../FreeRTOS/Sources/queue.c **** 			{
1207:../FreeRTOS/Sources/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
1208:../FreeRTOS/Sources/queue.c **** 				knows that data was removed while it was locked. */
1209:../FreeRTOS/Sources/queue.c **** 				++( pxQueue->xRxLock );
 1088              		.loc 1 1209 0
 1089 0094 BB69     		ldr	r3, [r7, #24]
 1090 0096 5B6C     		ldr	r3, [r3, #68]
 1091 0098 03F10102 		add	r2, r3, #1
 1092 009c BB69     		ldr	r3, [r7, #24]
 1093 009e 5A64     		str	r2, [r3, #68]
 1094              	.L84:
1210:../FreeRTOS/Sources/queue.c **** 			}
1211:../FreeRTOS/Sources/queue.c **** 
1212:../FreeRTOS/Sources/queue.c **** 			xReturn = pdPASS;
 1095              		.loc 1 1212 0
 1096 00a0 4FF00103 		mov	r3, #1
 1097 00a4 FB61     		str	r3, [r7, #28]
 1098 00a6 02E0     		b	.L85
 1099              	.L82:
1213:../FreeRTOS/Sources/queue.c **** 		}
1214:../FreeRTOS/Sources/queue.c **** 		else
1215:../FreeRTOS/Sources/queue.c **** 		{
1216:../FreeRTOS/Sources/queue.c **** 			xReturn = pdFAIL;
 1100              		.loc 1 1216 0
 1101 00a8 4FF00003 		mov	r3, #0
 1102 00ac FB61     		str	r3, [r7, #28]
 1103              	.L85:
1217:../FreeRTOS/Sources/queue.c **** 			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
1218:../FreeRTOS/Sources/queue.c **** 		}
1219:../FreeRTOS/Sources/queue.c **** 	}
1220:../FreeRTOS/Sources/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 1104              		.loc 1 1220 0
 1105 00ae 7869     		ldr	r0, [r7, #20]
 1106 00b0 FFF7FEFF 		bl	vPortClearInterruptMask
1221:../FreeRTOS/Sources/queue.c **** 
1222:../FreeRTOS/Sources/queue.c **** 	return xReturn;
 1107              		.loc 1 1222 0
 1108 00b4 FB69     		ldr	r3, [r7, #28]
1223:../FreeRTOS/Sources/queue.c **** }
 1109              		.loc 1 1223 0
 1110 00b6 1846     		mov	r0, r3
 1111 00b8 07F12007 		add	r7, r7, #32
 1112 00bc BD46     		mov	sp, r7
 1113 00be 80BD     		pop	{r7, pc}
 1114              		.cfi_endproc
 1115              	.LFE6:
 1117              		.section	.text.uxQueueMessagesWaiting,"ax",%progbits
 1118              		.align	2
 1119              		.global	uxQueueMessagesWaiting
 1120              		.thumb
 1121              		.thumb_func
 1123              	uxQueueMessagesWaiting:
 1124              	.LFB7:
1224:../FreeRTOS/Sources/queue.c **** /*-----------------------------------------------------------*/
1225:../FreeRTOS/Sources/queue.c **** 
1226:../FreeRTOS/Sources/queue.c **** unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle xQueue )
1227:../FreeRTOS/Sources/queue.c **** {
 1125              		.loc 1 1227 0
 1126              		.cfi_startproc
 1127              		@ args = 0, pretend = 0, frame = 16
 1128              		@ frame_needed = 1, uses_anonymous_args = 0
 1129 0000 80B5     		push	{r7, lr}
 1130              	.LCFI21:
 1131              		.cfi_def_cfa_offset 8
 1132              		.cfi_offset 7, -8
 1133              		.cfi_offset 14, -4
 1134 0002 84B0     		sub	sp, sp, #16
 1135              	.LCFI22:
 1136              		.cfi_def_cfa_offset 24
 1137 0004 00AF     		add	r7, sp, #0
 1138              	.LCFI23:
 1139              		.cfi_def_cfa_register 7
 1140 0006 7860     		str	r0, [r7, #4]
1228:../FreeRTOS/Sources/queue.c **** unsigned portBASE_TYPE uxReturn;
1229:../FreeRTOS/Sources/queue.c **** 
1230:../FreeRTOS/Sources/queue.c **** 	configASSERT( xQueue );
 1141              		.loc 1 1230 0
 1142 0008 7B68     		ldr	r3, [r7, #4]
 1143 000a 002B     		cmp	r3, #0
 1144 000c 02D1     		bne	.L88
 1145              		.loc 1 1230 0 is_stmt 0 discriminator 1
 1146 000e FFF7FEFF 		bl	ulPortSetInterruptMask
 1147              	.L89:
 1148              		.loc 1 1230 0 discriminator 2
 1149 0012 FEE7     		b	.L89
 1150              	.L88:
1231:../FreeRTOS/Sources/queue.c **** 
1232:../FreeRTOS/Sources/queue.c **** 	taskENTER_CRITICAL();
 1151              		.loc 1 1232 0 is_stmt 1
 1152 0014 FFF7FEFF 		bl	vPortEnterCritical
1233:../FreeRTOS/Sources/queue.c **** 		uxReturn = ( ( xQUEUE * ) xQueue )->uxMessagesWaiting;
 1153              		.loc 1 1233 0
 1154 0018 7B68     		ldr	r3, [r7, #4]
 1155 001a 9B6B     		ldr	r3, [r3, #56]
 1156 001c FB60     		str	r3, [r7, #12]
1234:../FreeRTOS/Sources/queue.c **** 	taskEXIT_CRITICAL();
 1157              		.loc 1 1234 0
 1158 001e FFF7FEFF 		bl	vPortExitCritical
1235:../FreeRTOS/Sources/queue.c **** 
1236:../FreeRTOS/Sources/queue.c **** 	return uxReturn;
 1159              		.loc 1 1236 0
 1160 0022 FB68     		ldr	r3, [r7, #12]
1237:../FreeRTOS/Sources/queue.c **** }
 1161              		.loc 1 1237 0
 1162 0024 1846     		mov	r0, r3
 1163 0026 07F11007 		add	r7, r7, #16
 1164 002a BD46     		mov	sp, r7
 1165 002c 80BD     		pop	{r7, pc}
 1166              		.cfi_endproc
 1167              	.LFE7:
 1169 002e 00BF     		.section	.text.uxQueueMessagesWaitingFromISR,"ax",%progbits
 1170              		.align	2
 1171              		.global	uxQueueMessagesWaitingFromISR
 1172              		.thumb
 1173              		.thumb_func
 1175              	uxQueueMessagesWaitingFromISR:
 1176              	.LFB8:
1238:../FreeRTOS/Sources/queue.c **** /*-----------------------------------------------------------*/
1239:../FreeRTOS/Sources/queue.c **** 
1240:../FreeRTOS/Sources/queue.c **** unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle xQueue )
1241:../FreeRTOS/Sources/queue.c **** {
 1177              		.loc 1 1241 0
 1178              		.cfi_startproc
 1179              		@ args = 0, pretend = 0, frame = 16
 1180              		@ frame_needed = 1, uses_anonymous_args = 0
 1181 0000 80B5     		push	{r7, lr}
 1182              	.LCFI24:
 1183              		.cfi_def_cfa_offset 8
 1184              		.cfi_offset 7, -8
 1185              		.cfi_offset 14, -4
 1186 0002 84B0     		sub	sp, sp, #16
 1187              	.LCFI25:
 1188              		.cfi_def_cfa_offset 24
 1189 0004 00AF     		add	r7, sp, #0
 1190              	.LCFI26:
 1191              		.cfi_def_cfa_register 7
 1192 0006 7860     		str	r0, [r7, #4]
1242:../FreeRTOS/Sources/queue.c **** unsigned portBASE_TYPE uxReturn;
1243:../FreeRTOS/Sources/queue.c **** 
1244:../FreeRTOS/Sources/queue.c **** 	configASSERT( xQueue );
 1193              		.loc 1 1244 0
 1194 0008 7B68     		ldr	r3, [r7, #4]
 1195 000a 002B     		cmp	r3, #0
 1196 000c 02D1     		bne	.L92
 1197              		.loc 1 1244 0 is_stmt 0 discriminator 1
 1198 000e FFF7FEFF 		bl	ulPortSetInterruptMask
 1199              	.L93:
 1200              		.loc 1 1244 0 discriminator 2
 1201 0012 FEE7     		b	.L93
 1202              	.L92:
1245:../FreeRTOS/Sources/queue.c **** 
1246:../FreeRTOS/Sources/queue.c **** 	uxReturn = ( ( xQUEUE * ) xQueue )->uxMessagesWaiting;
 1203              		.loc 1 1246 0 is_stmt 1
 1204 0014 7B68     		ldr	r3, [r7, #4]
 1205 0016 9B6B     		ldr	r3, [r3, #56]
 1206 0018 FB60     		str	r3, [r7, #12]
1247:../FreeRTOS/Sources/queue.c **** 
1248:../FreeRTOS/Sources/queue.c **** 	return uxReturn;
 1207              		.loc 1 1248 0
 1208 001a FB68     		ldr	r3, [r7, #12]
1249:../FreeRTOS/Sources/queue.c **** }
 1209              		.loc 1 1249 0
 1210 001c 1846     		mov	r0, r3
 1211 001e 07F11007 		add	r7, r7, #16
 1212 0022 BD46     		mov	sp, r7
 1213 0024 80BD     		pop	{r7, pc}
 1214              		.cfi_endproc
 1215              	.LFE8:
 1217 0026 00BF     		.section	.text.vQueueDelete,"ax",%progbits
 1218              		.align	2
 1219              		.global	vQueueDelete
 1220              		.thumb
 1221              		.thumb_func
 1223              	vQueueDelete:
 1224              	.LFB9:
1250:../FreeRTOS/Sources/queue.c **** /*-----------------------------------------------------------*/
1251:../FreeRTOS/Sources/queue.c **** 
1252:../FreeRTOS/Sources/queue.c **** void vQueueDelete( xQueueHandle xQueue )
1253:../FreeRTOS/Sources/queue.c **** {
 1225              		.loc 1 1253 0
 1226              		.cfi_startproc
 1227              		@ args = 0, pretend = 0, frame = 16
 1228              		@ frame_needed = 1, uses_anonymous_args = 0
 1229 0000 80B5     		push	{r7, lr}
 1230              	.LCFI27:
 1231              		.cfi_def_cfa_offset 8
 1232              		.cfi_offset 7, -8
 1233              		.cfi_offset 14, -4
 1234 0002 84B0     		sub	sp, sp, #16
 1235              	.LCFI28:
 1236              		.cfi_def_cfa_offset 24
 1237 0004 00AF     		add	r7, sp, #0
 1238              	.LCFI29:
 1239              		.cfi_def_cfa_register 7
 1240 0006 7860     		str	r0, [r7, #4]
1254:../FreeRTOS/Sources/queue.c **** xQUEUE *pxQueue;
1255:../FreeRTOS/Sources/queue.c **** 
1256:../FreeRTOS/Sources/queue.c **** 	pxQueue = ( xQUEUE * ) xQueue;
 1241              		.loc 1 1256 0
 1242 0008 7B68     		ldr	r3, [r7, #4]
 1243 000a FB60     		str	r3, [r7, #12]
1257:../FreeRTOS/Sources/queue.c **** 	configASSERT( pxQueue );
 1244              		.loc 1 1257 0
 1245 000c FB68     		ldr	r3, [r7, #12]
 1246 000e 002B     		cmp	r3, #0
 1247 0010 02D1     		bne	.L96
 1248              		.loc 1 1257 0 is_stmt 0 discriminator 1
 1249 0012 FFF7FEFF 		bl	ulPortSetInterruptMask
 1250              	.L97:
 1251              		.loc 1 1257 0 discriminator 2
 1252 0016 FEE7     		b	.L97
 1253              	.L96:
1258:../FreeRTOS/Sources/queue.c **** 
1259:../FreeRTOS/Sources/queue.c **** 	traceQUEUE_DELETE( pxQueue );
1260:../FreeRTOS/Sources/queue.c **** 	#if ( configQUEUE_REGISTRY_SIZE > 0 )
1261:../FreeRTOS/Sources/queue.c **** 	{
1262:../FreeRTOS/Sources/queue.c **** 		prvQueueUnregisterQueue( pxQueue );
1263:../FreeRTOS/Sources/queue.c **** 	}
1264:../FreeRTOS/Sources/queue.c **** 	#endif
1265:../FreeRTOS/Sources/queue.c **** 	vPortFree( pxQueue->pcHead );
 1254              		.loc 1 1265 0 is_stmt 1
 1255 0018 FB68     		ldr	r3, [r7, #12]
 1256 001a 1B68     		ldr	r3, [r3, #0]
 1257 001c 1846     		mov	r0, r3
 1258 001e FFF7FEFF 		bl	vPortFree
1266:../FreeRTOS/Sources/queue.c **** 	vPortFree( pxQueue );
 1259              		.loc 1 1266 0
 1260 0022 F868     		ldr	r0, [r7, #12]
 1261 0024 FFF7FEFF 		bl	vPortFree
1267:../FreeRTOS/Sources/queue.c **** }
 1262              		.loc 1 1267 0
 1263 0028 07F11007 		add	r7, r7, #16
 1264 002c BD46     		mov	sp, r7
 1265 002e 80BD     		pop	{r7, pc}
 1266              		.cfi_endproc
 1267              	.LFE9:
 1269              		.section	.text.prvCopyDataToQueue,"ax",%progbits
 1270              		.align	2
 1271              		.thumb
 1272              		.thumb_func
 1274              	prvCopyDataToQueue:
 1275              	.LFB10:
1268:../FreeRTOS/Sources/queue.c **** /*-----------------------------------------------------------*/
1269:../FreeRTOS/Sources/queue.c **** 
1270:../FreeRTOS/Sources/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1271:../FreeRTOS/Sources/queue.c **** 
1272:../FreeRTOS/Sources/queue.c **** 	unsigned char ucQueueGetQueueNumber( xQueueHandle xQueue )
1273:../FreeRTOS/Sources/queue.c **** 	{
1274:../FreeRTOS/Sources/queue.c **** 		return ( ( xQUEUE * ) xQueue )->ucQueueNumber;
1275:../FreeRTOS/Sources/queue.c **** 	}
1276:../FreeRTOS/Sources/queue.c **** 
1277:../FreeRTOS/Sources/queue.c **** #endif /* configUSE_TRACE_FACILITY */
1278:../FreeRTOS/Sources/queue.c **** /*-----------------------------------------------------------*/
1279:../FreeRTOS/Sources/queue.c **** 
1280:../FreeRTOS/Sources/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1281:../FreeRTOS/Sources/queue.c **** 
1282:../FreeRTOS/Sources/queue.c **** 	void vQueueSetQueueNumber( xQueueHandle xQueue, unsigned char ucQueueNumber )
1283:../FreeRTOS/Sources/queue.c **** 	{
1284:../FreeRTOS/Sources/queue.c **** 		( ( xQUEUE * ) xQueue )->ucQueueNumber = ucQueueNumber;
1285:../FreeRTOS/Sources/queue.c **** 	}
1286:../FreeRTOS/Sources/queue.c **** 
1287:../FreeRTOS/Sources/queue.c **** #endif /* configUSE_TRACE_FACILITY */
1288:../FreeRTOS/Sources/queue.c **** /*-----------------------------------------------------------*/
1289:../FreeRTOS/Sources/queue.c **** 
1290:../FreeRTOS/Sources/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1291:../FreeRTOS/Sources/queue.c **** 
1292:../FreeRTOS/Sources/queue.c **** 	unsigned char ucQueueGetQueueType( xQueueHandle xQueue )
1293:../FreeRTOS/Sources/queue.c **** 	{
1294:../FreeRTOS/Sources/queue.c **** 		return ( ( xQUEUE * ) xQueue )->ucQueueType;
1295:../FreeRTOS/Sources/queue.c **** 	}
1296:../FreeRTOS/Sources/queue.c **** 
1297:../FreeRTOS/Sources/queue.c **** #endif /* configUSE_TRACE_FACILITY */
1298:../FreeRTOS/Sources/queue.c **** /*-----------------------------------------------------------*/
1299:../FreeRTOS/Sources/queue.c **** 
1300:../FreeRTOS/Sources/queue.c **** static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition
1301:../FreeRTOS/Sources/queue.c **** {
 1276              		.loc 1 1301 0
 1277              		.cfi_startproc
 1278              		@ args = 0, pretend = 0, frame = 16
 1279              		@ frame_needed = 1, uses_anonymous_args = 0
 1280 0000 80B5     		push	{r7, lr}
 1281              	.LCFI30:
 1282              		.cfi_def_cfa_offset 8
 1283              		.cfi_offset 7, -8
 1284              		.cfi_offset 14, -4
 1285 0002 84B0     		sub	sp, sp, #16
 1286              	.LCFI31:
 1287              		.cfi_def_cfa_offset 24
 1288 0004 00AF     		add	r7, sp, #0
 1289              	.LCFI32:
 1290              		.cfi_def_cfa_register 7
 1291 0006 F860     		str	r0, [r7, #12]
 1292 0008 B960     		str	r1, [r7, #8]
 1293 000a 7A60     		str	r2, [r7, #4]
1302:../FreeRTOS/Sources/queue.c **** 	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
 1294              		.loc 1 1302 0
 1295 000c FB68     		ldr	r3, [r7, #12]
 1296 000e 1B6C     		ldr	r3, [r3, #64]
 1297 0010 002B     		cmp	r3, #0
 1298 0012 0DD1     		bne	.L99
1303:../FreeRTOS/Sources/queue.c **** 	{
1304:../FreeRTOS/Sources/queue.c **** 		#if ( configUSE_MUTEXES == 1 )
1305:../FreeRTOS/Sources/queue.c **** 		{
1306:../FreeRTOS/Sources/queue.c **** 			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 1299              		.loc 1 1306 0
 1300 0014 FB68     		ldr	r3, [r7, #12]
 1301 0016 1B68     		ldr	r3, [r3, #0]
 1302 0018 002B     		cmp	r3, #0
 1303 001a 48D1     		bne	.L100
1307:../FreeRTOS/Sources/queue.c **** 			{
1308:../FreeRTOS/Sources/queue.c **** 				/* The mutex is no longer being held. */
1309:../FreeRTOS/Sources/queue.c **** 				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
 1304              		.loc 1 1309 0
 1305 001c FB68     		ldr	r3, [r7, #12]
 1306 001e 5B68     		ldr	r3, [r3, #4]
 1307 0020 1846     		mov	r0, r3
 1308 0022 FFF7FEFF 		bl	vTaskPriorityDisinherit
1310:../FreeRTOS/Sources/queue.c **** 				pxQueue->pxMutexHolder = NULL;
 1309              		.loc 1 1310 0
 1310 0026 FB68     		ldr	r3, [r7, #12]
 1311 0028 4FF00002 		mov	r2, #0
 1312 002c 5A60     		str	r2, [r3, #4]
 1313 002e 3EE0     		b	.L100
 1314              	.L99:
1311:../FreeRTOS/Sources/queue.c **** 			}
1312:../FreeRTOS/Sources/queue.c **** 		}
1313:../FreeRTOS/Sources/queue.c **** 		#endif
1314:../FreeRTOS/Sources/queue.c **** 	}
1315:../FreeRTOS/Sources/queue.c **** 	else if( xPosition == queueSEND_TO_BACK )
 1315              		.loc 1 1315 0
 1316 0030 7B68     		ldr	r3, [r7, #4]
 1317 0032 002B     		cmp	r3, #0
 1318 0034 1AD1     		bne	.L101
1316:../FreeRTOS/Sources/queue.c **** 	{
1317:../FreeRTOS/Sources/queue.c **** 		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
 1319              		.loc 1 1317 0
 1320 0036 FB68     		ldr	r3, [r7, #12]
 1321 0038 9A68     		ldr	r2, [r3, #8]
 1322 003a FB68     		ldr	r3, [r7, #12]
 1323 003c 1B6C     		ldr	r3, [r3, #64]
 1324 003e 1046     		mov	r0, r2
 1325 0040 B968     		ldr	r1, [r7, #8]
 1326 0042 1A46     		mov	r2, r3
 1327 0044 FFF7FEFF 		bl	memcpy
1318:../FreeRTOS/Sources/queue.c **** 		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 1328              		.loc 1 1318 0
 1329 0048 FB68     		ldr	r3, [r7, #12]
 1330 004a 9A68     		ldr	r2, [r3, #8]
 1331 004c FB68     		ldr	r3, [r7, #12]
 1332 004e 1B6C     		ldr	r3, [r3, #64]
 1333 0050 D218     		adds	r2, r2, r3
 1334 0052 FB68     		ldr	r3, [r7, #12]
 1335 0054 9A60     		str	r2, [r3, #8]
1319:../FreeRTOS/Sources/queue.c **** 		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
 1336              		.loc 1 1319 0
 1337 0056 FB68     		ldr	r3, [r7, #12]
 1338 0058 9A68     		ldr	r2, [r3, #8]
 1339 005a FB68     		ldr	r3, [r7, #12]
 1340 005c 5B68     		ldr	r3, [r3, #4]
 1341 005e 9A42     		cmp	r2, r3
 1342 0060 25D3     		bcc	.L100
1320:../FreeRTOS/Sources/queue.c **** 		{
1321:../FreeRTOS/Sources/queue.c **** 			pxQueue->pcWriteTo = pxQueue->pcHead;
 1343              		.loc 1 1321 0
 1344 0062 FB68     		ldr	r3, [r7, #12]
 1345 0064 1A68     		ldr	r2, [r3, #0]
 1346 0066 FB68     		ldr	r3, [r7, #12]
 1347 0068 9A60     		str	r2, [r3, #8]
 1348 006a 20E0     		b	.L100
 1349              	.L101:
1322:../FreeRTOS/Sources/queue.c **** 		}
1323:../FreeRTOS/Sources/queue.c **** 	}
1324:../FreeRTOS/Sources/queue.c **** 	else
1325:../FreeRTOS/Sources/queue.c **** 	{
1326:../FreeRTOS/Sources/queue.c **** 		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
 1350              		.loc 1 1326 0
 1351 006c FB68     		ldr	r3, [r7, #12]
 1352 006e DA68     		ldr	r2, [r3, #12]
 1353 0070 FB68     		ldr	r3, [r7, #12]
 1354 0072 1B6C     		ldr	r3, [r3, #64]
 1355 0074 1046     		mov	r0, r2
 1356 0076 B968     		ldr	r1, [r7, #8]
 1357 0078 1A46     		mov	r2, r3
 1358 007a FFF7FEFF 		bl	memcpy
1327:../FreeRTOS/Sources/queue.c **** 		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
 1359              		.loc 1 1327 0
 1360 007e FB68     		ldr	r3, [r7, #12]
 1361 0080 DA68     		ldr	r2, [r3, #12]
 1362 0082 FB68     		ldr	r3, [r7, #12]
 1363 0084 1B6C     		ldr	r3, [r3, #64]
 1364 0086 C3F10003 		rsb	r3, r3, #0
 1365 008a D218     		adds	r2, r2, r3
 1366 008c FB68     		ldr	r3, [r7, #12]
 1367 008e DA60     		str	r2, [r3, #12]
1328:../FreeRTOS/Sources/queue.c **** 		if( pxQueue->pcReadFrom < pxQueue->pcHead )
 1368              		.loc 1 1328 0
 1369 0090 FB68     		ldr	r3, [r7, #12]
 1370 0092 DA68     		ldr	r2, [r3, #12]
 1371 0094 FB68     		ldr	r3, [r7, #12]
 1372 0096 1B68     		ldr	r3, [r3, #0]
 1373 0098 9A42     		cmp	r2, r3
 1374 009a 08D2     		bcs	.L100
1329:../FreeRTOS/Sources/queue.c **** 		{
1330:../FreeRTOS/Sources/queue.c **** 			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
 1375              		.loc 1 1330 0
 1376 009c FB68     		ldr	r3, [r7, #12]
 1377 009e 5A68     		ldr	r2, [r3, #4]
 1378 00a0 FB68     		ldr	r3, [r7, #12]
 1379 00a2 1B6C     		ldr	r3, [r3, #64]
 1380 00a4 C3F10003 		rsb	r3, r3, #0
 1381 00a8 D218     		adds	r2, r2, r3
 1382 00aa FB68     		ldr	r3, [r7, #12]
 1383 00ac DA60     		str	r2, [r3, #12]
 1384              	.L100:
1331:../FreeRTOS/Sources/queue.c **** 		}
1332:../FreeRTOS/Sources/queue.c **** 	}
1333:../FreeRTOS/Sources/queue.c **** 
1334:../FreeRTOS/Sources/queue.c **** 	++( pxQueue->uxMessagesWaiting );
 1385              		.loc 1 1334 0
 1386 00ae FB68     		ldr	r3, [r7, #12]
 1387 00b0 9B6B     		ldr	r3, [r3, #56]
 1388 00b2 03F10102 		add	r2, r3, #1
 1389 00b6 FB68     		ldr	r3, [r7, #12]
 1390 00b8 9A63     		str	r2, [r3, #56]
1335:../FreeRTOS/Sources/queue.c **** }
 1391              		.loc 1 1335 0
 1392 00ba 07F11007 		add	r7, r7, #16
 1393 00be BD46     		mov	sp, r7
 1394 00c0 80BD     		pop	{r7, pc}
 1395              		.cfi_endproc
 1396              	.LFE10:
 1398 00c2 00BF     		.section	.text.prvCopyDataFromQueue,"ax",%progbits
 1399              		.align	2
 1400              		.thumb
 1401              		.thumb_func
 1403              	prvCopyDataFromQueue:
 1404              	.LFB11:
1336:../FreeRTOS/Sources/queue.c **** /*-----------------------------------------------------------*/
1337:../FreeRTOS/Sources/queue.c **** 
1338:../FreeRTOS/Sources/queue.c **** static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
1339:../FreeRTOS/Sources/queue.c **** {
 1405              		.loc 1 1339 0
 1406              		.cfi_startproc
 1407              		@ args = 0, pretend = 0, frame = 8
 1408              		@ frame_needed = 1, uses_anonymous_args = 0
 1409 0000 80B5     		push	{r7, lr}
 1410              	.LCFI33:
 1411              		.cfi_def_cfa_offset 8
 1412              		.cfi_offset 7, -8
 1413              		.cfi_offset 14, -4
 1414 0002 82B0     		sub	sp, sp, #8
 1415              	.LCFI34:
 1416              		.cfi_def_cfa_offset 16
 1417 0004 00AF     		add	r7, sp, #0
 1418              	.LCFI35:
 1419              		.cfi_def_cfa_register 7
 1420 0006 7860     		str	r0, [r7, #4]
 1421 0008 3960     		str	r1, [r7, #0]
1340:../FreeRTOS/Sources/queue.c **** 	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
 1422              		.loc 1 1340 0
 1423 000a 7B68     		ldr	r3, [r7, #4]
 1424 000c 1B68     		ldr	r3, [r3, #0]
 1425 000e 002B     		cmp	r3, #0
 1426 0010 19D0     		beq	.L102
1341:../FreeRTOS/Sources/queue.c **** 	{
1342:../FreeRTOS/Sources/queue.c **** 		pxQueue->pcReadFrom += pxQueue->uxItemSize;
 1427              		.loc 1 1342 0
 1428 0012 7B68     		ldr	r3, [r7, #4]
 1429 0014 DA68     		ldr	r2, [r3, #12]
 1430 0016 7B68     		ldr	r3, [r7, #4]
 1431 0018 1B6C     		ldr	r3, [r3, #64]
 1432 001a D218     		adds	r2, r2, r3
 1433 001c 7B68     		ldr	r3, [r7, #4]
 1434 001e DA60     		str	r2, [r3, #12]
1343:../FreeRTOS/Sources/queue.c **** 		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
 1435              		.loc 1 1343 0
 1436 0020 7B68     		ldr	r3, [r7, #4]
 1437 0022 DA68     		ldr	r2, [r3, #12]
 1438 0024 7B68     		ldr	r3, [r7, #4]
 1439 0026 5B68     		ldr	r3, [r3, #4]
 1440 0028 9A42     		cmp	r2, r3
 1441 002a 03D3     		bcc	.L104
1344:../FreeRTOS/Sources/queue.c **** 		{
1345:../FreeRTOS/Sources/queue.c **** 			pxQueue->pcReadFrom = pxQueue->pcHead;
 1442              		.loc 1 1345 0
 1443 002c 7B68     		ldr	r3, [r7, #4]
 1444 002e 1A68     		ldr	r2, [r3, #0]
 1445 0030 7B68     		ldr	r3, [r7, #4]
 1446 0032 DA60     		str	r2, [r3, #12]
 1447              	.L104:
1346:../FreeRTOS/Sources/queue.c **** 		}
1347:../FreeRTOS/Sources/queue.c **** 		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
 1448              		.loc 1 1347 0
 1449 0034 7B68     		ldr	r3, [r7, #4]
 1450 0036 DA68     		ldr	r2, [r3, #12]
 1451 0038 7B68     		ldr	r3, [r7, #4]
 1452 003a 1B6C     		ldr	r3, [r3, #64]
 1453 003c 3868     		ldr	r0, [r7, #0]
 1454 003e 1146     		mov	r1, r2
 1455 0040 1A46     		mov	r2, r3
 1456 0042 FFF7FEFF 		bl	memcpy
 1457              	.L102:
1348:../FreeRTOS/Sources/queue.c **** 	}
1349:../FreeRTOS/Sources/queue.c **** }
 1458              		.loc 1 1349 0
 1459 0046 07F10807 		add	r7, r7, #8
 1460 004a BD46     		mov	sp, r7
 1461 004c 80BD     		pop	{r7, pc}
 1462              		.cfi_endproc
 1463              	.LFE11:
 1465 004e 00BF     		.section	.text.prvUnlockQueue,"ax",%progbits
 1466              		.align	2
 1467              		.thumb
 1468              		.thumb_func
 1470              	prvUnlockQueue:
 1471              	.LFB12:
1350:../FreeRTOS/Sources/queue.c **** /*-----------------------------------------------------------*/
1351:../FreeRTOS/Sources/queue.c **** 
1352:../FreeRTOS/Sources/queue.c **** static void prvUnlockQueue( xQUEUE *pxQueue )
1353:../FreeRTOS/Sources/queue.c **** {
 1472              		.loc 1 1353 0
 1473              		.cfi_startproc
 1474              		@ args = 0, pretend = 0, frame = 8
 1475              		@ frame_needed = 1, uses_anonymous_args = 0
 1476 0000 80B5     		push	{r7, lr}
 1477              	.LCFI36:
 1478              		.cfi_def_cfa_offset 8
 1479              		.cfi_offset 7, -8
 1480              		.cfi_offset 14, -4
 1481 0002 82B0     		sub	sp, sp, #8
 1482              	.LCFI37:
 1483              		.cfi_def_cfa_offset 16
 1484 0004 00AF     		add	r7, sp, #0
 1485              	.LCFI38:
 1486              		.cfi_def_cfa_register 7
 1487 0006 7860     		str	r0, [r7, #4]
1354:../FreeRTOS/Sources/queue.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
1355:../FreeRTOS/Sources/queue.c **** 
1356:../FreeRTOS/Sources/queue.c **** 	/* The lock counts contains the number of extra data items placed or
1357:../FreeRTOS/Sources/queue.c **** 	removed from the queue while the queue was locked.  When a queue is
1358:../FreeRTOS/Sources/queue.c **** 	locked items can be added or removed, but the event lists cannot be
1359:../FreeRTOS/Sources/queue.c **** 	updated. */
1360:../FreeRTOS/Sources/queue.c **** 	taskENTER_CRITICAL();
 1488              		.loc 1 1360 0
 1489 0008 FFF7FEFF 		bl	vPortEnterCritical
1361:../FreeRTOS/Sources/queue.c **** 	{
1362:../FreeRTOS/Sources/queue.c **** 		/* See if data was added to the queue while it was locked. */
1363:../FreeRTOS/Sources/queue.c **** 		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
 1490              		.loc 1 1363 0
 1491 000c 14E0     		b	.L106
 1492              	.L110:
1364:../FreeRTOS/Sources/queue.c **** 		{
1365:../FreeRTOS/Sources/queue.c **** 			/* Data was posted while the queue was locked.  Are any tasks
1366:../FreeRTOS/Sources/queue.c **** 			blocked waiting for data to become available? */
1367:../FreeRTOS/Sources/queue.c **** 			#if ( configUSE_QUEUE_SETS == 1 )
1368:../FreeRTOS/Sources/queue.c **** 			{
1369:../FreeRTOS/Sources/queue.c **** 				if( pxQueue->pxQueueSetContainer != NULL )
1370:../FreeRTOS/Sources/queue.c **** 				{
1371:../FreeRTOS/Sources/queue.c **** 					if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) == pdTRUE )
1372:../FreeRTOS/Sources/queue.c **** 					{
1373:../FreeRTOS/Sources/queue.c **** 						/* The queue is a member of a queue set, and posting to
1374:../FreeRTOS/Sources/queue.c **** 						the queue set caused a higher priority task to unblock.
1375:../FreeRTOS/Sources/queue.c **** 						A context switch is required. */
1376:../FreeRTOS/Sources/queue.c **** 						vTaskMissedYield();
1377:../FreeRTOS/Sources/queue.c **** 					}
1378:../FreeRTOS/Sources/queue.c **** 				}
1379:../FreeRTOS/Sources/queue.c **** 				else
1380:../FreeRTOS/Sources/queue.c **** 				{
1381:../FreeRTOS/Sources/queue.c **** 					/* Tasks that are removed from the event list will get added to
1382:../FreeRTOS/Sources/queue.c **** 					the pending ready list as the scheduler is still suspended. */
1383:../FreeRTOS/Sources/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1384:../FreeRTOS/Sources/queue.c **** 					{
1385:../FreeRTOS/Sources/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1386:../FreeRTOS/Sources/queue.c **** 						{
1387:../FreeRTOS/Sources/queue.c **** 							/* The task waiting has a higher priority so record that a
1388:../FreeRTOS/Sources/queue.c **** 							context	switch is required. */
1389:../FreeRTOS/Sources/queue.c **** 							vTaskMissedYield();
1390:../FreeRTOS/Sources/queue.c **** 						}
1391:../FreeRTOS/Sources/queue.c **** 					}
1392:../FreeRTOS/Sources/queue.c **** 					else
1393:../FreeRTOS/Sources/queue.c **** 					{
1394:../FreeRTOS/Sources/queue.c **** 						break;
1395:../FreeRTOS/Sources/queue.c **** 					}
1396:../FreeRTOS/Sources/queue.c **** 				}
1397:../FreeRTOS/Sources/queue.c **** 			}
1398:../FreeRTOS/Sources/queue.c **** 			#else /* configUSE_QUEUE_SETS */
1399:../FreeRTOS/Sources/queue.c **** 			{
1400:../FreeRTOS/Sources/queue.c **** 				/* Tasks that are removed from the event list will get added to
1401:../FreeRTOS/Sources/queue.c **** 				the pending ready list as the scheduler is still suspended. */
1402:../FreeRTOS/Sources/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 1493              		.loc 1 1402 0
 1494 000e 7B68     		ldr	r3, [r7, #4]
 1495 0010 5B6A     		ldr	r3, [r3, #36]
 1496 0012 002B     		cmp	r3, #0
 1497 0014 15D0     		beq	.L116
1403:../FreeRTOS/Sources/queue.c **** 				{
1404:../FreeRTOS/Sources/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 1498              		.loc 1 1404 0
 1499 0016 7B68     		ldr	r3, [r7, #4]
 1500 0018 03F12403 		add	r3, r3, #36
 1501 001c 1846     		mov	r0, r3
 1502 001e FFF7FEFF 		bl	xTaskRemoveFromEventList
 1503 0022 0346     		mov	r3, r0
 1504 0024 002B     		cmp	r3, #0
 1505 0026 01D0     		beq	.L108
1405:../FreeRTOS/Sources/queue.c **** 					{
1406:../FreeRTOS/Sources/queue.c **** 						/* The task waiting has a higher priority so record that a
1407:../FreeRTOS/Sources/queue.c **** 						context	switch is required. */
1408:../FreeRTOS/Sources/queue.c **** 						vTaskMissedYield();
 1506              		.loc 1 1408 0
 1507 0028 FFF7FEFF 		bl	vTaskMissedYield
 1508              	.L108:
1409:../FreeRTOS/Sources/queue.c **** 					}
1410:../FreeRTOS/Sources/queue.c **** 				}
1411:../FreeRTOS/Sources/queue.c **** 				else
1412:../FreeRTOS/Sources/queue.c **** 				{
1413:../FreeRTOS/Sources/queue.c **** 					break;
1414:../FreeRTOS/Sources/queue.c **** 				}
1415:../FreeRTOS/Sources/queue.c **** 			}
1416:../FreeRTOS/Sources/queue.c **** 			#endif /* configUSE_QUEUE_SETS */
1417:../FreeRTOS/Sources/queue.c **** 
1418:../FreeRTOS/Sources/queue.c **** 			--( pxQueue->xTxLock );
 1509              		.loc 1 1418 0
 1510 002c 7B68     		ldr	r3, [r7, #4]
 1511 002e 9B6C     		ldr	r3, [r3, #72]
 1512 0030 03F1FF32 		add	r2, r3, #-1
 1513 0034 7B68     		ldr	r3, [r7, #4]
 1514 0036 9A64     		str	r2, [r3, #72]
 1515              	.L106:
1363:../FreeRTOS/Sources/queue.c **** 		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
 1516              		.loc 1 1363 0 discriminator 1
 1517 0038 7B68     		ldr	r3, [r7, #4]
 1518 003a 9B6C     		ldr	r3, [r3, #72]
 1519 003c 002B     		cmp	r3, #0
 1520 003e E6DC     		bgt	.L110
 1521 0040 00E0     		b	.L109
 1522              	.L116:
1413:../FreeRTOS/Sources/queue.c **** 					break;
 1523              		.loc 1 1413 0
 1524 0042 00BF     		nop
 1525              	.L109:
1419:../FreeRTOS/Sources/queue.c **** 		}
1420:../FreeRTOS/Sources/queue.c **** 
1421:../FreeRTOS/Sources/queue.c **** 		pxQueue->xTxLock = queueUNLOCKED;
 1526              		.loc 1 1421 0
 1527 0044 7B68     		ldr	r3, [r7, #4]
 1528 0046 4FF0FF32 		mov	r2, #-1
 1529 004a 9A64     		str	r2, [r3, #72]
1422:../FreeRTOS/Sources/queue.c **** 	}
1423:../FreeRTOS/Sources/queue.c **** 	taskEXIT_CRITICAL();
 1530              		.loc 1 1423 0
 1531 004c FFF7FEFF 		bl	vPortExitCritical
1424:../FreeRTOS/Sources/queue.c **** 
1425:../FreeRTOS/Sources/queue.c **** 	/* Do the same for the Rx lock. */
1426:../FreeRTOS/Sources/queue.c **** 	taskENTER_CRITICAL();
 1532              		.loc 1 1426 0
 1533 0050 FFF7FEFF 		bl	vPortEnterCritical
1427:../FreeRTOS/Sources/queue.c **** 	{
1428:../FreeRTOS/Sources/queue.c **** 		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
 1534              		.loc 1 1428 0
 1535 0054 14E0     		b	.L111
 1536              	.L115:
1429:../FreeRTOS/Sources/queue.c **** 		{
1430:../FreeRTOS/Sources/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 1537              		.loc 1 1430 0
 1538 0056 7B68     		ldr	r3, [r7, #4]
 1539 0058 1B69     		ldr	r3, [r3, #16]
 1540 005a 002B     		cmp	r3, #0
 1541 005c 15D0     		beq	.L117
1431:../FreeRTOS/Sources/queue.c **** 			{
1432:../FreeRTOS/Sources/queue.c **** 				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 1542              		.loc 1 1432 0
 1543 005e 7B68     		ldr	r3, [r7, #4]
 1544 0060 03F11003 		add	r3, r3, #16
 1545 0064 1846     		mov	r0, r3
 1546 0066 FFF7FEFF 		bl	xTaskRemoveFromEventList
 1547 006a 0346     		mov	r3, r0
 1548 006c 002B     		cmp	r3, #0
 1549 006e 01D0     		beq	.L113
1433:../FreeRTOS/Sources/queue.c **** 				{
1434:../FreeRTOS/Sources/queue.c **** 					vTaskMissedYield();
 1550              		.loc 1 1434 0
 1551 0070 FFF7FEFF 		bl	vTaskMissedYield
 1552              	.L113:
1435:../FreeRTOS/Sources/queue.c **** 				}
1436:../FreeRTOS/Sources/queue.c **** 
1437:../FreeRTOS/Sources/queue.c **** 				--( pxQueue->xRxLock );
 1553              		.loc 1 1437 0
 1554 0074 7B68     		ldr	r3, [r7, #4]
 1555 0076 5B6C     		ldr	r3, [r3, #68]
 1556 0078 03F1FF32 		add	r2, r3, #-1
 1557 007c 7B68     		ldr	r3, [r7, #4]
 1558 007e 5A64     		str	r2, [r3, #68]
 1559              	.L111:
1428:../FreeRTOS/Sources/queue.c **** 		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
 1560              		.loc 1 1428 0 discriminator 1
 1561 0080 7B68     		ldr	r3, [r7, #4]
 1562 0082 5B6C     		ldr	r3, [r3, #68]
 1563 0084 002B     		cmp	r3, #0
 1564 0086 E6DC     		bgt	.L115
 1565 0088 00E0     		b	.L114
 1566              	.L117:
1438:../FreeRTOS/Sources/queue.c **** 			}
1439:../FreeRTOS/Sources/queue.c **** 			else
1440:../FreeRTOS/Sources/queue.c **** 			{
1441:../FreeRTOS/Sources/queue.c **** 				break;
 1567              		.loc 1 1441 0
 1568 008a 00BF     		nop
 1569              	.L114:
1442:../FreeRTOS/Sources/queue.c **** 			}
1443:../FreeRTOS/Sources/queue.c **** 		}
1444:../FreeRTOS/Sources/queue.c **** 
1445:../FreeRTOS/Sources/queue.c **** 		pxQueue->xRxLock = queueUNLOCKED;
 1570              		.loc 1 1445 0
 1571 008c 7B68     		ldr	r3, [r7, #4]
 1572 008e 4FF0FF32 		mov	r2, #-1
 1573 0092 5A64     		str	r2, [r3, #68]
1446:../FreeRTOS/Sources/queue.c **** 	}
1447:../FreeRTOS/Sources/queue.c **** 	taskEXIT_CRITICAL();
 1574              		.loc 1 1447 0
 1575 0094 FFF7FEFF 		bl	vPortExitCritical
1448:../FreeRTOS/Sources/queue.c **** }
 1576              		.loc 1 1448 0
 1577 0098 07F10807 		add	r7, r7, #8
 1578 009c BD46     		mov	sp, r7
 1579 009e 80BD     		pop	{r7, pc}
 1580              		.cfi_endproc
 1581              	.LFE12:
 1583              		.section	.text.prvIsQueueEmpty,"ax",%progbits
 1584              		.align	2
 1585              		.thumb
 1586              		.thumb_func
 1588              	prvIsQueueEmpty:
 1589              	.LFB13:
1449:../FreeRTOS/Sources/queue.c **** /*-----------------------------------------------------------*/
1450:../FreeRTOS/Sources/queue.c **** 
1451:../FreeRTOS/Sources/queue.c **** static signed portBASE_TYPE prvIsQueueEmpty( const xQUEUE *pxQueue )
1452:../FreeRTOS/Sources/queue.c **** {
 1590              		.loc 1 1452 0
 1591              		.cfi_startproc
 1592              		@ args = 0, pretend = 0, frame = 16
 1593              		@ frame_needed = 1, uses_anonymous_args = 0
 1594 0000 80B5     		push	{r7, lr}
 1595              	.LCFI39:
 1596              		.cfi_def_cfa_offset 8
 1597              		.cfi_offset 7, -8
 1598              		.cfi_offset 14, -4
 1599 0002 84B0     		sub	sp, sp, #16
 1600              	.LCFI40:
 1601              		.cfi_def_cfa_offset 24
 1602 0004 00AF     		add	r7, sp, #0
 1603              	.LCFI41:
 1604              		.cfi_def_cfa_register 7
 1605 0006 7860     		str	r0, [r7, #4]
1453:../FreeRTOS/Sources/queue.c **** signed portBASE_TYPE xReturn;
1454:../FreeRTOS/Sources/queue.c **** 
1455:../FreeRTOS/Sources/queue.c **** 	taskENTER_CRITICAL();
 1606              		.loc 1 1455 0
 1607 0008 FFF7FEFF 		bl	vPortEnterCritical
1456:../FreeRTOS/Sources/queue.c **** 	{
1457:../FreeRTOS/Sources/queue.c **** 		if( pxQueue->uxMessagesWaiting == 0 )
 1608              		.loc 1 1457 0
 1609 000c 7B68     		ldr	r3, [r7, #4]
 1610 000e 9B6B     		ldr	r3, [r3, #56]
 1611 0010 002B     		cmp	r3, #0
 1612 0012 03D1     		bne	.L119
1458:../FreeRTOS/Sources/queue.c **** 		{
1459:../FreeRTOS/Sources/queue.c **** 			xReturn = pdTRUE;
 1613              		.loc 1 1459 0
 1614 0014 4FF00103 		mov	r3, #1
 1615 0018 FB60     		str	r3, [r7, #12]
 1616 001a 02E0     		b	.L120
 1617              	.L119:
1460:../FreeRTOS/Sources/queue.c **** 		}
1461:../FreeRTOS/Sources/queue.c **** 		else
1462:../FreeRTOS/Sources/queue.c **** 		{
1463:../FreeRTOS/Sources/queue.c **** 			xReturn = pdFALSE;
 1618              		.loc 1 1463 0
 1619 001c 4FF00003 		mov	r3, #0
 1620 0020 FB60     		str	r3, [r7, #12]
 1621              	.L120:
1464:../FreeRTOS/Sources/queue.c **** 		}
1465:../FreeRTOS/Sources/queue.c **** 	}
1466:../FreeRTOS/Sources/queue.c **** 	taskEXIT_CRITICAL();
 1622              		.loc 1 1466 0
 1623 0022 FFF7FEFF 		bl	vPortExitCritical
1467:../FreeRTOS/Sources/queue.c **** 
1468:../FreeRTOS/Sources/queue.c **** 	return xReturn;
 1624              		.loc 1 1468 0
 1625 0026 FB68     		ldr	r3, [r7, #12]
1469:../FreeRTOS/Sources/queue.c **** }
 1626              		.loc 1 1469 0
 1627 0028 1846     		mov	r0, r3
 1628 002a 07F11007 		add	r7, r7, #16
 1629 002e BD46     		mov	sp, r7
 1630 0030 80BD     		pop	{r7, pc}
 1631              		.cfi_endproc
 1632              	.LFE13:
 1634 0032 00BF     		.section	.text.xQueueIsQueueEmptyFromISR,"ax",%progbits
 1635              		.align	2
 1636              		.global	xQueueIsQueueEmptyFromISR
 1637              		.thumb
 1638              		.thumb_func
 1640              	xQueueIsQueueEmptyFromISR:
 1641              	.LFB14:
1470:../FreeRTOS/Sources/queue.c **** /*-----------------------------------------------------------*/
1471:../FreeRTOS/Sources/queue.c **** 
1472:../FreeRTOS/Sources/queue.c **** signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle xQueue )
1473:../FreeRTOS/Sources/queue.c **** {
 1642              		.loc 1 1473 0
 1643              		.cfi_startproc
 1644              		@ args = 0, pretend = 0, frame = 16
 1645              		@ frame_needed = 1, uses_anonymous_args = 0
 1646 0000 80B5     		push	{r7, lr}
 1647              	.LCFI42:
 1648              		.cfi_def_cfa_offset 8
 1649              		.cfi_offset 7, -8
 1650              		.cfi_offset 14, -4
 1651 0002 84B0     		sub	sp, sp, #16
 1652              	.LCFI43:
 1653              		.cfi_def_cfa_offset 24
 1654 0004 00AF     		add	r7, sp, #0
 1655              	.LCFI44:
 1656              		.cfi_def_cfa_register 7
 1657 0006 7860     		str	r0, [r7, #4]
1474:../FreeRTOS/Sources/queue.c **** signed portBASE_TYPE xReturn;
1475:../FreeRTOS/Sources/queue.c **** 
1476:../FreeRTOS/Sources/queue.c **** 	configASSERT( xQueue );
 1658              		.loc 1 1476 0
 1659 0008 7B68     		ldr	r3, [r7, #4]
 1660 000a 002B     		cmp	r3, #0
 1661 000c 02D1     		bne	.L123
 1662              		.loc 1 1476 0 is_stmt 0 discriminator 1
 1663 000e FFF7FEFF 		bl	ulPortSetInterruptMask
 1664              	.L124:
 1665              		.loc 1 1476 0 discriminator 2
 1666 0012 FEE7     		b	.L124
 1667              	.L123:
1477:../FreeRTOS/Sources/queue.c **** 	if( ( ( xQUEUE * ) xQueue )->uxMessagesWaiting == 0 )
 1668              		.loc 1 1477 0 is_stmt 1
 1669 0014 7B68     		ldr	r3, [r7, #4]
 1670 0016 9B6B     		ldr	r3, [r3, #56]
 1671 0018 002B     		cmp	r3, #0
 1672 001a 03D1     		bne	.L125
1478:../FreeRTOS/Sources/queue.c **** 	{
1479:../FreeRTOS/Sources/queue.c **** 		xReturn = pdTRUE;
 1673              		.loc 1 1479 0
 1674 001c 4FF00103 		mov	r3, #1
 1675 0020 FB60     		str	r3, [r7, #12]
 1676 0022 02E0     		b	.L126
 1677              	.L125:
1480:../FreeRTOS/Sources/queue.c **** 	}
1481:../FreeRTOS/Sources/queue.c **** 	else
1482:../FreeRTOS/Sources/queue.c **** 	{
1483:../FreeRTOS/Sources/queue.c **** 		xReturn = pdFALSE;
 1678              		.loc 1 1483 0
 1679 0024 4FF00003 		mov	r3, #0
 1680 0028 FB60     		str	r3, [r7, #12]
 1681              	.L126:
1484:../FreeRTOS/Sources/queue.c **** 	}
1485:../FreeRTOS/Sources/queue.c **** 
1486:../FreeRTOS/Sources/queue.c **** 	return xReturn;
 1682              		.loc 1 1486 0
 1683 002a FB68     		ldr	r3, [r7, #12]
1487:../FreeRTOS/Sources/queue.c **** }
 1684              		.loc 1 1487 0
 1685 002c 1846     		mov	r0, r3
 1686 002e 07F11007 		add	r7, r7, #16
 1687 0032 BD46     		mov	sp, r7
 1688 0034 80BD     		pop	{r7, pc}
 1689              		.cfi_endproc
 1690              	.LFE14:
 1692 0036 00BF     		.section	.text.prvIsQueueFull,"ax",%progbits
 1693              		.align	2
 1694              		.thumb
 1695              		.thumb_func
 1697              	prvIsQueueFull:
 1698              	.LFB15:
1488:../FreeRTOS/Sources/queue.c **** /*-----------------------------------------------------------*/
1489:../FreeRTOS/Sources/queue.c **** 
1490:../FreeRTOS/Sources/queue.c **** static signed portBASE_TYPE prvIsQueueFull( const xQUEUE *pxQueue )
1491:../FreeRTOS/Sources/queue.c **** {
 1699              		.loc 1 1491 0
 1700              		.cfi_startproc
 1701              		@ args = 0, pretend = 0, frame = 16
 1702              		@ frame_needed = 1, uses_anonymous_args = 0
 1703 0000 80B5     		push	{r7, lr}
 1704              	.LCFI45:
 1705              		.cfi_def_cfa_offset 8
 1706              		.cfi_offset 7, -8
 1707              		.cfi_offset 14, -4
 1708 0002 84B0     		sub	sp, sp, #16
 1709              	.LCFI46:
 1710              		.cfi_def_cfa_offset 24
 1711 0004 00AF     		add	r7, sp, #0
 1712              	.LCFI47:
 1713              		.cfi_def_cfa_register 7
 1714 0006 7860     		str	r0, [r7, #4]
1492:../FreeRTOS/Sources/queue.c **** signed portBASE_TYPE xReturn;
1493:../FreeRTOS/Sources/queue.c **** 
1494:../FreeRTOS/Sources/queue.c **** 	taskENTER_CRITICAL();
 1715              		.loc 1 1494 0
 1716 0008 FFF7FEFF 		bl	vPortEnterCritical
1495:../FreeRTOS/Sources/queue.c **** 	{
1496:../FreeRTOS/Sources/queue.c **** 		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 1717              		.loc 1 1496 0
 1718 000c 7B68     		ldr	r3, [r7, #4]
 1719 000e 9A6B     		ldr	r2, [r3, #56]
 1720 0010 7B68     		ldr	r3, [r7, #4]
 1721 0012 DB6B     		ldr	r3, [r3, #60]
 1722 0014 9A42     		cmp	r2, r3
 1723 0016 03D1     		bne	.L129
1497:../FreeRTOS/Sources/queue.c **** 		{
1498:../FreeRTOS/Sources/queue.c **** 			xReturn = pdTRUE;
 1724              		.loc 1 1498 0
 1725 0018 4FF00103 		mov	r3, #1
 1726 001c FB60     		str	r3, [r7, #12]
 1727 001e 02E0     		b	.L130
 1728              	.L129:
1499:../FreeRTOS/Sources/queue.c **** 		}
1500:../FreeRTOS/Sources/queue.c **** 		else
1501:../FreeRTOS/Sources/queue.c **** 		{
1502:../FreeRTOS/Sources/queue.c **** 			xReturn = pdFALSE;
 1729              		.loc 1 1502 0
 1730 0020 4FF00003 		mov	r3, #0
 1731 0024 FB60     		str	r3, [r7, #12]
 1732              	.L130:
1503:../FreeRTOS/Sources/queue.c **** 		}
1504:../FreeRTOS/Sources/queue.c **** 	}
1505:../FreeRTOS/Sources/queue.c **** 	taskEXIT_CRITICAL();
 1733              		.loc 1 1505 0
 1734 0026 FFF7FEFF 		bl	vPortExitCritical
1506:../FreeRTOS/Sources/queue.c **** 
1507:../FreeRTOS/Sources/queue.c **** 	return xReturn;
 1735              		.loc 1 1507 0
 1736 002a FB68     		ldr	r3, [r7, #12]
1508:../FreeRTOS/Sources/queue.c **** }
 1737              		.loc 1 1508 0
 1738 002c 1846     		mov	r0, r3
 1739 002e 07F11007 		add	r7, r7, #16
 1740 0032 BD46     		mov	sp, r7
 1741 0034 80BD     		pop	{r7, pc}
 1742              		.cfi_endproc
 1743              	.LFE15:
 1745 0036 00BF     		.section	.text.xQueueIsQueueFullFromISR,"ax",%progbits
 1746              		.align	2
 1747              		.global	xQueueIsQueueFullFromISR
 1748              		.thumb
 1749              		.thumb_func
 1751              	xQueueIsQueueFullFromISR:
 1752              	.LFB16:
1509:../FreeRTOS/Sources/queue.c **** /*-----------------------------------------------------------*/
1510:../FreeRTOS/Sources/queue.c **** 
1511:../FreeRTOS/Sources/queue.c **** signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle xQueue )
1512:../FreeRTOS/Sources/queue.c **** {
 1753              		.loc 1 1512 0
 1754              		.cfi_startproc
 1755              		@ args = 0, pretend = 0, frame = 16
 1756              		@ frame_needed = 1, uses_anonymous_args = 0
 1757 0000 80B5     		push	{r7, lr}
 1758              	.LCFI48:
 1759              		.cfi_def_cfa_offset 8
 1760              		.cfi_offset 7, -8
 1761              		.cfi_offset 14, -4
 1762 0002 84B0     		sub	sp, sp, #16
 1763              	.LCFI49:
 1764              		.cfi_def_cfa_offset 24
 1765 0004 00AF     		add	r7, sp, #0
 1766              	.LCFI50:
 1767              		.cfi_def_cfa_register 7
 1768 0006 7860     		str	r0, [r7, #4]
1513:../FreeRTOS/Sources/queue.c **** signed portBASE_TYPE xReturn;
1514:../FreeRTOS/Sources/queue.c **** 
1515:../FreeRTOS/Sources/queue.c **** 	configASSERT( xQueue );
 1769              		.loc 1 1515 0
 1770 0008 7B68     		ldr	r3, [r7, #4]
 1771 000a 002B     		cmp	r3, #0
 1772 000c 02D1     		bne	.L133
 1773              		.loc 1 1515 0 is_stmt 0 discriminator 1
 1774 000e FFF7FEFF 		bl	ulPortSetInterruptMask
 1775              	.L134:
 1776              		.loc 1 1515 0 discriminator 2
 1777 0012 FEE7     		b	.L134
 1778              	.L133:
1516:../FreeRTOS/Sources/queue.c **** 	if( ( ( xQUEUE * ) xQueue )->uxMessagesWaiting == ( ( xQUEUE * ) xQueue )->uxLength )
 1779              		.loc 1 1516 0 is_stmt 1
 1780 0014 7B68     		ldr	r3, [r7, #4]
 1781 0016 9A6B     		ldr	r2, [r3, #56]
 1782 0018 7B68     		ldr	r3, [r7, #4]
 1783 001a DB6B     		ldr	r3, [r3, #60]
 1784 001c 9A42     		cmp	r2, r3
 1785 001e 03D1     		bne	.L135
1517:../FreeRTOS/Sources/queue.c **** 	{
1518:../FreeRTOS/Sources/queue.c **** 		xReturn = pdTRUE;
 1786              		.loc 1 1518 0
 1787 0020 4FF00103 		mov	r3, #1
 1788 0024 FB60     		str	r3, [r7, #12]
 1789 0026 02E0     		b	.L136
 1790              	.L135:
1519:../FreeRTOS/Sources/queue.c **** 	}
1520:../FreeRTOS/Sources/queue.c **** 	else
1521:../FreeRTOS/Sources/queue.c **** 	{
1522:../FreeRTOS/Sources/queue.c **** 		xReturn = pdFALSE;
 1791              		.loc 1 1522 0
 1792 0028 4FF00003 		mov	r3, #0
 1793 002c FB60     		str	r3, [r7, #12]
 1794              	.L136:
1523:../FreeRTOS/Sources/queue.c **** 	}
1524:../FreeRTOS/Sources/queue.c **** 
1525:../FreeRTOS/Sources/queue.c **** 	return xReturn;
 1795              		.loc 1 1525 0
 1796 002e FB68     		ldr	r3, [r7, #12]
1526:../FreeRTOS/Sources/queue.c **** }
 1797              		.loc 1 1526 0
 1798 0030 1846     		mov	r0, r3
 1799 0032 07F11007 		add	r7, r7, #16
 1800 0036 BD46     		mov	sp, r7
 1801 0038 80BD     		pop	{r7, pc}
 1802              		.cfi_endproc
 1803              	.LFE16:
 1805 003a 00BF     		.section	.text.vQueueWaitForMessageRestricted,"ax",%progbits
 1806              		.align	2
 1807              		.global	vQueueWaitForMessageRestricted
 1808              		.thumb
 1809              		.thumb_func
 1811              	vQueueWaitForMessageRestricted:
 1812              	.LFB17:
1527:../FreeRTOS/Sources/queue.c **** /*-----------------------------------------------------------*/
1528:../FreeRTOS/Sources/queue.c **** 
1529:../FreeRTOS/Sources/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
1530:../FreeRTOS/Sources/queue.c **** 
1531:../FreeRTOS/Sources/queue.c **** 	signed portBASE_TYPE xQueueCRSend( xQueueHandle xQueue, const void *pvItemToQueue, portTickType xT
1532:../FreeRTOS/Sources/queue.c **** 	{
1533:../FreeRTOS/Sources/queue.c **** 	signed portBASE_TYPE xReturn;
1534:../FreeRTOS/Sources/queue.c **** 	xQUEUE *pxQueue;
1535:../FreeRTOS/Sources/queue.c **** 
1536:../FreeRTOS/Sources/queue.c **** 		pxQueue = ( xQUEUE * ) xQueue;
1537:../FreeRTOS/Sources/queue.c **** 
1538:../FreeRTOS/Sources/queue.c **** 		/* If the queue is already full we may have to block.  A critical section
1539:../FreeRTOS/Sources/queue.c **** 		is required to prevent an interrupt removing something from the queue
1540:../FreeRTOS/Sources/queue.c **** 		between the check to see if the queue is full and blocking on the queue. */
1541:../FreeRTOS/Sources/queue.c **** 		portDISABLE_INTERRUPTS();
1542:../FreeRTOS/Sources/queue.c **** 		{
1543:../FreeRTOS/Sources/queue.c **** 			if( prvIsQueueFull( pxQueue ) != pdFALSE )
1544:../FreeRTOS/Sources/queue.c **** 			{
1545:../FreeRTOS/Sources/queue.c **** 				/* The queue is full - do we want to block or just leave without
1546:../FreeRTOS/Sources/queue.c **** 				posting? */
1547:../FreeRTOS/Sources/queue.c **** 				if( xTicksToWait > ( portTickType ) 0 )
1548:../FreeRTOS/Sources/queue.c **** 				{
1549:../FreeRTOS/Sources/queue.c **** 					/* As this is called from a coroutine we cannot block directly, but
1550:../FreeRTOS/Sources/queue.c **** 					return indicating that we need to block. */
1551:../FreeRTOS/Sources/queue.c **** 					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
1552:../FreeRTOS/Sources/queue.c **** 					portENABLE_INTERRUPTS();
1553:../FreeRTOS/Sources/queue.c **** 					return errQUEUE_BLOCKED;
1554:../FreeRTOS/Sources/queue.c **** 				}
1555:../FreeRTOS/Sources/queue.c **** 				else
1556:../FreeRTOS/Sources/queue.c **** 				{
1557:../FreeRTOS/Sources/queue.c **** 					portENABLE_INTERRUPTS();
1558:../FreeRTOS/Sources/queue.c **** 					return errQUEUE_FULL;
1559:../FreeRTOS/Sources/queue.c **** 				}
1560:../FreeRTOS/Sources/queue.c **** 			}
1561:../FreeRTOS/Sources/queue.c **** 		}
1562:../FreeRTOS/Sources/queue.c **** 		portENABLE_INTERRUPTS();
1563:../FreeRTOS/Sources/queue.c **** 
1564:../FreeRTOS/Sources/queue.c **** 		portDISABLE_INTERRUPTS();
1565:../FreeRTOS/Sources/queue.c **** 		{
1566:../FreeRTOS/Sources/queue.c **** 			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
1567:../FreeRTOS/Sources/queue.c **** 			{
1568:../FreeRTOS/Sources/queue.c **** 				/* There is room in the queue, copy the data into the queue. */
1569:../FreeRTOS/Sources/queue.c **** 				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
1570:../FreeRTOS/Sources/queue.c **** 				xReturn = pdPASS;
1571:../FreeRTOS/Sources/queue.c **** 
1572:../FreeRTOS/Sources/queue.c **** 				/* Were any co-routines waiting for data to become available? */
1573:../FreeRTOS/Sources/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1574:../FreeRTOS/Sources/queue.c **** 				{
1575:../FreeRTOS/Sources/queue.c **** 					/* In this instance the co-routine could be placed directly
1576:../FreeRTOS/Sources/queue.c **** 					into the ready list as we are within a critical section.
1577:../FreeRTOS/Sources/queue.c **** 					Instead the same pending ready list mechanism is used as if
1578:../FreeRTOS/Sources/queue.c **** 					the event were caused from within an interrupt. */
1579:../FreeRTOS/Sources/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1580:../FreeRTOS/Sources/queue.c **** 					{
1581:../FreeRTOS/Sources/queue.c **** 						/* The co-routine waiting has a higher priority so record
1582:../FreeRTOS/Sources/queue.c **** 						that a yield might be appropriate. */
1583:../FreeRTOS/Sources/queue.c **** 						xReturn = errQUEUE_YIELD;
1584:../FreeRTOS/Sources/queue.c **** 					}
1585:../FreeRTOS/Sources/queue.c **** 				}
1586:../FreeRTOS/Sources/queue.c **** 			}
1587:../FreeRTOS/Sources/queue.c **** 			else
1588:../FreeRTOS/Sources/queue.c **** 			{
1589:../FreeRTOS/Sources/queue.c **** 				xReturn = errQUEUE_FULL;
1590:../FreeRTOS/Sources/queue.c **** 			}
1591:../FreeRTOS/Sources/queue.c **** 		}
1592:../FreeRTOS/Sources/queue.c **** 		portENABLE_INTERRUPTS();
1593:../FreeRTOS/Sources/queue.c **** 
1594:../FreeRTOS/Sources/queue.c **** 		return xReturn;
1595:../FreeRTOS/Sources/queue.c **** 	}
1596:../FreeRTOS/Sources/queue.c **** 
1597:../FreeRTOS/Sources/queue.c **** #endif /* configUSE_CO_ROUTINES */
1598:../FreeRTOS/Sources/queue.c **** /*-----------------------------------------------------------*/
1599:../FreeRTOS/Sources/queue.c **** 
1600:../FreeRTOS/Sources/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
1601:../FreeRTOS/Sources/queue.c **** 
1602:../FreeRTOS/Sources/queue.c **** 	signed portBASE_TYPE xQueueCRReceive( xQueueHandle xQueue, void *pvBuffer, portTickType xTicksToWa
1603:../FreeRTOS/Sources/queue.c **** 	{
1604:../FreeRTOS/Sources/queue.c **** 	signed portBASE_TYPE xReturn;
1605:../FreeRTOS/Sources/queue.c **** 	xQUEUE *pxQueue;
1606:../FreeRTOS/Sources/queue.c **** 
1607:../FreeRTOS/Sources/queue.c **** 		pxQueue = ( xQUEUE * ) xQueue;
1608:../FreeRTOS/Sources/queue.c **** 
1609:../FreeRTOS/Sources/queue.c **** 		/* If the queue is already empty we may have to block.  A critical section
1610:../FreeRTOS/Sources/queue.c **** 		is required to prevent an interrupt adding something to the queue
1611:../FreeRTOS/Sources/queue.c **** 		between the check to see if the queue is empty and blocking on the queue. */
1612:../FreeRTOS/Sources/queue.c **** 		portDISABLE_INTERRUPTS();
1613:../FreeRTOS/Sources/queue.c **** 		{
1614:../FreeRTOS/Sources/queue.c **** 			if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 )
1615:../FreeRTOS/Sources/queue.c **** 			{
1616:../FreeRTOS/Sources/queue.c **** 				/* There are no messages in the queue, do we want to block or just
1617:../FreeRTOS/Sources/queue.c **** 				leave with nothing? */
1618:../FreeRTOS/Sources/queue.c **** 				if( xTicksToWait > ( portTickType ) 0 )
1619:../FreeRTOS/Sources/queue.c **** 				{
1620:../FreeRTOS/Sources/queue.c **** 					/* As this is a co-routine we cannot block directly, but return
1621:../FreeRTOS/Sources/queue.c **** 					indicating that we need to block. */
1622:../FreeRTOS/Sources/queue.c **** 					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
1623:../FreeRTOS/Sources/queue.c **** 					portENABLE_INTERRUPTS();
1624:../FreeRTOS/Sources/queue.c **** 					return errQUEUE_BLOCKED;
1625:../FreeRTOS/Sources/queue.c **** 				}
1626:../FreeRTOS/Sources/queue.c **** 				else
1627:../FreeRTOS/Sources/queue.c **** 				{
1628:../FreeRTOS/Sources/queue.c **** 					portENABLE_INTERRUPTS();
1629:../FreeRTOS/Sources/queue.c **** 					return errQUEUE_FULL;
1630:../FreeRTOS/Sources/queue.c **** 				}
1631:../FreeRTOS/Sources/queue.c **** 			}
1632:../FreeRTOS/Sources/queue.c **** 		}
1633:../FreeRTOS/Sources/queue.c **** 		portENABLE_INTERRUPTS();
1634:../FreeRTOS/Sources/queue.c **** 
1635:../FreeRTOS/Sources/queue.c **** 		portDISABLE_INTERRUPTS();
1636:../FreeRTOS/Sources/queue.c **** 		{
1637:../FreeRTOS/Sources/queue.c **** 			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
1638:../FreeRTOS/Sources/queue.c **** 			{
1639:../FreeRTOS/Sources/queue.c **** 				/* Data is available from the queue. */
1640:../FreeRTOS/Sources/queue.c **** 				pxQueue->pcReadFrom += pxQueue->uxItemSize;
1641:../FreeRTOS/Sources/queue.c **** 				if( pxQueue->pcReadFrom >= pxQueue->pcTail )
1642:../FreeRTOS/Sources/queue.c **** 				{
1643:../FreeRTOS/Sources/queue.c **** 					pxQueue->pcReadFrom = pxQueue->pcHead;
1644:../FreeRTOS/Sources/queue.c **** 				}
1645:../FreeRTOS/Sources/queue.c **** 				--( pxQueue->uxMessagesWaiting );
1646:../FreeRTOS/Sources/queue.c **** 				memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize )
1647:../FreeRTOS/Sources/queue.c **** 
1648:../FreeRTOS/Sources/queue.c **** 				xReturn = pdPASS;
1649:../FreeRTOS/Sources/queue.c **** 
1650:../FreeRTOS/Sources/queue.c **** 				/* Were any co-routines waiting for space to become available? */
1651:../FreeRTOS/Sources/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
1652:../FreeRTOS/Sources/queue.c **** 				{
1653:../FreeRTOS/Sources/queue.c **** 					/* In this instance the co-routine could be placed directly
1654:../FreeRTOS/Sources/queue.c **** 					into the ready list as we are within a critical section.
1655:../FreeRTOS/Sources/queue.c **** 					Instead the same pending ready list mechanism is used as if
1656:../FreeRTOS/Sources/queue.c **** 					the event were caused from within an interrupt. */
1657:../FreeRTOS/Sources/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
1658:../FreeRTOS/Sources/queue.c **** 					{
1659:../FreeRTOS/Sources/queue.c **** 						xReturn = errQUEUE_YIELD;
1660:../FreeRTOS/Sources/queue.c **** 					}
1661:../FreeRTOS/Sources/queue.c **** 				}
1662:../FreeRTOS/Sources/queue.c **** 			}
1663:../FreeRTOS/Sources/queue.c **** 			else
1664:../FreeRTOS/Sources/queue.c **** 			{
1665:../FreeRTOS/Sources/queue.c **** 				xReturn = pdFAIL;
1666:../FreeRTOS/Sources/queue.c **** 			}
1667:../FreeRTOS/Sources/queue.c **** 		}
1668:../FreeRTOS/Sources/queue.c **** 		portENABLE_INTERRUPTS();
1669:../FreeRTOS/Sources/queue.c **** 
1670:../FreeRTOS/Sources/queue.c **** 		return xReturn;
1671:../FreeRTOS/Sources/queue.c **** 	}
1672:../FreeRTOS/Sources/queue.c **** 
1673:../FreeRTOS/Sources/queue.c **** #endif /* configUSE_CO_ROUTINES */
1674:../FreeRTOS/Sources/queue.c **** /*-----------------------------------------------------------*/
1675:../FreeRTOS/Sources/queue.c **** 
1676:../FreeRTOS/Sources/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
1677:../FreeRTOS/Sources/queue.c **** 
1678:../FreeRTOS/Sources/queue.c **** 	signed portBASE_TYPE xQueueCRSendFromISR( xQueueHandle xQueue, const void *pvItemToQueue, signed p
1679:../FreeRTOS/Sources/queue.c **** 	{
1680:../FreeRTOS/Sources/queue.c **** 	xQUEUE *pxQueue;
1681:../FreeRTOS/Sources/queue.c **** 
1682:../FreeRTOS/Sources/queue.c **** 		pxQueue = ( xQUEUE * ) xQueue;
1683:../FreeRTOS/Sources/queue.c **** 
1684:../FreeRTOS/Sources/queue.c **** 		/* Cannot block within an ISR so if there is no space on the queue then
1685:../FreeRTOS/Sources/queue.c **** 		exit without doing anything. */
1686:../FreeRTOS/Sources/queue.c **** 		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
1687:../FreeRTOS/Sources/queue.c **** 		{
1688:../FreeRTOS/Sources/queue.c **** 			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
1689:../FreeRTOS/Sources/queue.c **** 
1690:../FreeRTOS/Sources/queue.c **** 			/* We only want to wake one co-routine per ISR, so check that a
1691:../FreeRTOS/Sources/queue.c **** 			co-routine has not already been woken. */
1692:../FreeRTOS/Sources/queue.c **** 			if( xCoRoutinePreviouslyWoken == pdFALSE )
1693:../FreeRTOS/Sources/queue.c **** 			{
1694:../FreeRTOS/Sources/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1695:../FreeRTOS/Sources/queue.c **** 				{
1696:../FreeRTOS/Sources/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1697:../FreeRTOS/Sources/queue.c **** 					{
1698:../FreeRTOS/Sources/queue.c **** 						return pdTRUE;
1699:../FreeRTOS/Sources/queue.c **** 					}
1700:../FreeRTOS/Sources/queue.c **** 				}
1701:../FreeRTOS/Sources/queue.c **** 			}
1702:../FreeRTOS/Sources/queue.c **** 		}
1703:../FreeRTOS/Sources/queue.c **** 
1704:../FreeRTOS/Sources/queue.c **** 		return xCoRoutinePreviouslyWoken;
1705:../FreeRTOS/Sources/queue.c **** 	}
1706:../FreeRTOS/Sources/queue.c **** 
1707:../FreeRTOS/Sources/queue.c **** #endif /* configUSE_CO_ROUTINES */
1708:../FreeRTOS/Sources/queue.c **** /*-----------------------------------------------------------*/
1709:../FreeRTOS/Sources/queue.c **** 
1710:../FreeRTOS/Sources/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
1711:../FreeRTOS/Sources/queue.c **** 
1712:../FreeRTOS/Sources/queue.c **** 	signed portBASE_TYPE xQueueCRReceiveFromISR( xQueueHandle xQueue, void *pvBuffer, signed portBASE_
1713:../FreeRTOS/Sources/queue.c **** 	{
1714:../FreeRTOS/Sources/queue.c **** 	signed portBASE_TYPE xReturn;
1715:../FreeRTOS/Sources/queue.c **** 	xQUEUE * pxQueue;
1716:../FreeRTOS/Sources/queue.c **** 
1717:../FreeRTOS/Sources/queue.c **** 		pxQueue = ( xQUEUE * ) xQueue;
1718:../FreeRTOS/Sources/queue.c **** 
1719:../FreeRTOS/Sources/queue.c **** 		/* We cannot block from an ISR, so check there is data available. If
1720:../FreeRTOS/Sources/queue.c **** 		not then just leave without doing anything. */
1721:../FreeRTOS/Sources/queue.c **** 		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
1722:../FreeRTOS/Sources/queue.c **** 		{
1723:../FreeRTOS/Sources/queue.c **** 			/* Copy the data from the queue. */
1724:../FreeRTOS/Sources/queue.c **** 			pxQueue->pcReadFrom += pxQueue->uxItemSize;
1725:../FreeRTOS/Sources/queue.c **** 			if( pxQueue->pcReadFrom >= pxQueue->pcTail )
1726:../FreeRTOS/Sources/queue.c **** 			{
1727:../FreeRTOS/Sources/queue.c **** 				pxQueue->pcReadFrom = pxQueue->pcHead;
1728:../FreeRTOS/Sources/queue.c **** 			}
1729:../FreeRTOS/Sources/queue.c **** 			--( pxQueue->uxMessagesWaiting );
1730:../FreeRTOS/Sources/queue.c **** 			memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
1731:../FreeRTOS/Sources/queue.c **** 
1732:../FreeRTOS/Sources/queue.c **** 			if( ( *pxCoRoutineWoken ) == pdFALSE )
1733:../FreeRTOS/Sources/queue.c **** 			{
1734:../FreeRTOS/Sources/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
1735:../FreeRTOS/Sources/queue.c **** 				{
1736:../FreeRTOS/Sources/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
1737:../FreeRTOS/Sources/queue.c **** 					{
1738:../FreeRTOS/Sources/queue.c **** 						*pxCoRoutineWoken = pdTRUE;
1739:../FreeRTOS/Sources/queue.c **** 					}
1740:../FreeRTOS/Sources/queue.c **** 				}
1741:../FreeRTOS/Sources/queue.c **** 			}
1742:../FreeRTOS/Sources/queue.c **** 
1743:../FreeRTOS/Sources/queue.c **** 			xReturn = pdPASS;
1744:../FreeRTOS/Sources/queue.c **** 		}
1745:../FreeRTOS/Sources/queue.c **** 		else
1746:../FreeRTOS/Sources/queue.c **** 		{
1747:../FreeRTOS/Sources/queue.c **** 			xReturn = pdFAIL;
1748:../FreeRTOS/Sources/queue.c **** 		}
1749:../FreeRTOS/Sources/queue.c **** 
1750:../FreeRTOS/Sources/queue.c **** 		return xReturn;
1751:../FreeRTOS/Sources/queue.c **** 	}
1752:../FreeRTOS/Sources/queue.c **** 
1753:../FreeRTOS/Sources/queue.c **** #endif /* configUSE_CO_ROUTINES */
1754:../FreeRTOS/Sources/queue.c **** /*-----------------------------------------------------------*/
1755:../FreeRTOS/Sources/queue.c **** 
1756:../FreeRTOS/Sources/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
1757:../FreeRTOS/Sources/queue.c **** 
1758:../FreeRTOS/Sources/queue.c **** 	void vQueueAddToRegistry( xQueueHandle xQueue, signed char *pcQueueName )
1759:../FreeRTOS/Sources/queue.c **** 	{
1760:../FreeRTOS/Sources/queue.c **** 	unsigned portBASE_TYPE ux;
1761:../FreeRTOS/Sources/queue.c **** 
1762:../FreeRTOS/Sources/queue.c **** 		/* See if there is an empty space in the registry.  A NULL name denotes
1763:../FreeRTOS/Sources/queue.c **** 		a free slot. */
1764:../FreeRTOS/Sources/queue.c **** 		for( ux = ( unsigned portBASE_TYPE ) 0U; ux < ( unsigned portBASE_TYPE ) configQUEUE_REGISTRY_SIZ
1765:../FreeRTOS/Sources/queue.c **** 		{
1766:../FreeRTOS/Sources/queue.c **** 			if( xQueueRegistry[ ux ].pcQueueName == NULL )
1767:../FreeRTOS/Sources/queue.c **** 			{
1768:../FreeRTOS/Sources/queue.c **** 				/* Store the information on this queue. */
1769:../FreeRTOS/Sources/queue.c **** 				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
1770:../FreeRTOS/Sources/queue.c **** 				xQueueRegistry[ ux ].xHandle = xQueue;
1771:../FreeRTOS/Sources/queue.c **** 				break;
1772:../FreeRTOS/Sources/queue.c **** 			}
1773:../FreeRTOS/Sources/queue.c **** 		}
1774:../FreeRTOS/Sources/queue.c **** 	}
1775:../FreeRTOS/Sources/queue.c **** 
1776:../FreeRTOS/Sources/queue.c **** #endif /* configQUEUE_REGISTRY_SIZE */
1777:../FreeRTOS/Sources/queue.c **** /*-----------------------------------------------------------*/
1778:../FreeRTOS/Sources/queue.c **** 
1779:../FreeRTOS/Sources/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
1780:../FreeRTOS/Sources/queue.c **** 
1781:../FreeRTOS/Sources/queue.c **** 	static void prvQueueUnregisterQueue( xQueueHandle xQueue )
1782:../FreeRTOS/Sources/queue.c **** 	{
1783:../FreeRTOS/Sources/queue.c **** 	unsigned portBASE_TYPE ux;
1784:../FreeRTOS/Sources/queue.c **** 
1785:../FreeRTOS/Sources/queue.c **** 		/* See if the handle of the queue being unregistered in actually in the
1786:../FreeRTOS/Sources/queue.c **** 		registry. */
1787:../FreeRTOS/Sources/queue.c **** 		for( ux = ( unsigned portBASE_TYPE ) 0U; ux < ( unsigned portBASE_TYPE ) configQUEUE_REGISTRY_SIZ
1788:../FreeRTOS/Sources/queue.c **** 		{
1789:../FreeRTOS/Sources/queue.c **** 			if( xQueueRegistry[ ux ].xHandle == xQueue )
1790:../FreeRTOS/Sources/queue.c **** 			{
1791:../FreeRTOS/Sources/queue.c **** 				/* Set the name to NULL to show that this slot if free again. */
1792:../FreeRTOS/Sources/queue.c **** 				xQueueRegistry[ ux ].pcQueueName = NULL;
1793:../FreeRTOS/Sources/queue.c **** 				break;
1794:../FreeRTOS/Sources/queue.c **** 			}
1795:../FreeRTOS/Sources/queue.c **** 		}
1796:../FreeRTOS/Sources/queue.c **** 
1797:../FreeRTOS/Sources/queue.c **** 	}
1798:../FreeRTOS/Sources/queue.c **** 
1799:../FreeRTOS/Sources/queue.c **** #endif /* configQUEUE_REGISTRY_SIZE */
1800:../FreeRTOS/Sources/queue.c **** /*-----------------------------------------------------------*/
1801:../FreeRTOS/Sources/queue.c **** 
1802:../FreeRTOS/Sources/queue.c **** #if ( configUSE_TIMERS == 1 )
1803:../FreeRTOS/Sources/queue.c **** 
1804:../FreeRTOS/Sources/queue.c **** 	void vQueueWaitForMessageRestricted( xQueueHandle xQueue, portTickType xTicksToWait )
1805:../FreeRTOS/Sources/queue.c **** 	{
 1813              		.loc 1 1805 0
 1814              		.cfi_startproc
 1815              		@ args = 0, pretend = 0, frame = 16
 1816              		@ frame_needed = 1, uses_anonymous_args = 0
 1817 0000 80B5     		push	{r7, lr}
 1818              	.LCFI51:
 1819              		.cfi_def_cfa_offset 8
 1820              		.cfi_offset 7, -8
 1821              		.cfi_offset 14, -4
 1822 0002 84B0     		sub	sp, sp, #16
 1823              	.LCFI52:
 1824              		.cfi_def_cfa_offset 24
 1825 0004 00AF     		add	r7, sp, #0
 1826              	.LCFI53:
 1827              		.cfi_def_cfa_register 7
 1828 0006 7860     		str	r0, [r7, #4]
 1829 0008 3960     		str	r1, [r7, #0]
1806:../FreeRTOS/Sources/queue.c **** 	xQUEUE *pxQueue;
1807:../FreeRTOS/Sources/queue.c **** 
1808:../FreeRTOS/Sources/queue.c **** 		pxQueue = ( xQUEUE * ) xQueue;
 1830              		.loc 1 1808 0
 1831 000a 7B68     		ldr	r3, [r7, #4]
 1832 000c FB60     		str	r3, [r7, #12]
1809:../FreeRTOS/Sources/queue.c **** 
1810:../FreeRTOS/Sources/queue.c **** 		/* This function should not be called by application code hence the
1811:../FreeRTOS/Sources/queue.c **** 		'Restricted' in its name.  It is not part of the public API.  It is
1812:../FreeRTOS/Sources/queue.c **** 		designed for use by kernel code, and has special calling requirements.
1813:../FreeRTOS/Sources/queue.c **** 		It can result in vListInsert() being called on a list that can only
1814:../FreeRTOS/Sources/queue.c **** 		possibly ever have one item in it, so the list will be fast, but even
1815:../FreeRTOS/Sources/queue.c **** 		so it should be called with the scheduler locked and not from a critical
1816:../FreeRTOS/Sources/queue.c **** 		section. */
1817:../FreeRTOS/Sources/queue.c **** 
1818:../FreeRTOS/Sources/queue.c **** 		/* Only do anything if there are no messages in the queue.  This function
1819:../FreeRTOS/Sources/queue.c **** 		will not actually cause the task to block, just place it on a blocked
1820:../FreeRTOS/Sources/queue.c **** 		list.  It will not block until the scheduler is unlocked - at which
1821:../FreeRTOS/Sources/queue.c **** 		time a yield will be performed.  If an item is added to the queue while
1822:../FreeRTOS/Sources/queue.c **** 		the queue is locked, and the calling task blocks on the queue, then the
1823:../FreeRTOS/Sources/queue.c **** 		calling task will be immediately unblocked when the queue is unlocked. */
1824:../FreeRTOS/Sources/queue.c **** 		prvLockQueue( pxQueue );
 1833              		.loc 1 1824 0
 1834 000e FFF7FEFF 		bl	vPortEnterCritical
 1835 0012 FB68     		ldr	r3, [r7, #12]
 1836 0014 5B6C     		ldr	r3, [r3, #68]
 1837 0016 B3F1FF3F 		cmp	r3, #-1
 1838 001a 03D1     		bne	.L139
 1839              		.loc 1 1824 0 is_stmt 0 discriminator 1
 1840 001c FB68     		ldr	r3, [r7, #12]
 1841 001e 4FF00002 		mov	r2, #0
 1842 0022 5A64     		str	r2, [r3, #68]
 1843              	.L139:
 1844              		.loc 1 1824 0 discriminator 2
 1845 0024 FB68     		ldr	r3, [r7, #12]
 1846 0026 9B6C     		ldr	r3, [r3, #72]
 1847 0028 B3F1FF3F 		cmp	r3, #-1
 1848 002c 03D1     		bne	.L140
 1849              		.loc 1 1824 0 discriminator 3
 1850 002e FB68     		ldr	r3, [r7, #12]
 1851 0030 4FF00002 		mov	r2, #0
 1852 0034 9A64     		str	r2, [r3, #72]
 1853              	.L140:
 1854              		.loc 1 1824 0 discriminator 4
 1855 0036 FFF7FEFF 		bl	vPortExitCritical
1825:../FreeRTOS/Sources/queue.c **** 		if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0U )
 1856              		.loc 1 1825 0 is_stmt 1 discriminator 4
 1857 003a FB68     		ldr	r3, [r7, #12]
 1858 003c 9B6B     		ldr	r3, [r3, #56]
 1859 003e 002B     		cmp	r3, #0
 1860 0040 06D1     		bne	.L141
1826:../FreeRTOS/Sources/queue.c **** 		{
1827:../FreeRTOS/Sources/queue.c **** 			/* There is nothing in the queue, block for the specified period. */
1828:../FreeRTOS/Sources/queue.c **** 			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 1861              		.loc 1 1828 0
 1862 0042 FB68     		ldr	r3, [r7, #12]
 1863 0044 03F12403 		add	r3, r3, #36
 1864 0048 1846     		mov	r0, r3
 1865 004a 3968     		ldr	r1, [r7, #0]
 1866 004c FFF7FEFF 		bl	vTaskPlaceOnEventListRestricted
 1867              	.L141:
1829:../FreeRTOS/Sources/queue.c **** 		}
1830:../FreeRTOS/Sources/queue.c **** 		prvUnlockQueue( pxQueue );
 1868              		.loc 1 1830 0
 1869 0050 F868     		ldr	r0, [r7, #12]
 1870 0052 FFF7FEFF 		bl	prvUnlockQueue
1831:../FreeRTOS/Sources/queue.c **** 	}
 1871              		.loc 1 1831 0
 1872 0056 07F11007 		add	r7, r7, #16
 1873 005a BD46     		mov	sp, r7
 1874 005c 80BD     		pop	{r7, pc}
 1875              		.cfi_endproc
 1876              	.LFE17:
 1878 005e 00BF     		.text
 1879              	.Letext0:
 1880              		.file 2 "/home/frolls/ARM/gcc-arm-none-eabi-4_7-2012q4/bin/../lib/gcc/arm-none-eabi/4.7.3/include/
 1881              		.file 3 "/home/frolls/git/STM32_FreeRTOS_freeModBus/stm32vld_template/FreeRTOS/Headers/portmacro.h
 1882              		.file 4 "/home/frolls/git/STM32_FreeRTOS_freeModBus/stm32vld_template/FreeRTOS/Headers/list.h"
 1883              		.file 5 "/home/frolls/git/STM32_FreeRTOS_freeModBus/stm32vld_template/FreeRTOS/Headers/task.h"
 1884              		.file 6 "/home/frolls/git/STM32_FreeRTOS_freeModBus/stm32vld_template/FreeRTOS/Headers/queue.h"
DEFINED SYMBOLS
                            *ABS*:00000000 queue.c
     /tmp/ccDhRQb0.s:19     .text.xQueueGenericReset:00000000 $t
     /tmp/ccDhRQb0.s:24     .text.xQueueGenericReset:00000000 xQueueGenericReset
     /tmp/ccDhRQb0.s:144    .text.xQueueGenericCreate:00000000 $t
     /tmp/ccDhRQb0.s:149    .text.xQueueGenericCreate:00000000 xQueueGenericCreate
     /tmp/ccDhRQb0.s:244    .text.xQueueCreateMutex:00000000 $t
     /tmp/ccDhRQb0.s:249    .text.xQueueCreateMutex:00000000 xQueueCreateMutex
     /tmp/ccDhRQb0.s:355    .text.xQueueGenericSend:00000000 xQueueGenericSend
     /tmp/ccDhRQb0.s:350    .text.xQueueGenericSend:00000000 $t
     /tmp/ccDhRQb0.s:1274   .text.prvCopyDataToQueue:00000000 prvCopyDataToQueue
     /tmp/ccDhRQb0.s:1697   .text.prvIsQueueFull:00000000 prvIsQueueFull
     /tmp/ccDhRQb0.s:1470   .text.prvUnlockQueue:00000000 prvUnlockQueue
     /tmp/ccDhRQb0.s:566    .text.xQueueGenericSendFromISR:00000000 $t
     /tmp/ccDhRQb0.s:571    .text.xQueueGenericSendFromISR:00000000 xQueueGenericSendFromISR
     /tmp/ccDhRQb0.s:704    .text.xQueueGenericReceive:00000000 $t
     /tmp/ccDhRQb0.s:709    .text.xQueueGenericReceive:00000000 xQueueGenericReceive
     /tmp/ccDhRQb0.s:1403   .text.prvCopyDataFromQueue:00000000 prvCopyDataFromQueue
     /tmp/ccDhRQb0.s:1588   .text.prvIsQueueEmpty:00000000 prvIsQueueEmpty
     /tmp/ccDhRQb0.s:978    .text.xQueueReceiveFromISR:00000000 $t
     /tmp/ccDhRQb0.s:983    .text.xQueueReceiveFromISR:00000000 xQueueReceiveFromISR
     /tmp/ccDhRQb0.s:1118   .text.uxQueueMessagesWaiting:00000000 $t
     /tmp/ccDhRQb0.s:1123   .text.uxQueueMessagesWaiting:00000000 uxQueueMessagesWaiting
     /tmp/ccDhRQb0.s:1170   .text.uxQueueMessagesWaitingFromISR:00000000 $t
     /tmp/ccDhRQb0.s:1175   .text.uxQueueMessagesWaitingFromISR:00000000 uxQueueMessagesWaitingFromISR
     /tmp/ccDhRQb0.s:1218   .text.vQueueDelete:00000000 $t
     /tmp/ccDhRQb0.s:1223   .text.vQueueDelete:00000000 vQueueDelete
     /tmp/ccDhRQb0.s:1270   .text.prvCopyDataToQueue:00000000 $t
     /tmp/ccDhRQb0.s:1399   .text.prvCopyDataFromQueue:00000000 $t
     /tmp/ccDhRQb0.s:1466   .text.prvUnlockQueue:00000000 $t
     /tmp/ccDhRQb0.s:1584   .text.prvIsQueueEmpty:00000000 $t
     /tmp/ccDhRQb0.s:1635   .text.xQueueIsQueueEmptyFromISR:00000000 $t
     /tmp/ccDhRQb0.s:1640   .text.xQueueIsQueueEmptyFromISR:00000000 xQueueIsQueueEmptyFromISR
     /tmp/ccDhRQb0.s:1693   .text.prvIsQueueFull:00000000 $t
     /tmp/ccDhRQb0.s:1746   .text.xQueueIsQueueFullFromISR:00000000 $t
     /tmp/ccDhRQb0.s:1751   .text.xQueueIsQueueFullFromISR:00000000 xQueueIsQueueFullFromISR
     /tmp/ccDhRQb0.s:1806   .text.vQueueWaitForMessageRestricted:00000000 $t
     /tmp/ccDhRQb0.s:1811   .text.vQueueWaitForMessageRestricted:00000000 vQueueWaitForMessageRestricted
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
ulPortSetInterruptMask
vPortEnterCritical
xTaskRemoveFromEventList
vPortYieldFromISR
vListInitialise
vPortExitCritical
pvPortMalloc
vPortFree
vTaskSetTimeOutState
vTaskSuspendAll
xTaskCheckForTimeOut
vTaskPlaceOnEventList
xTaskResumeAll
vPortClearInterruptMask
xTaskGetCurrentTaskHandle
vTaskPriorityInherit
vTaskPriorityDisinherit
memcpy
vTaskMissedYield
vTaskPlaceOnEventListRestricted
